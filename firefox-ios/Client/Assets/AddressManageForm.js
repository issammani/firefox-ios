/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs":
/*!*********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddressMetaData\": () => (/* binding */ AddressMetaData),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// The data below is initially copied from\n// https://chromium-i18n.appspot.com/ssl-aggregate-address\n\n// See https://github.com/googlei18n/libaddressinput/wiki/AddressValidationMetadata for\n// documentation on how to use the data.\n\n// WARNING: DO NOT change any value or add additional properties in addressData.\n// We only accept the metadata of the supported countries that is copied from libaddressinput directly.\n// Please edit AddressMetaDataExtension.sys.mjs instead if you want to add new property as complement\n// or overwrite the existing properties.\n\nconst AddressMetaData = {\n  \"data/AD\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/AD\",\n    key: \"AD\",\n    lang: \"ca\",\n    languages: \"ca\",\n    name: \"ANDORRA\",\n    posturl:\n      \"http://www.correos.es/comun/CodigosPostales/1010_s-CodPostal.asp?Provincia=\",\n    sub_isoids: \"07~02~03~08~04~05~06\",\n    sub_keys:\n      \"Parròquia d'Andorra la Vella~Canillo~Encamp~Escaldes-Engordany~La Massana~Ordino~Sant Julià de Lòria\",\n    sub_names:\n      \"Andorra la Vella~Canillo~Encamp~Escaldes-Engordany~La Massana~Ordino~Sant Julià de Lòria\",\n    sub_zipexs: \"AD500~AD100~AD200~AD700~AD400~AD300~AD600\",\n    sub_zips: \"AD50[01]~AD10[01]~AD20[01]~AD70[01]~AD40[01]~AD30[01]~AD60[01]\",\n    zip: \"AD[1-7]0\\\\d\",\n    zipex: \"AD100,AD501,AD700\",\n  },\n  \"data/AE\": {\n    fmt: \"%N%n%O%n%A%n%S\",\n    id: \"data/AE\",\n    key: \"AE\",\n    lang: \"ar\",\n    languages: \"ar\",\n    lfmt: \"%N%n%O%n%A%n%S\",\n    name: \"UNITED ARAB EMIRATES\",\n    require: \"AS\",\n    state_name_type: \"emirate\",\n    sub_isoids: \"AZ~SH~FU~UQ~DU~RK~AJ\",\n    sub_keys:\n      \"أبو ظبي~إمارة الشارقةّ~الفجيرة~ام القيوين~إمارة دبيّ~إمارة رأس الخيمة~عجمان\",\n    sub_lnames:\n      \"Abu Dhabi~Sharjah~Fujairah~Umm Al Quwain~Dubai~Ras al Khaimah~Ajman\",\n    sub_names: \"أبو ظبي~الشارقة~الفجيرة~ام القيوين~دبي~رأس الخيمة~عجمان\",\n  },\n  \"data/AF\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/AF\",\n    key: \"AF\",\n    name: \"AFGHANISTAN\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1001,2601,3801\",\n  },\n  \"data/AG\": {\n    id: \"data/AG\",\n    key: \"AG\",\n    name: \"ANTIGUA AND BARBUDA\",\n    require: \"A\",\n  },\n  \"data/AI\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/AI\",\n    key: \"AI\",\n    name: \"ANGUILLA\",\n    zip: \"(?:AI-)?2640\",\n    zipex: \"2640\",\n  },\n  \"data/AL\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/AL\",\n    key: \"AL\",\n    name: \"ALBANIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1001,1017,3501\",\n  },\n  \"data/AM\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C%n%S\",\n    id: \"data/AM\",\n    key: \"AM\",\n    lang: \"hy\",\n    languages: \"hy\",\n    lfmt: \"%N%n%O%n%A%n%Z%n%C%n%S\",\n    name: \"ARMENIA\",\n    sub_isoids: \"AG~AR~AV~GR~ER~LO~KT~SH~SU~VD~TV\",\n    sub_keys:\n      \"Արագածոտն~Արարատ~Արմավիր~Գեղարքունիք~Երևան~Լոռի~Կոտայք~Շիրակ~Սյունիք~Վայոց ձոր~Տավուշ\",\n    sub_lnames:\n      \"Aragatsotn~Ararat~Armavir~Gegharkunik~Yerevan~Lori~Kotayk~Shirak~Syunik~Vayots Dzor~Tavush\",\n    sub_zipexs:\n      \"0201,0514~0601,0823~0901,1149~1201,1626~0000,0099~1701,2117~2201,2506~2601,3126~3201,3519~3601,3810~3901,4216\",\n    sub_zips:\n      \"0[2-5]~0[6-8]~09|1[01]~1[2-6]~00~1[7-9]|2[01]~2[2-5]~2[6-9]|3[01]~3[2-5]~3[6-8]~39|4[0-2]\",\n    zip: \"(?:37)?\\\\d{4}\",\n    zipex: \"375010,0002,0010\",\n  },\n  \"data/AO\": { id: \"data/AO\", key: \"AO\", name: \"ANGOLA\" },\n  \"data/AQ\": { id: \"data/AQ\", key: \"AQ\", name: \"ANTARCTICA\" },\n  \"data/AR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/AR\",\n    key: \"AR\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"ARGENTINA\",\n    posturl: \"http://www.correoargentino.com.ar/formularios/cpa\",\n    sub_isoids: \"B~K~H~U~C~X~W~E~P~Y~L~F~M~N~Q~R~A~J~D~Z~S~G~V~T\",\n    sub_keys:\n      \"Buenos Aires~Catamarca~Chaco~Chubut~Ciudad Autónoma de Buenos Aires~Córdoba~Corrientes~Entre Ríos~Formosa~Jujuy~La Pampa~La Rioja~Mendoza~Misiones~Neuquén~Río Negro~Salta~San Juan~San Luis~Santa Cruz~Santa Fe~Santiago del Estero~Tierra del Fuego~Tucumán\",\n    sub_names:\n      \"Buenos Aires~Catamarca~Chaco~Chubut~Ciudad Autónoma de Buenos Aires~Córdoba~Corrientes~Entre Ríos~Formosa~Jujuy~La Pampa~La Rioja~Mendoza~Misiones~Neuquén~Río Negro~Salta~San Juan~San Luis~Santa Cruz~Santa Fe~Santiago del Estero~Tierra del Fuego~Tucumán\",\n    sub_zips:\n      \"B?[1-36-8]~K?[45]~H?3~U?[89]~C?1~X?[235-8]~W?3~E?[1-3]~P?[37]~Y?4~L?[3568]~F?5~M?[56]~N?3~Q?[38]~R?[89]~A?[34]~J?5~D?[4-6]~Z?[89]~S?[2368]~G?[2-5]~V?9~T?[45]\",\n    upper: \"ACZ\",\n    zip: \"((?:[A-HJ-NP-Z])?\\\\d{4})([A-Z]{3})?\",\n    zipex: \"C1070AAM,C1000WAM,B1000TBU,X5187XAB\",\n  },\n  \"data/AS\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/AS\",\n    key: \"AS\",\n    name: \"AMERICAN SAMOA\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(96799)(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96799\",\n  },\n  \"data/AT\": {\n    fmt: \"%O%n%N%n%A%n%Z %C\",\n    id: \"data/AT\",\n    key: \"AT\",\n    name: \"AUSTRIA\",\n    posturl: \"http://www.post.at/post_subsite_postleitzahlfinder.php\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1010,3741\",\n  },\n  \"data/AU\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/AU\",\n    key: \"AU\",\n    lang: \"en\",\n    languages: \"en\",\n    locality_name_type: \"suburb\",\n    name: \"AUSTRALIA\",\n    posturl: \"http://www1.auspost.com.au/postcodes/\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids: \"ACT~NSW~NT~QLD~SA~TAS~VIC~WA\",\n    sub_keys: \"ACT~NSW~NT~QLD~SA~TAS~VIC~WA\",\n    sub_names:\n      \"Australian Capital Territory~New South Wales~Northern Territory~Queensland~South Australia~Tasmania~Victoria~Western Australia\",\n    sub_zipexs:\n      \"0200,2540,2618,2999~1000,2888,3585,3707~0800,0999~4000,9999~5000~7000,7999~3000,8000~6000,0872\",\n    sub_zips:\n      \"29|2540|260|261[0-8]|02|2620~1|2[0-57-8]|26[2-9]|261[189]|3500|358[56]|3644|3707~0[89]~[49]~5|0872~7~[38]~6|0872\",\n    upper: \"CS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2060,3171,6430,4000,4006,3001\",\n  },\n  \"data/AW\": { id: \"data/AW\", key: \"AW\", name: \"ARUBA\" },\n  \"data/AZ\": {\n    fmt: \"%N%n%O%n%A%nAZ %Z %C\",\n    id: \"data/AZ\",\n    key: \"AZ\",\n    name: \"AZERBAIJAN\",\n    postprefix: \"AZ \",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000\",\n  },\n  \"data/BA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/BA\",\n    key: \"BA\",\n    name: \"BOSNIA AND HERZEGOVINA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"71000\",\n  },\n  \"data/BB\": {\n    fmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    id: \"data/BB\",\n    key: \"BB\",\n    name: \"BARBADOS\",\n    state_name_type: \"parish\",\n    zip: \"BB\\\\d{5}\",\n    zipex: \"BB23026,BB22025\",\n  },\n  \"data/BD\": {\n    fmt: \"%N%n%O%n%A%n%C - %Z\",\n    id: \"data/BD\",\n    key: \"BD\",\n    name: \"BANGLADESH\",\n    posturl: \"http://www.bangladeshpost.gov.bd/PostCode.asp\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1340,1000\",\n  },\n  \"data/BE\": {\n    fmt: \"%O%n%N%n%A%n%Z %C\",\n    id: \"data/BE\",\n    key: \"BE\",\n    name: \"BELGIUM\",\n    posturl:\n      \"http://www.post.be/site/nl/residential/customerservice/search/postal_codes.html\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"4000,1000\",\n  },\n  \"data/BF\": {\n    fmt: \"%N%n%O%n%A%n%C %X\",\n    id: \"data/BF\",\n    key: \"BF\",\n    name: \"BURKINA FASO\",\n  },\n  \"data/BG\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/BG\",\n    key: \"BG\",\n    name: \"BULGARIA (REP.)\",\n    posturl: \"http://www.bgpost.bg/?cid=5\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000,1700\",\n  },\n  \"data/BH\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BH\",\n    key: \"BH\",\n    name: \"BAHRAIN\",\n    zip: \"(?:\\\\d|1[0-2])\\\\d{2}\",\n    zipex: \"317\",\n  },\n  \"data/BI\": { id: \"data/BI\", key: \"BI\", name: \"BURUNDI\" },\n  \"data/BJ\": { id: \"data/BJ\", key: \"BJ\", name: \"BENIN\", upper: \"AC\" },\n  \"data/BL\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/BL\",\n    key: \"BL\",\n    name: \"SAINT BARTHELEMY\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78][01]\\\\d{2}\",\n    zipex: \"97100\",\n  },\n  \"data/BM\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BM\",\n    key: \"BM\",\n    name: \"BERMUDA\",\n    posturl: \"http://www.landvaluation.bm/\",\n    zip: \"[A-Z]{2} ?[A-Z0-9]{2}\",\n    zipex: \"FL 07,HM GX,HM 12\",\n  },\n  \"data/BN\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BN\",\n    key: \"BN\",\n    name: \"BRUNEI DARUSSALAM\",\n    posturl: \"http://www.post.gov.bn/SitePages/postcodes.aspx\",\n    zip: \"[A-Z]{2} ?\\\\d{4}\",\n    zipex: \"BT2328,KA1131,BA1511\",\n  },\n  \"data/BO\": { id: \"data/BO\", key: \"BO\", name: \"BOLIVIA\", upper: \"AC\" },\n  \"data/BQ\": {\n    id: \"data/BQ\",\n    key: \"BQ\",\n    name: \"BONAIRE, SINT EUSTATIUS, AND SABA\",\n  },\n  \"data/BR\": {\n    fmt: \"%O%n%N%n%A%n%D%n%C-%S%n%Z\",\n    id: \"data/BR\",\n    key: \"BR\",\n    lang: \"pt\",\n    languages: \"pt\",\n    name: \"BRAZIL\",\n    posturl: \"http://www.buscacep.correios.com.br/\",\n    require: \"ASCZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AC~AL~AP~AM~BA~CE~DF~ES~GO~MA~MT~MS~MG~PA~PB~PR~PE~PI~RJ~RN~RS~RO~RR~SC~SP~SE~TO\",\n    sub_keys:\n      \"AC~AL~AP~AM~BA~CE~DF~ES~GO~MA~MT~MS~MG~PA~PB~PR~PE~PI~RJ~RN~RS~RO~RR~SC~SP~SE~TO\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"Acre~Alagoas~Amapá~Amazonas~Bahia~Ceará~Distrito Federal~Espírito Santo~Goiás~Maranhão~Mato Grosso~Mato Grosso do Sul~Minas Gerais~Pará~Paraíba~Paraná~Pernambuco~Piauí~Rio de Janeiro~Rio Grande do Norte~Rio Grande do Sul~Rondônia~Roraima~Santa Catarina~São Paulo~Sergipe~Tocantins\",\n    sub_zipexs:\n      \"69900-000,69999-999~57000-000,57999-999~68900-000,68999-999~69000-000,69400-123~40000-000,48999-999~60000-000,63999-999~70000-000,73500-123~29000-000,29999-999~72800-000,73700-123~65000-000,65999-999~78000-000,78899-999~79000-000,79999-999~30000-000,39999-999~66000-000,68899-999~58000-000,58999-999~80000-000,87999-999~50000-000,56999-999~64000-000,64999-999~20000-000,28999-999~59000-000,59999-999~90000-000,99999-999~76800-000,78900-000,78999-999~69300-000,69399-999~88000-000,89999-999~01000-000,13000-123~49000-000,49999-999~77000-000,77999-999\",\n    sub_zips:\n      \"699~57~689~69[0-24-8]~4[0-8]~6[0-3]~7[0-1]|72[0-7]|73[0-6]~29~72[89]|73[7-9]|7[4-6]~65~78[0-8]~79~3~6[6-7]|68[0-8]~58~8[0-7]~5[0-6]~64~2[0-8]~59~9~76[89]|789~693~8[89]~[01][1-9]~49~77\",\n    sublocality_name_type: \"neighborhood\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}-?\\\\d{3}\",\n    zipex: \"40301-110,70002-900\",\n  },\n  \"data/BS\": {\n    fmt: \"%N%n%O%n%A%n%C, %S\",\n    id: \"data/BS\",\n    key: \"BS\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"BAHAMAS\",\n    state_name_type: \"island\",\n    sub_isoids: \"~AK~~BY~BI~CI~~~EX~~HI~IN~LI~MG~~RI~RC~SS~SW\",\n    sub_keys:\n      \"Abaco~Acklins~Andros~Berry Islands~Bimini~Cat Island~Crooked Island~Eleuthera~Exuma~Grand Bahama~Harbour Island~Inagua~Long Island~Mayaguana~N.P.~Ragged Island~Rum Cay~San Salvador~Spanish Wells\",\n    sub_names:\n      \"Abaco Islands~Acklins~Andros Island~Berry Islands~Bimini~Cat Island~Crooked Island~Eleuthera~Exuma and Cays~Grand Bahama~Harbour Island~Inagua~Long Island~Mayaguana~New Providence~Ragged Island~Rum Cay~San Salvador~Spanish Wells\",\n  },\n  \"data/BT\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/BT\",\n    key: \"BT\",\n    name: \"BHUTAN\",\n    posturl: \"http://www.bhutanpost.bt/postcodes/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11001,31101,35003\",\n  },\n  \"data/BV\": { id: \"data/BV\", key: \"BV\", name: \"BOUVET ISLAND\" },\n  \"data/BW\": { id: \"data/BW\", key: \"BW\", name: \"BOTSWANA\" },\n  \"data/BY\": {\n    fmt: \"%S%n%Z %C%n%A%n%O%n%N\",\n    id: \"data/BY\",\n    key: \"BY\",\n    name: \"BELARUS\",\n    posturl: \"http://ex.belpost.by/addressbook/\",\n    zip: \"\\\\d{6}\",\n    zipex: \"223016,225860,220050\",\n  },\n  \"data/BZ\": { id: \"data/BZ\", key: \"BZ\", name: \"BELIZE\" },\n  \"data/CA\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/CA\",\n    key: \"CA\",\n    lang: \"en\",\n    languages: \"en~fr\",\n    name: \"CANADA\",\n    posturl: \"https://www.canadapost.ca/cpo/mc/personal/postalcode/fpc.jsf\",\n    require: \"ACSZ\",\n    sub_isoids: \"AB~BC~MB~NB~NL~NT~NS~NU~ON~PE~QC~SK~YT\",\n    sub_keys: \"AB~BC~MB~NB~NL~NT~NS~NU~ON~PE~QC~SK~YT\",\n    sub_names:\n      \"Alberta~British Columbia~Manitoba~New Brunswick~Newfoundland and Labrador~Northwest Territories~Nova Scotia~Nunavut~Ontario~Prince Edward Island~Quebec~Saskatchewan~Yukon\",\n    sub_zips:\n      \"T~V~R~E~A~X0E|X0G|X1A~B~X0A|X0B|X0C~K|L|M|N|P~C~G|H|J|K1A~S|R8A~Y\",\n    upper: \"ACNOSZ\",\n    zip: \"[ABCEGHJKLMNPRSTVXY]\\\\d[ABCEGHJ-NPRSTV-Z] ?\\\\d[ABCEGHJ-NPRSTV-Z]\\\\d\",\n    zipex: \"H3Z 2Y7,V8X 3X4,T0L 1K0,T0H 1A0,K1A 0B1\",\n  },\n  \"data/CA--fr\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/CA--fr\",\n    key: \"CA\",\n    lang: \"fr\",\n    name: \"CANADA\",\n    posturl: \"https://www.canadapost.ca/cpo/mc/personal/postalcode/fpc.jsf\",\n    require: \"ACSZ\",\n    sub_isoids: \"AB~BC~PE~MB~NB~NS~NU~ON~QC~SK~NL~NT~YT\",\n    sub_keys: \"AB~BC~PE~MB~NB~NS~NU~ON~QC~SK~NL~NT~YT\",\n    sub_names:\n      \"Alberta~Colombie-Britannique~Île-du-Prince-Édouard~Manitoba~Nouveau-Brunswick~Nouvelle-Écosse~Nunavut~Ontario~Québec~Saskatchewan~Terre-Neuve-et-Labrador~Territoires du Nord-Ouest~Yukon\",\n    sub_zips:\n      \"T~V~C~R~E~B~X0A|X0B|X0C~K|L|M|N|P~G|H|J|K1A~S|R8A~A~X0E|X0G|X1A~Y\",\n    upper: \"ACNOSZ\",\n    zip: \"[ABCEGHJKLMNPRSTVXY]\\\\d[ABCEGHJ-NPRSTV-Z] ?\\\\d[ABCEGHJ-NPRSTV-Z]\\\\d\",\n    zipex: \"H3Z 2Y7,V8X 3X4,T0L 1K0,T0H 1A0,K1A 0B1\",\n  },\n  \"data/CC\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/CC\",\n    key: \"CC\",\n    name: \"COCOS (KEELING) ISLANDS\",\n    upper: \"CS\",\n    zip: \"6799\",\n    zipex: \"6799\",\n  },\n  \"data/CD\": { id: \"data/CD\", key: \"CD\", name: \"CONGO (DEM. REP.)\" },\n  \"data/CF\": { id: \"data/CF\", key: \"CF\", name: \"CENTRAL AFRICAN REPUBLIC\" },\n  \"data/CG\": { id: \"data/CG\", key: \"CG\", name: \"CONGO (REP.)\" },\n  \"data/CH\": {\n    fmt: \"%O%n%N%n%A%nCH-%Z %C\",\n    id: \"data/CH\",\n    key: \"CH\",\n    name: \"SWITZERLAND\",\n    postprefix: \"CH-\",\n    posturl: \"http://www.post.ch/db/owa/pv_plz_pack/pr_main\",\n    require: \"ACZ\",\n    upper: \"\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2544,1211,1556,3030\",\n  },\n  \"data/CI\": {\n    fmt: \"%N%n%O%n%X %A %C %X\",\n    id: \"data/CI\",\n    key: \"CI\",\n    name: \"COTE D'IVOIRE\",\n  },\n  \"data/CK\": { id: \"data/CK\", key: \"CK\", name: \"COOK ISLANDS\" },\n  \"data/CL\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/CL\",\n    key: \"CL\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"CHILE\",\n    posturl: \"http://www.correos.cl/SitePages/home.aspx\",\n    sub_isoids: \"AN~AR~AP~AT~AI~BI~CO~LI~LL~LR~MA~ML~RM~TA~VS\",\n    sub_keys:\n      \"Antofagasta~Araucanía~Arica y Parinacota~Atacama~Aysén~Biobío~Coquimbo~O'Higgins~Los Lagos~Los Ríos~Magallanes~Maule~Región Metropolitana~Tarapacá~Valparaíso\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"Antofagasta~Araucanía~Arica y Parinacota~Atacama~Aysén del General Carlos Ibáñez del Campo~Biobío~Coquimbo~Libertador General Bernardo O'Higgins~Los Lagos~Los Ríos~Magallanes y de la Antártica Chilena~Maule~Metropolitana de Santiago~Tarapacá~Valparaíso\",\n    zip: \"\\\\d{7}\",\n    zipex: \"8340457,8720019,1230000,8329100\",\n  },\n  \"data/CM\": { id: \"data/CM\", key: \"CM\", name: \"CAMEROON\" },\n  \"data/CN\": {\n    fmt: \"%Z%n%S%C%D%n%A%n%O%n%N\",\n    id: \"data/CN\",\n    key: \"CN\",\n    lang: \"zh\",\n    languages: \"zh\",\n    lfmt: \"%N%n%O%n%A%n%D%n%C%n%S, %Z\",\n    name: \"CHINA\",\n    posturl: \"http://www.ems.com.cn/serviceguide/you_bian_cha_xun.html\",\n    require: \"ACSZ\",\n    sub_isoids:\n      \"34~92~11~50~35~62~44~45~52~46~13~41~23~42~43~22~32~36~21~15~64~63~37~14~61~31~51~71~12~54~91~65~53~33\",\n    sub_keys:\n      \"安徽省~澳门~北京市~重庆市~福建省~甘肃省~广东省~广西壮族自治区~贵州省~海南省~河北省~河南省~黑龙江省~湖北省~湖南省~吉林省~江苏省~江西省~辽宁省~内蒙古自治区~宁夏回族自治区~青海省~山东省~山西省~陕西省~上海市~四川省~台湾~天津市~西藏自治区~香港~新疆维吾尔自治区~云南省~浙江省\",\n    sub_lnames:\n      \"Anhui Sheng~Macau~Beijing Shi~Chongqing Shi~Fujian Sheng~Gansu Sheng~Guangdong Sheng~Guangxi Zhuangzuzizhiqu~Guizhou Sheng~Hainan Sheng~Hebei Sheng~Henan Sheng~Heilongjiang Sheng~Hubei Sheng~Hunan Sheng~Jilin Sheng~Jiangsu Sheng~Jiangxi Sheng~Liaoning Sheng~Neimenggu Zizhiqu~Ningxia Huizuzizhiqu~Qinghai Sheng~Shandong Sheng~Shanxi Sheng~Shaanxi Sheng~Shanghai Shi~Sichuan Sheng~Taiwan~Tianjin Shi~Xizang Zizhiqu~Hong Kong~Xinjiang Weiwuerzizhiqu~Yunnan Sheng~Zhejiang Sheng\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"安徽省~澳门~北京市~重庆市~福建省~甘肃省~广东省~广西~贵州省~海南省~河北省~河南省~黑龙江省~湖北省~湖南省~吉林省~江苏省~江西省~辽宁省~内蒙古~宁夏~青海省~山东省~山西省~陕西省~上海市~四川省~台湾~天津市~西藏~香港~新疆~云南省~浙江省\",\n    sub_xrequires: \"~A~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ACS~~~\",\n    sub_xzips: \"~999078~~~~~~~~~~~~~~~~~~~~~~~~~~\\\\d{3}(\\\\d{2})?~~~999077~~~\",\n    sublocality_name_type: \"district\",\n    upper: \"S\",\n    zip: \"\\\\d{6}\",\n    zipex: \"266033,317204,100096,100808\",\n  },\n  \"data/CO\": {\n    fmt: \"%N%n%O%n%A%n%C, %S, %Z\",\n    id: \"data/CO\",\n    key: \"CO\",\n    name: \"COLOMBIA\",\n    posturl: \"http://www.codigopostal.gov.co/\",\n    require: \"AS\",\n    state_name_type: \"department\",\n    zip: \"\\\\d{6}\",\n    zipex: \"111221,130001,760011\",\n  },\n  \"data/CR\": {\n    fmt: \"%N%n%O%n%A%n%S, %C%n%Z\",\n    id: \"data/CR\",\n    key: \"CR\",\n    name: \"COSTA RICA\",\n    posturl: \"https://www.correos.go.cr/nosotros/codigopostal/busqueda.html\",\n    require: \"ACS\",\n    zip: \"\\\\d{4,5}|\\\\d{3}-\\\\d{4}\",\n    zipex: \"1000,2010,1001\",\n  },\n  \"data/CU\": {\n    fmt: \"%N%n%O%n%A%n%C %S%n%Z\",\n    id: \"data/CU\",\n    key: \"CU\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"CUBA\",\n    sub_isoids: \"15~09~08~06~12~14~11~99~03~10~04~16~01~07~13~05\",\n    sub_keys:\n      \"Artemisa~Camagüey~Ciego de Ávila~Cienfuegos~Granma~Guantánamo~Holguín~Isla de la Juventud~La Habana~Las Tunas~Matanzas~Mayabeque~Pinar del Río~Sancti Spíritus~Santiago de Cuba~Villa Clara\",\n    zip: \"\\\\d{5}\",\n    zipex: \"10700\",\n  },\n  \"data/CV\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/CV\",\n    key: \"CV\",\n    lang: \"pt\",\n    languages: \"pt\",\n    name: \"CAPE VERDE\",\n    state_name_type: \"island\",\n    sub_isoids: \"BV~BR~~MA~SL~~~~SV\",\n    sub_keys:\n      \"Boa Vista~Brava~Fogo~Maio~Sal~Santiago~Santo Antão~São Nicolau~São Vicente\",\n    zip: \"\\\\d{4}\",\n    zipex: \"7600\",\n  },\n  \"data/CW\": { id: \"data/CW\", key: \"CW\", name: \"CURACAO\" },\n  \"data/CX\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/CX\",\n    key: \"CX\",\n    name: \"CHRISTMAS ISLAND\",\n    upper: \"CS\",\n    zip: \"6798\",\n    zipex: \"6798\",\n  },\n  \"data/CY\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/CY\",\n    key: \"CY\",\n    name: \"CYPRUS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2008,3304,1900\",\n  },\n  \"data/CZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/CZ\",\n    key: \"CZ\",\n    name: \"CZECH REP.\",\n    posturl: \"http://psc.ceskaposta.cz/CleanForm.action\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"100 00,251 66,530 87,110 00,225 99\",\n  },\n  \"data/DE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DE\",\n    key: \"DE\",\n    name: \"GERMANY\",\n    posturl: \"http://www.postdirekt.de/plzserver/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{5}\",\n    zipex: \"26133,53225\",\n  },\n  \"data/DJ\": { id: \"data/DJ\", key: \"DJ\", name: \"DJIBOUTI\" },\n  \"data/DK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DK\",\n    key: \"DK\",\n    name: \"DENMARK\",\n    posturl:\n      \"http://www.postdanmark.dk/da/Privat/Kundeservice/postnummerkort/Sider/Find-postnummer.aspx\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"8660,1566\",\n  },\n  \"data/DM\": { id: \"data/DM\", key: \"DM\", name: \"DOMINICA\" },\n  \"data/DO\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DO\",\n    key: \"DO\",\n    name: \"DOMINICAN REP.\",\n    posturl: \"http://inposdom.gob.do/codigo-postal/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11903,10101\",\n  },\n  \"data/DZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/DZ\",\n    key: \"DZ\",\n    name: \"ALGERIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"40304,16027\",\n  },\n  \"data/EC\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/EC\",\n    key: \"EC\",\n    name: \"ECUADOR\",\n    posturl: \"http://www.codigopostal.gob.ec/\",\n    upper: \"CZ\",\n    zip: \"\\\\d{6}\",\n    zipex: \"090105,092301\",\n  },\n  \"data/EE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/EE\",\n    key: \"EE\",\n    name: \"ESTONIA\",\n    posturl: \"https://www.omniva.ee/era/sihtnumbrite_otsing\",\n    zip: \"\\\\d{5}\",\n    zipex: \"69501,11212\",\n  },\n  \"data/EG\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    id: \"data/EG\",\n    key: \"EG\",\n    lang: \"ar\",\n    languages: \"ar\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    name: \"EGYPT\",\n    sub_isoids:\n      \"ASN~AST~ALX~IS~LX~BA~BH~GZ~DK~SUZ~SHR~GH~FYM~C~KB~MNF~MN~WAD~BNS~PTS~JS~DT~SHG~SIN~KN~KFS~MT\",\n    sub_keys:\n      \"أسوان~أسيوط~الإسكندرية~الإسماعيلية~الأقصر~البحر الأحمر~البحيرة~الجيزة~الدقهلية~السويس~الشرقية~الغربية~الفيوم~القاهرة~القليوبية~المنوفية~المنيا~الوادي الجديد~بني سويف~بورسعيد~جنوب سيناء~دمياط~سوهاج~شمال سيناء~قنا~كفر الشيخ~مطروح\",\n    sub_lnames:\n      \"Aswan Governorate~Asyut Governorate~Alexandria Governorate~Ismailia Governorate~Luxor Governorate~Red Sea Governorate~El Beheira Governorate~Giza Governorate~Dakahlia Governorate~Suez Governorate~Ash Sharqia Governorate~Gharbia Governorate~Faiyum Governorate~Cairo Governorate~Qalyubia Governorate~Menofia Governorate~Menia Governorate~New Valley Governorate~Beni Suef Governorate~Port Said Governorate~South Sinai Governorate~Damietta Governorate~Sohag Governorate~North Sinai Governorate~Qena Governorate~Kafr El Sheikh Governorate~Matrouh Governorate\",\n    sub_zipexs:\n      \"81000~71000~21000,23000~41000~85000~84000~22000~12000~35000~43000~44000~31000~63000~11000~13000~32000~61000~72000~62000~42000~46000~34000~82000~45000~83000~33000~51000\",\n    sub_zips:\n      \"81~71~2[13]~41~85~84~22~12~35~43~44~31~63~11~13~32~61~72~62~42~46~34~82~45~83~33~51\",\n    zip: \"\\\\d{5}\",\n    zipex: \"12411,11599\",\n  },\n  \"data/EH\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/EH\",\n    key: \"EH\",\n    name: \"WESTERN SAHARA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"70000,72000\",\n  },\n  \"data/ER\": { id: \"data/ER\", key: \"ER\", name: \"ERITREA\" },\n  \"data/ES\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES\",\n    key: \"ES\",\n    lang: \"es\",\n    languages: \"es~ca~gl~eu\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"VI~AB~A~AL~O~AV~BA~B~BU~CC~CA~S~CS~CE~CR~CO~CU~GI~GR~GU~SS~H~HU~PM~J~C~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~BI~ZA~Z\",\n    sub_names:\n      \"Álava~Albacete~Alicante~Almería~Asturias~Ávila~Badajoz~Barcelona~Burgos~Cáceres~Cádiz~Cantabria~Castellón~Ceuta~Ciudad Real~Córdoba~Cuenca~Girona~Granada~Guadalajara~Guipúzcoa~Huelva~Huesca~Islas Baleares~Jaén~La Coruña~La Rioja~Las Palmas~León~Lérida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valencia~Valladolid~Vizcaya~Zamora~Zaragoza\",\n    sub_zips:\n      \"01~02~03~04~33~05~06~08~09~10~11~39~12~51~13~14~16~17~18~19~20~21~22~07~23~15~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~48~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ES--ca\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES--ca\",\n    key: \"ES\",\n    lang: \"ca\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"A~AB~AL~VI~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~CO~CU~GI~GR~GU~SS~H~HU~PM~J~C~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~ZA~Z\",\n    sub_names:\n      \"Alacant~Albacete~Almeria~Araba~Asturias~Àvila~Badajoz~Barcelona~Bizkaia~Burgos~Cáceres~Cadis~Cantabria~Castelló~Ceuta~Ciudad Real~Córdoba~Cuenca~Girona~Granada~Guadalajara~Guipúscoa~Huelva~Huesca~Illes Balears~Jaén~La Corunya~La Rioja~Las Palmas~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~València~Valladolid~Zamora~Zaragoza\",\n    sub_zips:\n      \"03~02~04~01~33~05~06~08~48~09~10~11~39~12~51~13~14~16~17~18~19~20~21~22~07~23~15~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ES--eu\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES--eu\",\n    key: \"ES\",\n    lang: \"eu\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"A~AB~AL~VI~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~C~CU~SS~GI~GR~GU~H~HU~PM~J~CO~LO~GC~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~ZA~Z\",\n    sub_names:\n      \"Alacant~Albacete~Almería~Araba~Asturias~Ávila~Badajoz~Barcelona~Bizkaia~Burgos~Cáceres~Cádiz~Cantabria~Castelló~Ceuta~Ciudad Real~Coruña~Cuenca~Gipuzkoa~Girona~Granada~Guadalajara~Huelva~Huesca~Illes Balears~Jaén~Kordoba~La Rioja~Las Palmas~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murtzia~Nafarroa~Ourense~Palentzia~Pontevedra~Salamanca~Santa Cruz Tenerifekoa~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valentzia~Valladolid~Zamora~Zaragoza\",\n    sub_zips:\n      \"03~02~04~01~33~05~06~08~48~09~10~11~39~12~51~13~15~16~20~17~18~19~21~22~07~23~14~26~35~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ES--gl\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/ES--gl\",\n    key: \"ES\",\n    lang: \"gl\",\n    name: \"SPAIN\",\n    posturl:\n      \"http://www.correos.es/contenido/13-MenuRec2/04-MenuRec24/1010_s-CodPostal.asp\",\n    require: \"ACSZ\",\n    sub_keys:\n      \"C~A~VI~AB~AL~GC~O~AV~BA~B~BI~BU~CC~CA~S~CS~CE~CR~CO~CU~GR~GU~SS~H~HU~PM~LO~LE~L~LU~M~MA~ML~MU~NA~OR~P~PO~SA~TF~SG~SE~SO~T~TE~TO~V~VA~J~GI~ZA~Z\",\n    sub_names:\n      \"A Coruña~Alacant~Álava~Albacete~Almería~As Palmas~Asturias~Ávila~Badaxoz~Barcelona~Biscaia~Burgos~Cáceres~Cádiz~Cantabria~Castelló~Ceuta~Cidade Real~Córdoba~Cuenca~Granada~Guadalajara~Guipúscoa~Huelva~Huesca~Illas Baleares~La Rioja~León~Lleida~Lugo~Madrid~Málaga~Melilla~Murcia~Navarra~Ourense~Palencia~Pontevedra~Salamanca~Santa Cruz de Tenerife~Segovia~Sevilla~Soria~Tarragona~Teruel~Toledo~Valencia~Valladolid~Xaén~Xirona~Zamora~Zaragoza\",\n    sub_zips:\n      \"15~03~01~02~04~35~33~05~06~08~48~09~10~11~39~12~51~13~14~16~18~19~20~21~22~07~26~24~25~27~28~29~52~30~31~32~34~36~37~38~40~41~42~43~44~45~46~47~23~17~49~50\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"28039,28300,28070\",\n  },\n  \"data/ET\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/ET\",\n    key: \"ET\",\n    name: \"ETHIOPIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000\",\n  },\n  \"data/FI\": {\n    fmt: \"%O%n%N%n%A%nFI-%Z %C\",\n    id: \"data/FI\",\n    key: \"FI\",\n    name: \"FINLAND\",\n    postprefix: \"FI-\",\n    posturl: \"http://www.verkkoposti.com/e3/postinumeroluettelo\",\n    require: \"ACZ\",\n    zip: \"\\\\d{5}\",\n    zipex: \"00550,00011\",\n  },\n  \"data/FJ\": { id: \"data/FJ\", key: \"FJ\", name: \"FIJI\" },\n  \"data/FK\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/FK\",\n    key: \"FK\",\n    name: \"FALKLAND ISLANDS (MALVINAS)\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"FIQQ 1ZZ\",\n    zipex: \"FIQQ 1ZZ\",\n  },\n  \"data/FM\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/FM\",\n    key: \"FM\",\n    name: \"MICRONESIA (Federated State of)\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(9694[1-4])(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96941,96944\",\n  },\n  \"data/FO\": {\n    fmt: \"%N%n%O%n%A%nFO%Z %C\",\n    id: \"data/FO\",\n    key: \"FO\",\n    name: \"FAROE ISLANDS\",\n    postprefix: \"FO\",\n    posturl: \"http://www.postur.fo/\",\n    zip: \"\\\\d{3}\",\n    zipex: \"100\",\n  },\n  \"data/FR\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/FR\",\n    key: \"FR\",\n    name: \"FRANCE\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"CX\",\n    zip: \"\\\\d{2} ?\\\\d{3}\",\n    zipex: \"33380,34092,33506\",\n  },\n  \"data/GA\": { id: \"data/GA\", key: \"GA\", name: \"GABON\" },\n  \"data/GB\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/GB\",\n    key: \"GB\",\n    locality_name_type: \"post_town\",\n    name: \"UNITED KINGDOM\",\n    posturl: \"http://www.royalmail.com/postcode-finder\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"GIR ?0AA|(?:(?:AB|AL|B|BA|BB|BD|BF|BH|BL|BN|BR|BS|BT|BX|CA|CB|CF|CH|CM|CO|CR|CT|CV|CW|DA|DD|DE|DG|DH|DL|DN|DT|DY|E|EC|EH|EN|EX|FK|FY|G|GL|GY|GU|HA|HD|HG|HP|HR|HS|HU|HX|IG|IM|IP|IV|JE|KA|KT|KW|KY|L|LA|LD|LE|LL|LN|LS|LU|M|ME|MK|ML|N|NE|NG|NN|NP|NR|NW|OL|OX|PA|PE|PH|PL|PO|PR|RG|RH|RM|S|SA|SE|SG|SK|SL|SM|SN|SO|SP|SR|SS|ST|SW|SY|TA|TD|TF|TN|TQ|TR|TS|TW|UB|W|WA|WC|WD|WF|WN|WR|WS|WV|YO|ZE)(?:\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}))|BFPO ?\\\\d{1,4}\",\n    zipex:\n      \"EC1Y 8SY,GIR 0AA,M2 5BQ,M34 4AB,CR0 2YR,DN16 9AA,W1A 4ZZ,EC1A 1HQ,OX14 4PG,BS18 8HF,NR25 7HG,RH6 0NP,BH23 6AA,B6 5BA,SO23 9AP,PO1 3AX,BFPO 61\",\n  },\n  \"data/GD\": { id: \"data/GD\", key: \"GD\", name: \"GRENADA (WEST INDIES)\" },\n  \"data/GE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GE\",\n    key: \"GE\",\n    name: \"GEORGIA\",\n    posturl: \"http://www.georgianpost.ge/index.php?page=10\",\n    zip: \"\\\\d{4}\",\n    zipex: \"0101\",\n  },\n  \"data/GF\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/GF\",\n    key: \"GF\",\n    name: \"FRENCH GUIANA\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]3\\\\d{2}\",\n    zipex: \"97300\",\n  },\n  \"data/GG\": {\n    fmt: \"%N%n%O%n%A%n%C%nGUERNSEY%n%Z\",\n    id: \"data/GG\",\n    key: \"GG\",\n    name: \"CHANNEL ISLANDS\",\n    posturl: \"http://www.guernseypost.com/postcode_finder/\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"GY\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}\",\n    zipex: \"GY1 1AA,GY2 2BT\",\n  },\n  \"data/GH\": { id: \"data/GH\", key: \"GH\", name: \"GHANA\" },\n  \"data/GI\": {\n    fmt: \"%N%n%O%n%A%nGIBRALTAR%n%Z\",\n    id: \"data/GI\",\n    key: \"GI\",\n    name: \"GIBRALTAR\",\n    require: \"A\",\n    zip: \"GX11 1AA\",\n    zipex: \"GX11 1AA\",\n  },\n  \"data/GL\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GL\",\n    key: \"GL\",\n    name: \"GREENLAND\",\n    require: \"ACZ\",\n    zip: \"39\\\\d{2}\",\n    zipex: \"3900,3950,3911\",\n  },\n  \"data/GM\": { id: \"data/GM\", key: \"GM\", name: \"GAMBIA\" },\n  \"data/GN\": {\n    fmt: \"%N%n%O%n%Z %A %C\",\n    id: \"data/GN\",\n    key: \"GN\",\n    name: \"GUINEA\",\n    zip: \"\\\\d{3}\",\n    zipex: \"001,200,100\",\n  },\n  \"data/GP\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/GP\",\n    key: \"GP\",\n    name: \"GUADELOUPE\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78][01]\\\\d{2}\",\n    zipex: \"97100\",\n  },\n  \"data/GQ\": { id: \"data/GQ\", key: \"GQ\", name: \"EQUATORIAL GUINEA\" },\n  \"data/GR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GR\",\n    key: \"GR\",\n    name: \"GREECE\",\n    posturl: \"http://www.elta.gr/findapostcode.aspx\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"151 24,151 10,101 88\",\n  },\n  \"data/GS\": {\n    fmt: \"%N%n%O%n%A%n%n%C%n%Z\",\n    id: \"data/GS\",\n    key: \"GS\",\n    name: \"SOUTH GEORGIA\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"SIQQ 1ZZ\",\n    zipex: \"SIQQ 1ZZ\",\n  },\n  \"data/GT\": {\n    fmt: \"%N%n%O%n%A%n%Z- %C\",\n    id: \"data/GT\",\n    key: \"GT\",\n    name: \"GUATEMALA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"09001,01501\",\n  },\n  \"data/GU\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/GU\",\n    key: \"GU\",\n    name: \"GUAM\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACZ\",\n    upper: \"ACNO\",\n    zip: \"(969(?:[12]\\\\d|3[12]))(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96910,96931\",\n  },\n  \"data/GW\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/GW\",\n    key: \"GW\",\n    name: \"GUINEA-BISSAU\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000,1011\",\n  },\n  \"data/GY\": { id: \"data/GY\", key: \"GY\", name: \"GUYANA\" },\n  \"data/HK\": {\n    fmt: \"%S%n%C%n%A%n%O%n%N\",\n    id: \"data/HK\",\n    key: \"HK\",\n    lang: \"zh-Hant\",\n    languages: \"zh-Hant~en\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S\",\n    locality_name_type: \"district\",\n    name: \"HONG KONG\",\n    require: \"AS\",\n    state_name_type: \"area\",\n    sub_keys: \"Kowloon~Hong Kong Island~New Territories\",\n    sub_mores: \"true~true~true\",\n    sub_names: \"九龍~香港島~新界\",\n    upper: \"S\",\n  },\n  \"data/HK--en\": {\n    fmt: \"%S%n%C%n%A%n%O%n%N\",\n    id: \"data/HK--en\",\n    key: \"HK\",\n    lang: \"en\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S\",\n    locality_name_type: \"district\",\n    name: \"HONG KONG\",\n    require: \"AS\",\n    state_name_type: \"area\",\n    sub_keys: \"Hong Kong Island~Kowloon~New Territories\",\n    sub_lnames: \"Hong Kong Island~Kowloon~New Territories\",\n    sub_mores: \"true~true~true\",\n    upper: \"S\",\n  },\n  \"data/HM\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/HM\",\n    key: \"HM\",\n    name: \"HEARD AND MCDONALD ISLANDS\",\n    upper: \"CS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"7050\",\n  },\n  \"data/HN\": {\n    fmt: \"%N%n%O%n%A%n%C, %S%n%Z\",\n    id: \"data/HN\",\n    key: \"HN\",\n    name: \"HONDURAS\",\n    require: \"ACS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"31301\",\n  },\n  \"data/HR\": {\n    fmt: \"%N%n%O%n%A%nHR-%Z %C\",\n    id: \"data/HR\",\n    key: \"HR\",\n    name: \"CROATIA\",\n    postprefix: \"HR-\",\n    posturl: \"http://www.posta.hr/default.aspx?pretpum\",\n    zip: \"\\\\d{5}\",\n    zipex: \"10000,21001,10002\",\n  },\n  \"data/HT\": {\n    fmt: \"%N%n%O%n%A%nHT%Z %C\",\n    id: \"data/HT\",\n    key: \"HT\",\n    name: \"HAITI\",\n    postprefix: \"HT\",\n    zip: \"\\\\d{4}\",\n    zipex: \"6120,5310,6110,8510\",\n  },\n  \"data/HU\": {\n    fmt: \"%N%n%O%n%C%n%A%n%Z\",\n    id: \"data/HU\",\n    key: \"HU\",\n    name: \"HUNGARY (Rep.)\",\n    posturl: \"http://posta.hu/ugyfelszolgalat/iranyitoszam_kereso\",\n    require: \"ACZ\",\n    upper: \"ACNO\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1037,2380,1540\",\n  },\n  \"data/ID\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    id: \"data/ID\",\n    key: \"ID\",\n    lang: \"id\",\n    languages: \"id\",\n    name: \"INDONESIA\",\n    require: \"AS\",\n    sub_isoids:\n      \"AC~BA~BT~BE~YO~JK~GO~JA~JB~JT~JI~KB~KS~KT~KI~KU~BB~KR~LA~MA~MU~NB~NT~PA~PB~RI~SR~SN~ST~SG~SA~SB~SS~SU\",\n    sub_keys:\n      \"Aceh~Bali~Banten~Bengkulu~Daerah Istimewa Yogyakarta~DKI Jakarta~Gorontalo~Jambi~Jawa Barat~Jawa Tengah~Jawa Timur~Kalimantan Barat~Kalimantan Selatan~Kalimantan Tengah~Kalimantan Timur~Kalimantan Utara~Kepulauan Bangka Belitung~Kepulauan Riau~Lampung~Maluku~Maluku Utara~Nusa Tenggara Barat~Nusa Tenggara Timur~Papua~Papua Barat~Riau~Sulawesi Barat~Sulawesi Selatan~Sulawesi Tengah~Sulawesi Tenggara~Sulawesi Utara~Sumatera Barat~Sumatera Selatan~Sumatera Utara\",\n    zip: \"\\\\d{5}\",\n    zipex: \"40115\",\n  },\n  \"data/IE\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C%n%S %Z\",\n    id: \"data/IE\",\n    key: \"IE\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"IRELAND\",\n    posturl: \"https://finder.eircode.ie\",\n    state_name_type: \"county\",\n    sub_isoids:\n      \"CW~CN~CE~C~DL~D~G~KY~KE~KK~LS~LM~LK~LD~LH~MO~MH~MN~OY~RN~SO~TA~WD~WH~WX~WW\",\n    sub_keys:\n      \"Co. Carlow~Co. Cavan~Co. Clare~Co. Cork~Co. Donegal~Co. Dublin~Co. Galway~Co. Kerry~Co. Kildare~Co. Kilkenny~Co. Laois~Co. Leitrim~Co. Limerick~Co. Longford~Co. Louth~Co. Mayo~Co. Meath~Co. Monaghan~Co. Offaly~Co. Roscommon~Co. Sligo~Co. Tipperary~Co. Waterford~Co. Westmeath~Co. Wexford~Co. Wicklow\",\n    sublocality_name_type: \"townland\",\n    zip: \"[\\\\dA-Z]{3} ?[\\\\dA-Z]{4}\",\n    zip_name_type: \"eircode\",\n    zipex: \"A65 F4E2\",\n  },\n  \"data/IL\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/IL\",\n    key: \"IL\",\n    name: \"ISRAEL\",\n    posturl: \"http://www.israelpost.co.il/zipcode.nsf/demozip?openform\",\n    zip: \"\\\\d{5}(?:\\\\d{2})?\",\n    zipex: \"9614303\",\n  },\n  \"data/IM\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/IM\",\n    key: \"IM\",\n    name: \"ISLE OF MAN\",\n    posturl: \"https://www.iompost.com/tools-forms/postcode-finder/\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"IM\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}\",\n    zipex: \"IM2 1AA,IM99 1PS\",\n  },\n  \"data/IN\": {\n    fmt: \"%N%n%O%n%A%n%C %Z%n%S\",\n    id: \"data/IN\",\n    key: \"IN\",\n    lang: \"en\",\n    languages: \"en~hi\",\n    name: \"INDIA\",\n    posturl: \"https://www.indiapost.gov.in/vas/pages/FindPinCode.aspx\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AN~AP~AR~AS~BR~CH~CT~DN~DD~DL~GA~GJ~HR~HP~JK~JH~KA~KL~LD~MP~MH~MN~ML~MZ~NL~OR~PY~PB~RJ~SK~TN~TG~TR~UP~UT~WB\",\n    sub_keys:\n      \"Andaman and Nicobar Islands~Andhra Pradesh~Arunachal Pradesh~Assam~Bihar~Chandigarh~Chhattisgarh~Dadra and Nagar Haveli~Daman and Diu~Delhi~Goa~Gujarat~Haryana~Himachal Pradesh~Jammu and Kashmir~Jharkhand~Karnataka~Kerala~Lakshadweep~Madhya Pradesh~Maharashtra~Manipur~Meghalaya~Mizoram~Nagaland~Odisha~Puducherry~Punjab~Rajasthan~Sikkim~Tamil Nadu~Telangana~Tripura~Uttar Pradesh~Uttarakhand~West Bengal\",\n    sub_names:\n      \"Andaman & Nicobar~Andhra Pradesh~Arunachal Pradesh~Assam~Bihar~Chandigarh~Chhattisgarh~Dadra & Nagar Haveli~Daman & Diu~Delhi~Goa~Gujarat~Haryana~Himachal Pradesh~Jammu & Kashmir~Jharkhand~Karnataka~Kerala~Lakshadweep~Madhya Pradesh~Maharashtra~Manipur~Meghalaya~Mizoram~Nagaland~Odisha~Puducherry~Punjab~Rajasthan~Sikkim~Tamil Nadu~Telangana~Tripura~Uttar Pradesh~Uttarakhand~West Bengal\",\n    sub_zips:\n      \"744~5[0-3]~79[0-2]~78~8[0-5]~16|1440[3-9]~49~396~396~11~403~3[6-9]~1[23]~17~1[89]~81[4-9]|82|83[0-5]~5[4-9]|53[7-9]~6[7-9]|6010|607008|777~682~4[5-8]|490~4[0-4]~79[56]~79[34]~796~79[78]~7[5-7]~60[579]~1[456]~3[0-4]~737|750~6[0-6]|536~5[0-3]~799~2[0-35-8]|24[0-7]|26[12]~24[46-9]|254|26[23]~7[0-4]\",\n    zip: \"\\\\d{6}\",\n    zip_name_type: \"pin\",\n    zipex: \"110034,110001\",\n  },\n  \"data/IN--hi\": {\n    fmt: \"%N%n%O%n%A%n%C %Z%n%S\",\n    id: \"data/IN--hi\",\n    key: \"IN\",\n    lang: \"hi\",\n    name: \"INDIA\",\n    posturl: \"https://www.indiapost.gov.in/vas/pages/FindPinCode.aspx\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AN~AR~AS~AP~UP~UT~OR~KA~KL~GJ~GA~CH~CT~JK~JH~TN~TG~TR~DD~DN~DL~NL~PB~WB~PY~BR~MN~MP~MH~MZ~ML~RJ~LD~SK~HR~HP\",\n    sub_keys:\n      \"Andaman & Nicobar~Arunachal Pradesh~Assam~Andhra Pradesh~Uttar Pradesh~Uttarakhand~Odisha~Karnataka~Kerala~Gujarat~Goa~Chandigarh~Chhattisgarh~Jammu & Kashmir~Jharkhand~Tamil Nadu~Telangana~Tripura~Daman & Diu~Dadra & Nagar Haveli~Delhi~Nagaland~Punjab~West Bengal~Puducherry~Bihar~Manipur~Madhya Pradesh~Maharashtra~Mizoram~Meghalaya~Rajasthan~Lakshadweep~Sikkim~Haryana~Himachal Pradesh\",\n    sub_names:\n      \"अंडमान और निकोबार द्वीपसमूह~अरुणाचल प्रदेश~असम~आंध्र प्रदेश~उत्तर प्रदेश~उत्तराखण्ड~ओड़िशा~कर्नाटक~केरल~गुजरात~गोआ~चंडीगढ़~छत्तीसगढ़~जम्मू और कश्मीर~झारखण्ड~तमिल नाडु~तेलंगाना~त्रिपुरा~दमन और दीव~दादरा और नगर हवेली~दिल्ली~नागालैंड~पंजाब~पश्चिम बंगाल~पांडिचेरी~बिहार~मणिपुर~मध्य प्रदेश~महाराष्ट्र~मिजोरम~मेघालय~राजस्थान~लक्षद्वीप~सिक्किम~हरियाणा~हिमाचल प्रदेश\",\n    sub_zips:\n      \"744~79[0-2]~78~5[0-3]~2[0-35-8]|24[0-7]|26[12]~24[46-9]|254|26[23]~7[5-7]~5[4-9]|53[7-9]~6[7-9]|6010|607008|777~3[6-9]~403~16|1440[3-9]~49~1[89]~81[4-9]|82|83[0-5]~6[0-6]|536~5[0-3]~799~396~396~11~79[78]~1[456]~7[0-4]~60[579]~8[0-5]~79[56]~4[5-8]|490~4[0-4]~796~79[34]~3[0-4]~682~737|750~1[23]~17\",\n    zip: \"\\\\d{6}\",\n    zip_name_type: \"pin\",\n    zipex: \"110034,110001\",\n  },\n  \"data/IO\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/IO\",\n    key: \"IO\",\n    name: \"BRITISH INDIAN OCEAN TERRITORY\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"BBND 1ZZ\",\n    zipex: \"BBND 1ZZ\",\n  },\n  \"data/IQ\": {\n    fmt: \"%O%n%N%n%A%n%C, %S%n%Z\",\n    id: \"data/IQ\",\n    key: \"IQ\",\n    name: \"IRAQ\",\n    require: \"ACS\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"31001\",\n  },\n  \"data/IR\": {\n    fmt: \"%O%n%N%n%S%n%C, %D%n%A%n%Z\",\n    id: \"data/IR\",\n    key: \"IR\",\n    lang: \"fa\",\n    languages: \"fa\",\n    name: \"IRAN\",\n    sub_isoids:\n      \"01~02~03~04~32~05~06~07~08~29~30~31~10~11~12~13~14~28~26~16~15~17~18~27~19~20~21~22~23~24~25\",\n    sub_keys:\n      \"استان آذربایجان شرقی~استان آذربایجان غربی~استان اردبیل~استان اصفهان~استان البرز~استان ایلام~استان بوشهر~استان تهران~استان چهارمحال و بختیاری~استان خراسان جنوبی~استان خراسان رضوی~استان خراسان شمالی~استان خوزستان~استان زنجان~استان سمنان~استان سیستان و بلوچستان~استان فارس~استان قزوین~استان قم~استان کردستان~استان کرمان~استان کرمانشاه~استان کهگیلویه و بویراحمد~استان گلستان~استان گیلان~استان لرستان~استان مازندران~استان مرکزی~استان هرمزگان~استان همدان~استان یزد\",\n    sub_lnames:\n      \"East Azerbaijan Province~West Azerbaijan Province~Ardabil Province~Isfahan Province~Alborz Province~Ilam Province~Bushehr Province~Tehran Province~Chaharmahal and Bakhtiari Province~South Khorasan Province~Razavi Khorasan Province~North Khorasan Province~Khuzestan Province~Zanjan Province~Semnan Province~Sistan and Baluchestan Province~Fars Province~Qazvin Province~Qom Province~Kurdistan Province~Kerman Province~Kermanshah Province~Kohgiluyeh and Boyer-Ahmad Province~Golestan Province~Gilan Province~Lorestan Province~Mazandaran Province~Markazi Province~Hormozgan Province~Hamadan Province~Yazd Province\",\n    sublocality_name_type: \"neighborhood\",\n    zip: \"\\\\d{5}-?\\\\d{5}\",\n    zipex: \"11936-12345\",\n  },\n  \"data/IS\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/IS\",\n    key: \"IS\",\n    name: \"ICELAND\",\n    posturl: \"http://www.postur.is/einstaklingar/posthus/postnumer/\",\n    zip: \"\\\\d{3}\",\n    zipex: \"320,121,220,110\",\n  },\n  \"data/IT\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/IT\",\n    key: \"IT\",\n    lang: \"it\",\n    languages: \"it\",\n    name: \"ITALY\",\n    posturl: \"http://www.poste.it/online/cercacap/\",\n    require: \"ACSZ\",\n    sub_isoids:\n      \"AG~AL~AN~AO~AR~AP~AT~AV~BA~BT~BL~BN~BG~BI~BO~BZ~BS~BR~CA~CL~CB~CI~CE~CT~CZ~CH~CO~CS~CR~KR~CN~EN~FM~FE~FI~FG~FC~FR~GE~GO~GR~IM~IS~AQ~SP~LT~LE~LC~LI~LO~LU~MC~MN~MS~MT~VS~ME~MI~MO~MB~NA~NO~NU~OG~OT~OR~PD~PA~PR~PV~PG~PU~PE~PC~PI~PT~PN~PZ~PO~RG~RA~RC~RE~RI~RN~RM~RO~SA~SS~SV~SI~SR~SO~TA~TE~TR~TO~TP~TN~TV~TS~UD~VA~VE~VB~VC~VR~VV~VI~VT\",\n    sub_keys:\n      \"AG~AL~AN~AO~AR~AP~AT~AV~BA~BT~BL~BN~BG~BI~BO~BZ~BS~BR~CA~CL~CB~CI~CE~CT~CZ~CH~CO~CS~CR~KR~CN~EN~FM~FE~FI~FG~FC~FR~GE~GO~GR~IM~IS~AQ~SP~LT~LE~LC~LI~LO~LU~MC~MN~MS~MT~VS~ME~MI~MO~MB~NA~NO~NU~OG~OT~OR~PD~PA~PR~PV~PG~PU~PE~PC~PI~PT~PN~PZ~PO~RG~RA~RC~RE~RI~RN~RM~RO~SA~SS~SV~SI~SR~SO~TA~TE~TR~TO~TP~TN~TV~TS~UD~VA~VE~VB~VC~VR~VV~VI~VT\",\n    sub_names:\n      \"Agrigento~Alessandria~Ancona~Aosta~Arezzo~Ascoli Piceno~Asti~Avellino~Bari~Barletta-Andria-Trani~Belluno~Benevento~Bergamo~Biella~Bologna~Bolzano~Brescia~Brindisi~Cagliari~Caltanissetta~Campobasso~Carbonia-Iglesias~Caserta~Catania~Catanzaro~Chieti~Como~Cosenza~Cremona~Crotone~Cuneo~Enna~Fermo~Ferrara~Firenze~Foggia~Forlì-Cesena~Frosinone~Genova~Gorizia~Grosseto~Imperia~Isernia~L'Aquila~La Spezia~Latina~Lecce~Lecco~Livorno~Lodi~Lucca~Macerata~Mantova~Massa-Carrara~Matera~Medio Campidano~Messina~Milano~Modena~Monza e Brianza~Napoli~Novara~Nuoro~Ogliastra~Olbia-Tempio~Oristano~Padova~Palermo~Parma~Pavia~Perugia~Pesaro e Urbino~Pescara~Piacenza~Pisa~Pistoia~Pordenone~Potenza~Prato~Ragusa~Ravenna~Reggio Calabria~Reggio Emilia~Rieti~Rimini~Roma~Rovigo~Salerno~Sassari~Savona~Siena~Siracusa~Sondrio~Taranto~Teramo~Terni~Torino~Trapani~Trento~Treviso~Trieste~Udine~Varese~Venezia~Verbano-Cusio-Ossola~Vercelli~Verona~Vibo Valentia~Vicenza~Viterbo\",\n    sub_zips:\n      \"92~15~60~11~52~63~14~83~70~76[01]~32~82~24~13[89]~40~39~25~72~0912[1-9]|0913[0-4]|0901[0289]|0902[03468]|0903[0234]|0904|0803[035]|08043~93~860[1-4]|86100~0901[013-7]~81~95~88[01]~66~22~87~26[01]~88[89]~12|18025~94~638|63900~44~50~71~47[015]~03~16~34[01]7~58~18~860[7-9]|86170~67~19~04~73~23[89]~57~26[89]~55~62~46~54~75~0902[012579]|0903[015-9]|09040~98~20~41~208|20900~80~28[01]~080[1-3]|08100~08037|0804[024-9]~08020|0702|0703[08]~090[7-9]|09170|0801[039]|0803[04]~35~90~43~27~06~61~65~29~56~51~330[7-9]|33170~85~59~97~48~89[01]~42~02~47[89]~00~45~84~070[14]|0703[0-79]|07100~17|12071~53~96~23[01]~74~64~05~10~91~38~31~3401|341[0-689]|34062~330[1-5]|33100~21~30~28[89]~13[01]~37~89[89]~36~01\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"00144,47037,39049\",\n  },\n  \"data/JE\": {\n    fmt: \"%N%n%O%n%A%n%C%nJERSEY%n%Z\",\n    id: \"data/JE\",\n    key: \"JE\",\n    name: \"CHANNEL ISLANDS\",\n    posturl: \"http://www.jerseypost.com/tools/postcode-address-finder/\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"JE\\\\d[\\\\dA-Z]? ?\\\\d[ABD-HJLN-UW-Z]{2}\",\n    zipex: \"JE1 1AA,JE2 2BT\",\n  },\n  \"data/JM\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %X\",\n    id: \"data/JM\",\n    key: \"JM\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"JAMAICA\",\n    require: \"ACS\",\n    state_name_type: \"parish\",\n    sub_isoids: \"13~09~01~12~04~02~06~14~11~08~05~03~07~10\",\n    sub_keys:\n      \"Clarendon~Hanover~Kingston~Manchester~Portland~St. Andrew~St. Ann~St. Catherine~St. Elizabeth~St. James~St. Mary~St. Thomas~Trelawny~Westmoreland\",\n  },\n  \"data/JO\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/JO\",\n    key: \"JO\",\n    name: \"JORDAN\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11937,11190\",\n  },\n  \"data/JP\": {\n    fmt: \"〒%Z%n%S%n%A%n%O%n%N\",\n    id: \"data/JP\",\n    key: \"JP\",\n    lang: \"ja\",\n    languages: \"ja\",\n    lfmt: \"%N%n%O%n%A, %S%n%Z\",\n    name: \"JAPAN\",\n    posturl: \"http://www.post.japanpost.jp/zipcode/\",\n    require: \"ASZ\",\n    state_name_type: \"prefecture\",\n    sub_isoids:\n      \"01~02~03~04~05~06~07~08~09~10~11~12~13~14~15~16~17~18~19~20~21~22~23~24~25~26~27~28~29~30~31~32~33~34~35~36~37~38~39~40~41~42~43~44~45~46~47\",\n    sub_keys:\n      \"北海道~青森県~岩手県~宮城県~秋田県~山形県~福島県~茨城県~栃木県~群馬県~埼玉県~千葉県~東京都~神奈川県~新潟県~富山県~石川県~福井県~山梨県~長野県~岐阜県~静岡県~愛知県~三重県~滋賀県~京都府~大阪府~兵庫県~奈良県~和歌山県~鳥取県~島根県~岡山県~広島県~山口県~徳島県~香川県~愛媛県~高知県~福岡県~佐賀県~長崎県~熊本県~大分県~宮崎県~鹿児島県~沖縄県\",\n    sub_lnames:\n      \"Hokkaido~Aomori~Iwate~Miyagi~Akita~Yamagata~Fukushima~Ibaraki~Tochigi~Gunma~Saitama~Chiba~Tokyo~Kanagawa~Niigata~Toyama~Ishikawa~Fukui~Yamanashi~Nagano~Gifu~Shizuoka~Aichi~Mie~Shiga~Kyoto~Osaka~Hyogo~Nara~Wakayama~Tottori~Shimane~Okayama~Hiroshima~Yamaguchi~Tokushima~Kagawa~Ehime~Kochi~Fukuoka~Saga~Nagasaki~Kumamoto~Oita~Miyazaki~Kagoshima~Okinawa\",\n    sub_zips:\n      \"0[4-9]|00[1-7]~03|018~02~98~01~99~9[67]~3[01]~32|311|349~37|38[49]~3[3-6]~2[6-9]~1[0-8]|19[0-8]|20~2[1-5]|199~9[45]|389~93~92|939~91|922~40~3[89]|949~50~4[1-9]~4[4-9]|431~51|498|647~52~6[0-2]|520~5[3-9]|618|630~6[5-7]|563~63|64[78]~64|519~68~69|68[45]~7[01]~7[23]~7[45]~77~76~79~78~8[0-3]|871~84~85|81[17]|848~86~87|839~88~89~90\",\n    upper: \"S\",\n    zip: \"\\\\d{3}-?\\\\d{4}\",\n    zipex: \"154-0023,350-1106,951-8073,112-0001,208-0032,231-0012\",\n  },\n  \"data/KE\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/KE\",\n    key: \"KE\",\n    name: \"KENYA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"20100,00100\",\n  },\n  \"data/KG\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/KG\",\n    key: \"KG\",\n    name: \"KYRGYZSTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"720001\",\n  },\n  \"data/KH\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/KH\",\n    key: \"KH\",\n    name: \"CAMBODIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"12203,14206,12000\",\n  },\n  \"data/KI\": {\n    fmt: \"%N%n%O%n%A%n%S%n%C\",\n    id: \"data/KI\",\n    key: \"KI\",\n    name: \"KIRIBATI\",\n    state_name_type: \"island\",\n    upper: \"ACNOS\",\n  },\n  \"data/KM\": { id: \"data/KM\", key: \"KM\", name: \"COMOROS\", upper: \"AC\" },\n  \"data/KN\": {\n    fmt: \"%N%n%O%n%A%n%C, %S\",\n    id: \"data/KN\",\n    key: \"KN\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"SAINT KITTS AND NEVIS\",\n    require: \"ACS\",\n    state_name_type: \"island\",\n    sub_isoids: \"N~K\",\n    sub_keys: \"Nevis~St. Kitts\",\n  },\n  \"data/KP\": {\n    fmt: \"%Z%n%S%n%C%n%A%n%O%n%N\",\n    id: \"data/KP\",\n    key: \"KP\",\n    lang: \"ko\",\n    languages: \"ko\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S, %Z\",\n    name: \"NORTH KOREA\",\n    sub_isoids: \"07~13~10~04~02~03~01~08~09~05~06\",\n    sub_keys:\n      \"강원도~라선 특별시~량강도~자강도~평안 남도~평안 북도~평양 직할시~함경 남도~함경 북도~황해남도~황해북도\",\n    sub_lnames:\n      \"Kangwon~Rason~Ryanggang~Chagang~South Pyongan~North Pyongan~Pyongyang~South Hamgyong~North Hamgyong~South Hwanghae~North Hwanghae\",\n  },\n  \"data/KR\": {\n    fmt: \"%S %C%D%n%A%n%O%n%N%n%Z\",\n    id: \"data/KR\",\n    key: \"KR\",\n    lang: \"ko\",\n    languages: \"ko\",\n    lfmt: \"%N%n%O%n%A%n%D%n%C%n%S%n%Z\",\n    name: \"SOUTH KOREA\",\n    posturl: \"http://www.epost.go.kr/search/zipcode/search5.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"do_si\",\n    sub_isoids: \"42~41~48~47~29~27~30~26~11~50~31~28~46~45~49~44~43\",\n    sub_keys:\n      \"강원도~경기도~경상남도~경상북도~광주광역시~대구광역시~대전광역시~부산광역시~서울특별시~세종특별자치시~울산광역시~인천광역시~전라남도~전라북도~제주특별자치도~충청남도~충청북도\",\n    sub_lnames:\n      \"Gangwon-do~Gyeonggi-do~Gyeongsangnam-do~Gyeongsangbuk-do~Gwangju~Daegu~Daejeon~Busan~Seoul~Sejong~Ulsan~Incheon~Jeollanam-do~Jeollabuk-do~Jeju-do~Chungcheongnam-do~Chungcheongbuk-do\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_names:\n      \"강원~경기~경남~경북~광주~대구~대전~부산~서울~세종~울산~인천~전남~전북~제주~충남~충북\",\n    sub_zipexs:\n      \"25627~12410~53286~38540~62394~42456~34316~46706~06321~30065~44782~23024~59222~56445~63563~32832~28006\",\n    sub_zips:\n      \"2[456]\\\\d{2}~1[0-8]\\\\d{2}~5[0-3]\\\\d{2}~(?:3[6-9]|40)\\\\d{2}~6[12]\\\\d{2}~4[12]\\\\d{2}~3[45]\\\\d{2}~4[6-9]\\\\d{2}~0[1-8]\\\\d{2}~30[01]\\\\d~4[45]\\\\d{2}~2[1-3]\\\\d{2}~5[7-9]\\\\d{2}~5[4-6]\\\\d{2}~63[0-356]\\\\d~3[1-3]\\\\d{2}~2[789]\\\\d{2}\",\n    sublocality_name_type: \"district\",\n    upper: \"Z\",\n    zip: \"\\\\d{5}\",\n    zipex: \"03051\",\n  },\n  \"data/KW\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/KW\",\n    key: \"KW\",\n    name: \"KUWAIT\",\n    zip: \"\\\\d{5}\",\n    zipex: \"54541,54551,54404,13009\",\n  },\n  \"data/KY\": {\n    fmt: \"%N%n%O%n%A%n%S %Z\",\n    id: \"data/KY\",\n    key: \"KY\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"CAYMAN ISLANDS\",\n    posturl: \"http://www.caymanpost.gov.ky/\",\n    require: \"AS\",\n    state_name_type: \"island\",\n    sub_keys: \"Cayman Brac~Grand Cayman~Little Cayman\",\n    zip: \"KY\\\\d-\\\\d{4}\",\n    zipex: \"KY1-1100,KY1-1702,KY2-2101\",\n  },\n  \"data/KZ\": {\n    fmt: \"%Z%n%S%n%C%n%A%n%O%n%N\",\n    id: \"data/KZ\",\n    key: \"KZ\",\n    name: \"KAZAKHSTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"040900,050012\",\n  },\n  \"data/LA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/LA\",\n    key: \"LA\",\n    name: \"LAO (PEOPLE'S DEM. REP.)\",\n    zip: \"\\\\d{5}\",\n    zipex: \"01160,01000\",\n  },\n  \"data/LB\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/LB\",\n    key: \"LB\",\n    name: \"LEBANON\",\n    zip: \"(?:\\\\d{4})(?: ?(?:\\\\d{4}))?\",\n    zipex: \"2038 3054,1107 2810,1000\",\n  },\n  \"data/LC\": { id: \"data/LC\", key: \"LC\", name: \"SAINT LUCIA\" },\n  \"data/LI\": {\n    fmt: \"%O%n%N%n%A%nFL-%Z %C\",\n    id: \"data/LI\",\n    key: \"LI\",\n    name: \"LIECHTENSTEIN\",\n    postprefix: \"FL-\",\n    posturl: \"http://www.post.ch/db/owa/pv_plz_pack/pr_main\",\n    require: \"ACZ\",\n    zip: \"948[5-9]|949[0-8]\",\n    zipex: \"9496,9491,9490,9485\",\n  },\n  \"data/LK\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/LK\",\n    key: \"LK\",\n    name: \"SRI LANKA\",\n    posturl: \"http://www.slpost.gov.lk/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"20000,00100\",\n  },\n  \"data/LR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/LR\",\n    key: \"LR\",\n    name: \"LIBERIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1000\",\n  },\n  \"data/LS\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/LS\",\n    key: \"LS\",\n    name: \"LESOTHO\",\n    zip: \"\\\\d{3}\",\n    zipex: \"100\",\n  },\n  \"data/LT\": {\n    fmt: \"%O%n%N%n%A%nLT-%Z %C\",\n    id: \"data/LT\",\n    key: \"LT\",\n    name: \"LITHUANIA\",\n    postprefix: \"LT-\",\n    posturl: \"http://www.post.lt/lt/?id=316\",\n    zip: \"\\\\d{5}\",\n    zipex: \"04340,03500\",\n  },\n  \"data/LU\": {\n    fmt: \"%O%n%N%n%A%nL-%Z %C\",\n    id: \"data/LU\",\n    key: \"LU\",\n    name: \"LUXEMBOURG\",\n    postprefix: \"L-\",\n    posturl:\n      \"https://www.post.lu/fr/grandes-entreprises/solutions-postales/rechercher-un-code-postal\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"4750,2998\",\n  },\n  \"data/LV\": {\n    fmt: \"%N%n%O%n%A%n%C, %Z\",\n    id: \"data/LV\",\n    key: \"LV\",\n    name: \"LATVIA\",\n    posturl: \"http://www.pasts.lv/lv/uzzinas/nodalas/\",\n    zip: \"LV-\\\\d{4}\",\n    zipex: \"LV-1073,LV-1000\",\n  },\n  \"data/LY\": { id: \"data/LY\", key: \"LY\", name: \"LIBYA\" },\n  \"data/MA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/MA\",\n    key: \"MA\",\n    name: \"MOROCCO\",\n    zip: \"\\\\d{5}\",\n    zipex: \"53000,10000,20050,16052\",\n  },\n  \"data/MC\": {\n    fmt: \"%N%n%O%n%A%nMC-%Z %C %X\",\n    id: \"data/MC\",\n    key: \"MC\",\n    name: \"MONACO\",\n    postprefix: \"MC-\",\n    zip: \"980\\\\d{2}\",\n    zipex: \"98000,98020,98011,98001\",\n  },\n  \"data/MD\": {\n    fmt: \"%N%n%O%n%A%nMD-%Z %C\",\n    id: \"data/MD\",\n    key: \"MD\",\n    name: \"Rep. MOLDOVA\",\n    postprefix: \"MD-\",\n    zip: \"\\\\d{4}\",\n    zipex: \"2012,2019\",\n  },\n  \"data/ME\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/ME\",\n    key: \"ME\",\n    name: \"MONTENEGRO\",\n    zip: \"8\\\\d{4}\",\n    zipex: \"81257,81258,81217,84314,85366\",\n  },\n  \"data/MF\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/MF\",\n    key: \"MF\",\n    name: \"SAINT MARTIN\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78][01]\\\\d{2}\",\n    zipex: \"97100\",\n  },\n  \"data/MG\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/MG\",\n    key: \"MG\",\n    name: \"MADAGASCAR\",\n    zip: \"\\\\d{3}\",\n    zipex: \"501,101\",\n  },\n  \"data/MH\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/MH\",\n    key: \"MH\",\n    name: \"MARSHALL ISLANDS\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(969[67]\\\\d)(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96960,96970\",\n  },\n  \"data/MK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/MK\",\n    key: \"MK\",\n    name: \"MACEDONIA\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1314,1321,1443,1062\",\n  },\n  \"data/ML\": { id: \"data/ML\", key: \"ML\", name: \"MALI\" },\n  \"data/MM\": {\n    fmt: \"%N%n%O%n%A%n%C, %Z\",\n    id: \"data/MM\",\n    key: \"MM\",\n    name: \"MYANMAR\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11181\",\n  },\n  \"data/MN\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    id: \"data/MN\",\n    key: \"MN\",\n    name: \"MONGOLIA\",\n    posturl: \"http://www.zipcode.mn/\",\n    zip: \"\\\\d{5}\",\n    zipex: \"65030,65270\",\n  },\n  \"data/MO\": {\n    fmt: \"%A%n%O%n%N\",\n    id: \"data/MO\",\n    key: \"MO\",\n    lfmt: \"%N%n%O%n%A\",\n    name: \"MACAO\",\n    require: \"A\",\n  },\n  \"data/MP\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/MP\",\n    key: \"MP\",\n    name: \"NORTHERN MARIANA ISLANDS\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(9695[012])(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96950,96951,96952\",\n  },\n  \"data/MQ\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/MQ\",\n    key: \"MQ\",\n    name: \"MARTINIQUE\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]2\\\\d{2}\",\n    zipex: \"97220\",\n  },\n  \"data/MR\": { id: \"data/MR\", key: \"MR\", name: \"MAURITANIA\", upper: \"AC\" },\n  \"data/MS\": { id: \"data/MS\", key: \"MS\", name: \"MONTSERRAT\" },\n  \"data/MT\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/MT\",\n    key: \"MT\",\n    name: \"MALTA\",\n    posturl: \"http://postcodes.maltapost.com/\",\n    upper: \"CZ\",\n    zip: \"[A-Z]{3} ?\\\\d{2,4}\",\n    zipex: \"NXR 01,ZTN 05,GPO 01,BZN 1130,SPB 6031,VCT 1753\",\n  },\n  \"data/MU\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/MU\",\n    key: \"MU\",\n    name: \"MAURITIUS\",\n    upper: \"CZ\",\n    zip: \"\\\\d{3}(?:\\\\d{2}|[A-Z]{2}\\\\d{3})\",\n    zipex: \"42602\",\n  },\n  \"data/MV\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/MV\",\n    key: \"MV\",\n    name: \"MALDIVES\",\n    posturl: \"http://www.maldivespost.com/?lid=10\",\n    zip: \"\\\\d{5}\",\n    zipex: \"20026\",\n  },\n  \"data/MW\": {\n    fmt: \"%N%n%O%n%A%n%C %X\",\n    id: \"data/MW\",\n    key: \"MW\",\n    name: \"MALAWI\",\n  },\n  \"data/MX\": {\n    fmt: \"%N%n%O%n%A%n%D%n%Z %C, %S\",\n    id: \"data/MX\",\n    key: \"MX\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"MEXICO\",\n    posturl:\n      \"http://www.correosdemexico.gob.mx/ServiciosLinea/Paginas/ccpostales.aspx\",\n    require: \"ACZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AGU~BCN~BCS~CAM~CHP~CHH~CMX~COA~COL~DUR~MEX~GUA~GRO~HID~JAL~MIC~MOR~NAY~NLE~OAX~PUE~QUE~ROO~SLP~SIN~SON~TAB~TAM~TLA~VER~YUC~ZAC\",\n    sub_keys:\n      \"Ags.~B.C.~B.C.S.~Camp.~Chis.~Chih.~CDMX~Coah.~Col.~Dgo.~Méx.~Gto.~Gro.~Hgo.~Jal.~Mich.~Mor.~Nay.~N.L.~Oax.~Pue.~Qro.~Q.R.~S.L.P.~Sin.~Son.~Tab.~Tamps.~Tlax.~Ver.~Yuc.~Zac.\",\n    sub_names:\n      \"Aguascalientes~Baja California~Baja California Sur~Campeche~Chiapas~Chihuahua~Ciudad de México~Coahuila de Zaragoza~Colima~Durango~Estado de México~Guanajuato~Guerrero~Hidalgo~Jalisco~Michoacán~Morelos~Nayarit~Nuevo León~Oaxaca~Puebla~Querétaro~Quintana Roo~San Luis Potosí~Sinaloa~Sonora~Tabasco~Tamaulipas~Tlaxcala~Veracruz~Yucatán~Zacatecas\",\n    sub_zipexs:\n      \"20000,20999~21000,22999~23000,23999~24000,24999~29000,30999~31000,33999~00000,16999~25000,27999~28000,28999~34000,35999~50000,57999~36000,38999~39000,41999~42000,43999~44000,49999~58000,61999~62000,62999~63000,63999~64000,67999~68000,71999~72000,75999~76000,76999~77000,77999~78000,79999~80000,82999~83000,85999~86000,86999~87000,89999~90000,90999~91000,96999~97000,97999~98000,99999\",\n    sub_zips:\n      \"20~2[12]~23~24~29|30~3[1-3]~0|1[0-6]~2[5-7]~28~3[45]~5[0-7]~3[6-8]~39|4[01]~4[23]~4[4-9]~5[89]|6[01]~62~63~6[4-7]~6[89]|7[01]~7[2-5]~76~77~7[89]~8[0-2]~8[3-5]~86~8[7-9]~90~9[1-6]~97~9[89]\",\n    sublocality_name_type: \"neighborhood\",\n    upper: \"CSZ\",\n    zip: \"\\\\d{5}\",\n    zipex: \"02860,77520,06082\",\n  },\n  \"data/MY\": {\n    fmt: \"%N%n%O%n%A%n%D%n%Z %C%n%S\",\n    id: \"data/MY\",\n    key: \"MY\",\n    lang: \"ms\",\n    languages: \"ms\",\n    name: \"MALAYSIA\",\n    posturl: \"http://www.pos.com.my\",\n    require: \"ACZ\",\n    state_name_type: \"state\",\n    sub_isoids: \"01~02~03~14~15~04~05~06~08~09~07~16~12~13~10~11\",\n    sub_keys:\n      \"Johor~Kedah~Kelantan~Kuala Lumpur~Labuan~Melaka~Negeri Sembilan~Pahang~Perak~Perlis~Pulau Pinang~Putrajaya~Sabah~Sarawak~Selangor~Terengganu\",\n    sub_zipexs:\n      \"79000,86999~05000,09999,34950~15000,18599~50000,60000~87000,87999~75000,78399~70000,73599~25000,28999,39000,49000,69000~30000,36899,39000~01000,02799~10000,14999~62000,62999~88000,91999~93000,98999~40000,48999,63000,68199~20000,24999\",\n    sub_zips:\n      \"79|8[0-6]~0[5-9]|34950~1[5-9]~5|60~87~7[5-8]~7[0-4]~2[5-8]|[346]9~3[0-6]|39000~0[12]~1[0-4]~62~8[89]|9[01]~9[3-8]~4[0-8]|6[3-8]~2[0-4]\",\n    sublocality_name_type: \"village_township\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"43000,50754,88990,50670\",\n  },\n  \"data/MZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%S\",\n    id: \"data/MZ\",\n    key: \"MZ\",\n    lang: \"pt\",\n    languages: \"pt\",\n    name: \"MOZAMBIQUE\",\n    sub_isoids: \"P~MPM~G~I~B~L~N~A~S~T~Q\",\n    sub_keys:\n      \"Cabo Delgado~Cidade de Maputo~Gaza~Inhambane~Manica~Maputo~Nampula~Niassa~Sofala~Tete~Zambezia\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1102,1119,3212\",\n  },\n  \"data/NA\": { id: \"data/NA\", key: \"NA\", name: \"NAMIBIA\" },\n  \"data/NC\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/NC\",\n    key: \"NC\",\n    name: \"NEW CALEDONIA\",\n    posturl:\n      \"http://poste.opt.nc/index.php?option=com_content&view=article&id=80&Itemid=131\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"988\\\\d{2}\",\n    zipex: \"98814,98800,98810\",\n  },\n  \"data/NE\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/NE\",\n    key: \"NE\",\n    name: \"NIGER\",\n    zip: \"\\\\d{4}\",\n    zipex: \"8001\",\n  },\n  \"data/NF\": {\n    fmt: \"%O%n%N%n%A%n%C %S %Z\",\n    id: \"data/NF\",\n    key: \"NF\",\n    name: \"NORFOLK ISLAND\",\n    upper: \"CS\",\n    zip: \"2899\",\n    zipex: \"2899\",\n  },\n  \"data/NG\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C %Z%n%S\",\n    id: \"data/NG\",\n    key: \"NG\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"NIGERIA\",\n    posturl: \"http://www.nigeriapostcodes.com/\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AB~AD~AK~AN~BA~BY~BE~BO~CR~DE~EB~ED~EK~EN~FC~GO~IM~JI~KD~KN~KT~KE~KO~KW~LA~NA~NI~OG~ON~OS~OY~PL~RI~SO~TA~YO~ZA\",\n    sub_keys:\n      \"Abia~Adamawa~Akwa Ibom~Anambra~Bauchi~Bayelsa~Benue~Borno~Cross River~Delta~Ebonyi~Edo~Ekiti~Enugu~Federal Capital Territory~Gombe~Imo~Jigawa~Kaduna~Kano~Katsina~Kebbi~Kogi~Kwara~Lagos~Nasarawa~Niger~Ogun State~Ondo~Osun~Oyo~Plateau~Rivers~Sokoto~Taraba~Yobe~Zamfara\",\n    upper: \"CS\",\n    zip: \"\\\\d{6}\",\n    zipex: \"930283,300001,931104\",\n  },\n  \"data/NI\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C, %S\",\n    id: \"data/NI\",\n    key: \"NI\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"NICARAGUA\",\n    posturl: \"http://www.correos.gob.ni/index.php/codigo-postal-2\",\n    state_name_type: \"department\",\n    sub_isoids: \"BO~CA~CI~CO~ES~GR~JI~LE~MD~MN~MS~MT~NS~AN~AS~SJ~RI\",\n    sub_keys:\n      \"Boaco~Carazo~Chinandega~Chontales~Esteli~Granada~Jinotega~Leon~Madriz~Managua~Masaya~Matagalpa~Nueva Segovia~Raan~Raas~Rio San Juan~Rivas\",\n    sub_zips:\n      \"5[12]~4[56]~2[5-7]~5[56]~3[12]~4[34]~6[56]~2[12]~3[45]~1[0-6]~4[12]~6[1-3]~3[7-9]~7[12]~8[1-3]~9[12]~4[78]\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"52000\",\n  },\n  \"data/NL\": {\n    fmt: \"%O%n%N%n%A%n%Z %C\",\n    id: \"data/NL\",\n    key: \"NL\",\n    name: \"NETHERLANDS\",\n    posturl: \"http://www.postnl.nl/voorthuis/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4} ?[A-Z]{2}\",\n    zipex: \"1234 AB,2490 AA\",\n  },\n  \"data/NO\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/NO\",\n    key: \"NO\",\n    locality_name_type: \"post_town\",\n    name: \"NORWAY\",\n    posturl: \"http://adressesok.posten.no/nb/postal_codes/search\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"0025,0107,6631\",\n  },\n  \"data/NP\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/NP\",\n    key: \"NP\",\n    name: \"NEPAL\",\n    posturl: \"http://www.gpo.gov.np/Home/Postalcode\",\n    zip: \"\\\\d{5}\",\n    zipex: \"44601\",\n  },\n  \"data/NR\": {\n    fmt: \"%N%n%O%n%A%n%S\",\n    id: \"data/NR\",\n    key: \"NR\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"NAURU CENTRAL PACIFIC\",\n    require: \"AS\",\n    state_name_type: \"district\",\n    sub_isoids: \"01~02~03~04~05~06~07~08~09~10~11~12~13~14\",\n    sub_keys:\n      \"Aiwo District~Anabar District~Anetan District~Anibare District~Baiti District~Boe District~Buada District~Denigomodu District~Ewa District~Ijuw District~Meneng District~Nibok District~Uaboe District~Yaren District\",\n  },\n  \"data/NU\": { id: \"data/NU\", key: \"NU\", name: \"NIUE\" },\n  \"data/NZ\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C %Z\",\n    id: \"data/NZ\",\n    key: \"NZ\",\n    name: \"NEW ZEALAND\",\n    posturl:\n      \"http://www.nzpost.co.nz/Cultures/en-NZ/OnlineTools/PostCodeFinder/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"6001,6015,6332,8252,1030\",\n  },\n  \"data/OM\": {\n    fmt: \"%N%n%O%n%A%n%Z%n%C\",\n    id: \"data/OM\",\n    key: \"OM\",\n    name: \"OMAN\",\n    zip: \"(?:PC )?\\\\d{3}\",\n    zipex: \"133,112,111\",\n  },\n  \"data/PA\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/PA\",\n    key: \"PA\",\n    name: \"PANAMA (REP.)\",\n    upper: \"CS\",\n  },\n  \"data/PE\": {\n    fmt: \"%N%n%O%n%A%n%C %Z%n%S\",\n    id: \"data/PE\",\n    key: \"PE\",\n    lang: \"es\",\n    languages: \"es\",\n    locality_name_type: \"district\",\n    name: \"PERU\",\n    posturl: \"http://www.serpost.com.pe/cpostal/codigo\",\n    sub_isoids:\n      \"AMA~ANC~APU~ARE~AYA~CAJ~CAL~CUS~LIM~HUV~HUC~ICA~JUN~LAL~LAM~LOR~MDD~MOQ~LMA~PAS~PIU~PUN~SAM~TAC~TUM~UCA\",\n    sub_keys:\n      \"Amazonas~Áncash~Apurímac~Arequipa~Ayacucho~Cajamarca~Callao~Cuzco~Gobierno Regional de Lima~Huancavelica~Huánuco~Ica~Junín~La Libertad~Lambayeque~Loreto~Madre de Dios~Moquegua~Municipalidad Metropolitana de Lima~Pasco~Piura~Puno~San Martín~Tacna~Tumbes~Ucayali\",\n    zip: \"(?:LIMA \\\\d{1,2}|CALLAO 0?\\\\d)|[0-2]\\\\d{4}\",\n    zipex: \"LIMA 23,LIMA 42,CALLAO 2,02001\",\n  },\n  \"data/PF\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/PF\",\n    key: \"PF\",\n    name: \"FRENCH POLYNESIA\",\n    require: \"ACSZ\",\n    state_name_type: \"island\",\n    upper: \"CS\",\n    zip: \"987\\\\d{2}\",\n    zipex: \"98709\",\n  },\n  \"data/PG\": {\n    fmt: \"%N%n%O%n%A%n%C %Z %S\",\n    id: \"data/PG\",\n    key: \"PG\",\n    name: \"PAPUA NEW GUINEA\",\n    require: \"ACS\",\n    zip: \"\\\\d{3}\",\n    zipex: \"111\",\n  },\n  \"data/PH\": {\n    fmt: \"%N%n%O%n%A%n%D, %C%n%Z %S\",\n    id: \"data/PH\",\n    key: \"PH\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"PHILIPPINES\",\n    posturl: \"http://www.philpost.gov.ph/\",\n    sub_isoids:\n      \"ABR~AGN~AGS~AKL~ALB~ANT~APA~AUR~BAS~BAN~BTN~BTG~BEN~BIL~BOH~BUK~BUL~CAG~CAN~CAS~CAM~CAP~CAT~CAV~CEB~COM~NCO~DAV~DAS~DVO~DAO~DIN~EAS~GUI~IFU~ILN~ILS~ILI~ISA~KAL~LUN~LAG~LAN~LAS~LEY~MAG~MAD~MAS~00~MDC~MDR~MSC~MSR~MOU~NEC~NER~NSA~NUE~NUV~PLW~PAM~PAN~QUE~QUI~RIZ~ROM~WSA~SAR~SIG~SOR~SCO~SLE~SUK~SLU~SUN~SUR~TAR~TAW~ZMB~ZAN~ZAS~ZSI\",\n    sub_keys:\n      \"Abra~Agusan del Norte~Agusan del Sur~Aklan~Albay~Antique~Apayao~Aurora~Basilan~Bataan~Batanes~Batangas~Benguet~Biliran~Bohol~Bukidnon~Bulacan~Cagayan~Camarines Norte~Camarines Sur~Camiguin~Capiz~Catanduanes~Cavite~Cebu~Compostela Valley~Cotabato~Davao del Norte~Davao del Sur~Davao Occidental~Davao Oriental~Dinagat Islands~Eastern Samar~Guimaras~Ifugao~Ilocos Norte~Ilocos Sur~Iloilo~Isabela~Kalinga~La Union~Laguna~Lanao del Norte~Lanao del Sur~Leyte~Maguindanao~Marinduque~Masbate~Metro Manila~Mindoro Occidental~Mindoro Oriental~Misamis Occidental~Misamis Oriental~Mountain Province~Negros Occidental~Negros Oriental~Northern Samar~Nueva Ecija~Nueva Vizcaya~Palawan~Pampanga~Pangasinan~Quezon Province~Quirino~Rizal~Romblon~Samar~Sarangani~Siquijor~Sorsogon~South Cotabato~Southern Leyte~Sultan Kudarat~Sulu~Surigao del Norte~Surigao del Sur~Tarlac~Tawi-Tawi~Zambales~Zamboanga del Norte~Zamboanga del Sur~Zamboanga Sibuguey\",\n    sub_zipexs:\n      \"2800,2826~8600,8611~8500,8513~5600,5616~4500,4517~5700,5717~3800,3806,3808~3200,3207~7300,7306~2100,2114~3900,3905~4200,4234~2600,2615~6543,6550~6300,6337~8700,8723~3000,3024~3500,3528~4600,4612~4400,4436~9100,9104~5800,5816~4800,4810~4100,4126~6000,6053~8800,8810~9400,9417~8100,8120~8000,8010~8015,8013~8200,8210~8426,8412~6800,6822~5044,5046~3600,3610~2900,2922~2700,2733~5000,5043~3300,3336~3807,3809,3814~2500,2520~4000,4033~9200,9223~9300,9321,9700,9716~6500,6542~9600,9619~4900,4905~5400,5421~~5100,5111~5200,5214~7200,7215~9000,9025~2616,2625~6100,6132~6200,6224~6400,6423~3100,3133~3700,3714~5300,5322~2000,2022~2400,2447~4300,4342~3400,3405~1850,1990~5500,5516~6700,6725~8015~6225,6230~4700,4715~9500,9513~6600,6613~9800,9811~7400,7416~8400,8425~8300,8319~2300,2318~7500,7509~2200,2213~7100,7124~7000,7043~7000,7043\",\n    sub_zips:\n      \"28[0-2]~86[01]~85[01]~56[01]~45[01]~57[01]~380[0-68]~320~730~21[01]~390~42[0-3]~26(0|1[0-5])~65(4[3-9]|5)~63[0-3]~87[0-2]~30[0-2]~35[0-2]~46[01]~44[0-3]~910~58[01]~48[01]~41[0-2]~60[0-5]~88[01]~94[01]~81[0-2]~80[01]~801[1-5]~82[01]~84[12]~68[0-2]~504[4-6]~36[01]~29[0-2]~27[0-3]~50([0-3]|4[0-3])~33[0-3]~38(0[79]|1[0-4])~25[0-2]~40[0-3]~92[0-2]~9(3[0-2]|7[01])~65([0-3]|4[0-2])~96[01]~490~54[0-2]~~51[01]~52[01]~72[01]~90[0-2]~26(1[6-9]|2[0-5])~61[0-3]~62[0-2]~64[0-2]~31[0-3]~37[01]~53[0-2]~20[0-2]~24[0-4]~43[0-4]~340~1[89]~55[01]~67[0-2]~8015~62(2[5-9]|30)~47[01]~95[01]~66[10]~98[01]~74[01]~84[0-2]~83[01]~23[01]~750~22[01]~71[0-2]~70[0-4]~70[0-4]\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1008,1050,1135,1207,2000,1000\",\n  },\n  \"data/PK\": {\n    fmt: \"%N%n%O%n%A%n%C-%Z\",\n    id: \"data/PK\",\n    key: \"PK\",\n    name: \"PAKISTAN\",\n    posturl: \"http://www.pakpost.gov.pk/postcode.php\",\n    zip: \"\\\\d{5}\",\n    zipex: \"44000\",\n  },\n  \"data/PL\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/PL\",\n    key: \"PL\",\n    name: \"POLAND\",\n    posturl: \"http://kody.poczta-polska.pl/\",\n    require: \"ACZ\",\n    zip: \"\\\\d{2}-\\\\d{3}\",\n    zipex: \"00-950,05-470,48-300,32-015,00-940\",\n  },\n  \"data/PM\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/PM\",\n    key: \"PM\",\n    name: \"ST. PIERRE AND MIQUELON\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]5\\\\d{2}\",\n    zipex: \"97500\",\n  },\n  \"data/PN\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/PN\",\n    key: \"PN\",\n    name: \"PITCAIRN\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"PCRN 1ZZ\",\n    zipex: \"PCRN 1ZZ\",\n  },\n  \"data/PR\": {\n    fmt: \"%N%n%O%n%A%n%C PR %Z\",\n    id: \"data/PR\",\n    key: \"PR\",\n    name: \"PUERTO RICO\",\n    postprefix: \"PR \",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACZ\",\n    upper: \"ACNO\",\n    zip: \"(00[679]\\\\d{2})(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"00930\",\n  },\n  \"data/PT\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/PT\",\n    key: \"PT\",\n    name: \"PORTUGAL\",\n    posturl: \"http://www.ctt.pt/feapl_2/app/open/tools.jspx?tool=1\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}-\\\\d{3}\",\n    zipex: \"2725-079,1250-096,1201-950,2860-571,1208-148\",\n  },\n  \"data/PW\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/PW\",\n    key: \"PW\",\n    name: \"PALAU\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(969(?:39|40))(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"96940\",\n  },\n  \"data/PY\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/PY\",\n    key: \"PY\",\n    name: \"PARAGUAY\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1536,1538,1209\",\n  },\n  \"data/QA\": { id: \"data/QA\", key: \"QA\", name: \"QATAR\", upper: \"AC\" },\n  \"data/RE\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/RE\",\n    key: \"RE\",\n    name: \"REUNION\",\n    posturl:\n      \"http://www.laposte.fr/Particulier/Utiliser-nos-outils-pratiques/Outils-et-documents/Trouvez-un-code-postal\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"9[78]4\\\\d{2}\",\n    zipex: \"97400\",\n  },\n  \"data/RO\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/RO\",\n    key: \"RO\",\n    name: \"ROMANIA\",\n    posturl: \"http://www.posta-romana.ro/zip_codes\",\n    upper: \"AC\",\n    zip: \"\\\\d{6}\",\n    zipex: \"060274,061357,200716\",\n  },\n  \"data/RS\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/RS\",\n    key: \"RS\",\n    name: \"REPUBLIC OF SERBIA\",\n    posturl:\n      \"http://www.posta.rs/struktura/lat/aplikacije/pronadji/nadji-postu.asp\",\n    zip: \"\\\\d{5,6}\",\n    zipex: \"106314\",\n  },\n  \"data/RU\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    id: \"data/RU\",\n    key: \"RU\",\n    lang: \"ru\",\n    languages: \"ru\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    name: \"RUSSIAN FEDERATION\",\n    posturl: \"http://info.russianpost.ru/servlet/department\",\n    require: \"ACSZ\",\n    state_name_type: \"oblast\",\n    sub_isoids:\n      \"ALT~AMU~ARK~AST~BEL~BRY~VLA~VGG~VLG~VOR~YEV~ZAB~IVA~IRK~KB~KGD~KLU~KAM~KC~KEM~KIR~KOS~KDA~KYA~KGN~KRS~LEN~LIP~MAG~MOW~MOS~MUR~NEN~NIZ~NGR~NVS~OMS~ORE~ORL~PNZ~PER~PRI~PSK~AD~AL~BA~BU~DA~IN~KL~KR~KO~~ME~MO~SA~SE~TA~TY~UD~KK~ROS~RYA~SAM~SPE~SAR~SAK~SVE~~SMO~STA~TAM~TVE~TOM~TUL~TYU~ULY~KHA~KHM~CHE~CE~CU~CHU~YAN~YAR\",\n    sub_keys:\n      \"Алтайский край~Амурская область~Архангельская область~Астраханская область~Белгородская область~Брянская область~Владимирская область~Волгоградская область~Вологодская область~Воронежская область~Еврейская автономная область~Забайкальский край~Ивановская область~Иркутская область~Кабардино-Балкарская Республика~Калининградская область~Калужская область~Камчатский край~Карачаево-Черкесская Республика~Кемеровская область~Кировская область~Костромская область~Краснодарский край~Красноярский край~Курганская область~Курская область~Ленинградская область~Липецкая область~Магаданская область~Москва~Московская область~Мурманская область~Ненецкий автономный округ~Нижегородская область~Новгородская область~Новосибирская область~Омская область~Оренбургская область~Орловская область~Пензенская область~Пермский край~Приморский край~Псковская область~Республика Адыгея~Республика Алтай~Республика Башкортостан~Республика Бурятия~Республика Дагестан~Республика Ингушетия~Республика Калмыкия~Республика Карелия~Республика Коми~Автономна Республіка Крим~Республика Марий Эл~Республика Мордовия~Республика Саха (Якутия)~Республика Северная Осетия-Алания~Республика Татарстан~Республика Тыва~Республика Удмуртия~Республика Хакасия~Ростовская область~Рязанская область~Самарская область~Санкт-Петербург~Саратовская область~Сахалинская область~Свердловская область~Севастополь~Смоленская область~Ставропольский край~Тамбовская область~Тверская область~Томская область~Тульская область~Тюменская область~Ульяновская область~Хабаровский край~Ханты-Мансийский автономный округ~Челябинская область~Чеченская Республика~Чувашская Республика~Чукотский автономный округ~Ямало-Ненецкий автономный округ~Ярославская область\",\n    sub_lnames:\n      \"Altayskiy kray~Amurskaya oblast'~Arkhangelskaya oblast'~Astrakhanskaya oblast'~Belgorodskaya oblast'~Bryanskaya oblast'~Vladimirskaya oblast'~Volgogradskaya oblast'~Vologodskaya oblast'~Voronezhskaya oblast'~Evreyskaya avtonomnaya oblast'~Zabaykalskiy kray~Ivanovskaya oblast'~Irkutskaya oblast'~Kabardino-Balkarskaya Republits~Kaliningradskaya oblast'~Kaluzhskaya oblast'~Kamchatskiy kray~Karachaevo-Cherkesskaya Republits~Kemerovskaya oblast'~Kirovskaya oblast'~Kostromskaya oblast'~Krasnodarskiy kray~Krasnoyarskiy kray~Kurganskaya oblast'~Kurskaya oblast'~Leningradskaya oblast'~Lipetskaya oblast'~Magadanskaya oblast'~Moskva~Moskovskaya oblast'~Murmanskaya oblast'~Nenetskiy~Nizhegorodskaya oblast'~Novgorodskaya oblast'~Novosibirskaya oblast'~Omskaya oblast'~Orenburgskaya oblast'~Orlovskaya oblast'~Penzenskaya oblast'~Permskiy kray~Primorskiy kray~Pskovskaya oblast'~Respublika Adygeya~Altay Republits~Bashkortostan Republits~Buryatiya Republits~Dagestan Republits~Ingushetiya Republits~Respublika Kalmykiya~Kareliya Republits~Komi Republits~Respublika Krym~Respublika Mariy El~Respublika Mordoviya~Sakha (Yakutiya) Republits~Respublika Severnaya Osetiya-Alaniya~Respublika Tatarstan~Tyva Republits~Respublika Udmurtiya~Khakasiya Republits~Rostovskaya oblast'~Ryazanskaya oblast'~Samarskaya oblast'~Sankt-Peterburg~Saratovskaya oblast'~Sakhalinskaya oblast'~Sverdlovskaya oblast'~Sevastopol'~Smolenskaya oblast'~Stavropolskiy kray~Tambovskaya oblast'~Tverskaya oblast'~Tomskaya oblast'~Tulskaya oblast'~Tyumenskaya oblast'~Ulyanovskaya oblast'~Khabarovskiy kray~Khanty-Mansiyskiy avtonomnyy okrug~Chelyabinskaya oblast'~Chechenskaya Republits~Chuvashia~Chukotskiy~Yamalo-Nenetskiy~Yaroslavskaya oblast'\",\n    sub_names:\n      \"Алтайский край~Амурская область~Архангельская область~Астраханская область~Белгородская область~Брянская область~Владимирская область~Волгоградская область~Вологодская область~Воронежская область~Еврейская автономная область~Забайкальский край~Ивановская область~Иркутская область~Кабардино-Балкарская Республика~Калининградская область~Калужская область~Камчатский край~Карачаево-Черкесская Республика~Кемеровская область~Кировская область~Костромская область~Краснодарский край~Красноярский край~Курганская область~Курская область~Ленинградская область~Липецкая область~Магаданская область~Москва~Московская область~Мурманская область~Ненецкий автономный округ~Нижегородская область~Новгородская область~Новосибирская область~Омская область~Оренбургская область~Орловская область~Пензенская область~Пермский край~Приморский край~Псковская область~Республика Адыгея~Республика Алтай~Республика Башкортостан~Республика Бурятия~Республика Дагестан~Республика Ингушетия~Республика Калмыкия~Республика Карелия~Республика Коми~Республика Крым~Республика Марий Эл~Республика Мордовия~Республика Саха (Якутия)~Республика Северная Осетия-Алания~Республика Татарстан~Республика Тыва~Республика Удмуртия~Республика Хакасия~Ростовская область~Рязанская область~Самарская область~Санкт-Петербург~Саратовская область~Сахалинская область~Свердловская область~Севастополь~Смоленская область~Ставропольский край~Тамбовская область~Тверская область~Томская область~Тульская область~Тюменская область~Ульяновская область~Хабаровский край~Ханты-Мансийский автономный округ~Челябинская область~Чеченская Республика~Чувашская Республика~Чукотский автономный округ~Ямало-Ненецкий автономный округ~Ярославская область\",\n    sub_zips:\n      \"65[6-9]~67[56]~16[3-5]~41[4-6]~30[89]~24[1-3]~60[0-2]~40[0-4]~16[0-2]~39[4-7]~679~6(?:7[2-4]|87)~15[3-5]~66[4-9]~36[01]~23[6-8]~24[89]~68[348]~369~65[0-4]~61[0-3]~15[67]~35[0-4]~6(?:6[0-3]|4[78])~64[01]~30[5-7]~18[78]~39[89]~68[56]~1(?:0[1-9]|1|2|3[0-5]|4[0-4])~14[0-4]~18[34]~166~60[3-7]~17[3-5]~63[0-3]~64[4-6]~46[0-2]~30[23]~44[0-2]~61[4-9]~69[0-2]~18[0-2]~385~649~45[0-3]~67[01]~36[78]~386~35[89]~18[56]~16[7-9]~29[5-8]~42[45]~43[01]~67[78]~36[23]~42[0-3]~66[78]~42[67]~655~34[4-7]~39[01]~44[3-6]~19~41[0-3]~69[34]~62[0-4]~299~21[4-6]~35[5-7]~39[23]~17[0-2]~63[4-6]~30[01]~62[5-7]~43[23]~68[0-2]~628~45[4-7]~36[4-6]~42[89]~689~629~15[0-2]\",\n    upper: \"AC\",\n    zip: \"\\\\d{6}\",\n    zipex: \"247112,103375,188300\",\n  },\n  \"data/RW\": { id: \"data/RW\", key: \"RW\", name: \"RWANDA\", upper: \"AC\" },\n  \"data/SA\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/SA\",\n    key: \"SA\",\n    name: \"SAUDI ARABIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11564,11187,11142\",\n  },\n  \"data/SB\": { id: \"data/SB\", key: \"SB\", name: \"SOLOMON ISLANDS\" },\n  \"data/SC\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/SC\",\n    key: \"SC\",\n    name: \"SEYCHELLES\",\n    state_name_type: \"island\",\n    upper: \"S\",\n  },\n  \"data/SD\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/SD\",\n    key: \"SD\",\n    locality_name_type: \"district\",\n    name: \"SUDAN\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11042,11113\",\n  },\n  \"data/SE\": {\n    fmt: \"%O%n%N%n%A%nSE-%Z %C\",\n    id: \"data/SE\",\n    key: \"SE\",\n    locality_name_type: \"post_town\",\n    name: \"SWEDEN\",\n    postprefix: \"SE-\",\n    posturl:\n      \"http://www.posten.se/sv/Kundservice/Sidor/Sok-postnummer-resultat.aspx\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"11455,12345,10500\",\n  },\n  \"data/SG\": {\n    fmt: \"%N%n%O%n%A%nSINGAPORE %Z\",\n    id: \"data/SG\",\n    key: \"SG\",\n    name: \"REP. OF SINGAPORE\",\n    posturl: \"https://www.singpost.com/find-postal-code\",\n    require: \"AZ\",\n    zip: \"\\\\d{6}\",\n    zipex: \"546080,308125,408600\",\n  },\n  \"data/SH\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/SH\",\n    key: \"SH\",\n    name: \"SAINT HELENA\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"(?:ASCN|STHL) 1ZZ\",\n    zipex: \"STHL 1ZZ\",\n  },\n  \"data/SI\": {\n    fmt: \"%N%n%O%n%A%nSI-%Z %C\",\n    id: \"data/SI\",\n    key: \"SI\",\n    name: \"SLOVENIA\",\n    postprefix: \"SI-\",\n    zip: \"\\\\d{4}\",\n    zipex: \"4000,1001,2500\",\n  },\n  \"data/SK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/SK\",\n    key: \"SK\",\n    name: \"SLOVAKIA\",\n    posturl: \"http://psc.posta.sk\",\n    require: \"ACZ\",\n    zip: \"\\\\d{3} ?\\\\d{2}\",\n    zipex: \"010 01,023 14,972 48,921 01,975 99\",\n  },\n  \"data/SL\": { id: \"data/SL\", key: \"SL\", name: \"SIERRA LEONE\" },\n  \"data/SM\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/SM\",\n    key: \"SM\",\n    name: \"SAN MARINO\",\n    posturl: \"http://www.poste.it/online/cercacap/\",\n    require: \"AZ\",\n    zip: \"4789\\\\d\",\n    zipex: \"47890,47891,47895,47899\",\n  },\n  \"data/SN\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/SN\",\n    key: \"SN\",\n    name: \"SENEGAL\",\n    zip: \"\\\\d{5}\",\n    zipex: \"12500,46024,16556,10000\",\n  },\n  \"data/SO\": {\n    fmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    id: \"data/SO\",\n    key: \"SO\",\n    lang: \"so\",\n    languages: \"so\",\n    name: \"SOMALIA\",\n    require: \"ACS\",\n    sub_isoids: \"AW~BK~BN~BR~BY~GA~GE~HI~JD~JH~MU~NU~SA~SD~SH~SO~TO~WO\",\n    sub_keys: \"AD~BK~BN~BR~BY~GG~GD~HR~JD~JH~MD~NG~SG~SD~SH~SL~TG~WG\",\n    sub_names:\n      \"Awdal~Bakool~Banaadir~Bari~Bay~Galguduud~Gedo~Hiiraan~Jubbada Dhexe~Jubbada Hoose~Mudug~Nugaal~Sanaag~Shabeellaha Dhexe~Shabeellaha Hoose~Sool~Togdheer~Woqooyi Galbeed\",\n    upper: \"ACS\",\n    zip: \"[A-Z]{2} ?\\\\d{5}\",\n    zipex: \"JH 09010,AD 11010\",\n  },\n  \"data/SR\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/SR\",\n    key: \"SR\",\n    lang: \"nl\",\n    languages: \"nl\",\n    name: \"SURINAME\",\n    sub_isoids: \"BR~CM~CR~MA~NI~PR~PM~SA~SI~WA\",\n    sub_keys:\n      \"Brokopondo~Commewijne~Coronie~Marowijne~Nickerie~Para~Paramaribo~Saramacca~Sipaliwini~Wanica\",\n    upper: \"AS\",\n  },\n  \"data/SS\": { id: \"data/SS\", key: \"SS\", name: \"SOUTH SUDAN\" },\n  \"data/ST\": { id: \"data/ST\", key: \"ST\", name: \"SAO TOME AND PRINCIPE\" },\n  \"data/SV\": {\n    fmt: \"%N%n%O%n%A%n%Z-%C%n%S\",\n    id: \"data/SV\",\n    key: \"SV\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"EL SALVADOR\",\n    require: \"ACS\",\n    sub_isoids: \"AH~CA~CH~CU~LI~PA~UN~MO~SM~SS~SV~SA~SO~US\",\n    sub_keys:\n      \"Ahuachapan~Cabanas~Calatenango~Cuscatlan~La Libertad~La Paz~La Union~Morazan~San Miguel~San Salvador~San Vicente~Santa Ana~Sonsonate~Usulutan\",\n    sub_names:\n      \"Ahuachapán~Cabañas~Chalatenango~Cuscatlán~La Libertad~La Paz~La Unión~Morazán~San Miguel~San Salvador~San Vicente~Santa Ana~Sonsonate~Usulután\",\n    sub_zipexs:\n      \"CP 2101~CP 1201~CP 1301~CP 1401~CP 1501~CP 1601~CP 3101~CP 3201~CP 3301~CP 1101~CP 1701~CP 2201~CP 2301~CP 3401\",\n    sub_zips:\n      \"CP 21~CP 12~CP 13~CP 14~CP 15~CP 16~CP 31~CP 32~CP 33~CP 11~CP 17~CP 22~CP 23~CP 34\",\n    upper: \"CSZ\",\n    zip: \"CP [1-3][1-7][0-2]\\\\d\",\n    zipex: \"CP 1101\",\n  },\n  \"data/SX\": { id: \"data/SX\", key: \"SX\", name: \"SINT MAARTEN\" },\n  \"data/SY\": {\n    id: \"data/SY\",\n    key: \"SY\",\n    locality_name_type: \"district\",\n    name: \"SYRIA\",\n  },\n  \"data/SZ\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/SZ\",\n    key: \"SZ\",\n    name: \"SWAZILAND\",\n    posturl: \"http://www.sptc.co.sz/swazipost/codes/index.php\",\n    upper: \"ACZ\",\n    zip: \"[HLMS]\\\\d{3}\",\n    zipex: \"H100\",\n  },\n  \"data/TC\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/TC\",\n    key: \"TC\",\n    name: \"TURKS AND CAICOS ISLANDS\",\n    require: \"ACZ\",\n    upper: \"CZ\",\n    zip: \"TKCA 1ZZ\",\n    zipex: \"TKCA 1ZZ\",\n  },\n  \"data/TD\": { id: \"data/TD\", key: \"TD\", name: \"CHAD\" },\n  \"data/TF\": { id: \"data/TF\", key: \"TF\", name: \"FRENCH SOUTHERN TERRITORIES\" },\n  \"data/TG\": { id: \"data/TG\", key: \"TG\", name: \"TOGO\" },\n  \"data/TH\": {\n    fmt: \"%N%n%O%n%A%n%D %C%n%S %Z\",\n    id: \"data/TH\",\n    key: \"TH\",\n    lang: \"th\",\n    languages: \"th\",\n    lfmt: \"%N%n%O%n%A%n%D, %C%n%S %Z\",\n    name: \"THAILAND\",\n    sub_isoids:\n      \"81~10~71~46~62~40~38~22~24~20~18~36~86~57~50~92~23~63~26~73~48~30~80~60~12~96~55~31~13~77~25~94~14~56~82~93~66~65~76~67~54~83~44~49~58~35~95~45~85~21~70~16~52~51~42~33~47~90~91~11~75~74~27~19~17~64~72~84~32~43~39~15~37~41~53~61~34\",\n    sub_keys:\n      \"กระบี่~กรุงเทพมหานคร~กาญจนบุรี~กาฬสินธุ์~กำแพงเพชร~ขอนแก่น~จังหวัด บึงกาฬ~จันทบุรี~ฉะเชิงเทรา~ชลบุรี~ชัยนาท~ชัยภูมิ~ชุมพร~เชียงราย~เชียงใหม่~ตรัง~ตราด~ตาก~นครนายก~นครปฐม~นครพนม~นครราชสีมา~นครศรีธรรมราช~นครสวรรค์~นนทบุรี~นราธิวาส~น่าน~บุรีรัมย์~ปทุมธานี~ประจวบคีรีขันธ์~ปราจีนบุรี~ปัตตานี~พระนครศรีอยุธยา~พะเยา~พังงา~พัทลุง~พิจิตร~พิษณุโลก~เพชรบุรี~เพชรบูรณ์~แพร่~ภูเก็ต~มหาสารคาม~มุกดาหาร~แม่ฮ่องสอน~ยโสธร~ยะลา~ร้อยเอ็ด~ระนอง~ระยอง~ราชบุรี~ลพบุรี~ลำปาง~ลำพูน~เลย~ศรีสะเกษ~สกลนคร~สงขลา~สตูล~สมุทรปราการ~สมุทรสงคราม~สมุทรสาคร~สระแก้ว~สระบุรี~สิงห์บุรี~สุโขทัย~สุพรรณบุรี~สุราษฎร์ธานี~สุรินทร์~หนองคาย~หนองบัวลำภู~อ่างทอง~อำนาจเจริญ~อุดรธานี~อุตรดิตถ์~อุทัยธานี~อุบลราชธานี\",\n    sub_lnames:\n      \"Krabi~Bangkok~Kanchanaburi~Kalasin~Kamphaeng Phet~Khon Kaen~Bueng Kan~Chanthaburi~Chachoengsao~Chon Buri~Chai Nat~Chaiyaphum~Chumpon~Chiang Rai~Chiang Mai~Trang~Trat~Tak~Nakhon Nayok~Nakhon Pathom~Nakhon Phanom~Nakhon Ratchasima~Nakhon Si Thammarat~Nakhon Sawan~Nonthaburi~Narathiwat~Nan~Buri Ram~Pathum Thani~Prachuap Khiri Khan~Prachin Buri~Pattani~Phra Nakhon Si Ayutthaya~Phayao~Phang Nga~Phattalung~Phichit~Phitsanulok~Phetchaburi~Phetchabun~Phrae~Phuket~Maha Sarakham~Mukdahan~Mae Hong Son~Yasothon~Yala~Roi Et~Ranong~Rayong~Ratchaburi~Lop Buri~Lampang~Lamphun~Loei~Si Sa Ket~Sakon Nakhon~Songkhla~Satun~Samut Prakan~Samut Songkhram~Samut Sakhon~Sa Kaeo~Saraburi~Sing Buri~Sukhothai~Suphanburi~Surat Thani~Surin~Nong Khai~Nong Bua Lam Phu~Ang Thong~Amnat Charoen~Udon Thani~Uttaradit~Uthai Thani~Ubon Ratchathani\",\n    sub_zips:\n      \"81~10~71~46~62~40~~22~24~20~17~36~86~57~50~92~23~63~26~73~48~30~80~60~11~96~55~31~12~77~25~94~13~56~82~93~66~65~76~67~54~83~44~49~58~35~95~45~85~21~70~15~52~51~42~33~47~90~91~10~75~74~27~18~16~64~72~84~32~43~39~14~37~41~53~61~34\",\n    upper: \"S\",\n    zip: \"\\\\d{5}\",\n    zipex: \"10150,10210\",\n  },\n  \"data/TJ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TJ\",\n    key: \"TJ\",\n    name: \"TAJIKISTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"735450,734025\",\n  },\n  \"data/TK\": { id: \"data/TK\", key: \"TK\", name: \"TOKELAU\" },\n  \"data/TL\": { id: \"data/TL\", key: \"TL\", name: \"TIMOR-LESTE\" },\n  \"data/TM\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TM\",\n    key: \"TM\",\n    name: \"TURKMENISTAN\",\n    zip: \"\\\\d{6}\",\n    zipex: \"744000\",\n  },\n  \"data/TN\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TN\",\n    key: \"TN\",\n    name: \"TUNISIA\",\n    posturl: \"http://www.poste.tn/codes.php\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1002,8129,3100,1030\",\n  },\n  \"data/TO\": { id: \"data/TO\", key: \"TO\", name: \"TONGA\" },\n  \"data/TR\": {\n    fmt: \"%N%n%O%n%A%n%Z %C/%S\",\n    id: \"data/TR\",\n    key: \"TR\",\n    lang: \"tr\",\n    languages: \"tr\",\n    locality_name_type: \"district\",\n    name: \"TURKEY\",\n    posturl: \"http://postakodu.ptt.gov.tr/\",\n    require: \"ACZ\",\n    sub_isoids:\n      \"01~02~03~04~68~05~06~07~75~08~09~10~74~72~69~11~12~13~14~15~16~17~18~19~20~21~81~22~23~24~25~26~27~28~29~30~31~76~32~34~35~46~78~70~36~37~38~71~39~40~79~41~42~43~44~45~47~33~48~49~50~51~52~80~53~54~55~56~57~58~63~73~59~60~61~62~64~65~77~66~67\",\n    sub_keys:\n      \"Adana~Adıyaman~Afyon~Ağrı~Aksaray~Amasya~Ankara~Antalya~Ardahan~Artvin~Aydın~Balıkesir~Bartın~Batman~Bayburt~Bilecik~Bingöl~Bitlis~Bolu~Burdur~Bursa~Çanakkale~Çankırı~Çorum~Denizli~Diyarbakır~Düzce~Edirne~Elazığ~Erzincan~Erzurum~Eskişehir~Gaziantep~Giresun~Gümüşhane~Hakkari~Hatay~Iğdır~Isparta~İstanbul~İzmir~Kahramanmaraş~Karabük~Karaman~Kars~Kastamonu~Kayseri~Kırıkkale~Kırklareli~Kırşehir~Kilis~Kocaeli~Konya~Kütahya~Malatya~Manisa~Mardin~Mersin~Muğla~Muş~Nevşehir~Niğde~Ordu~Osmaniye~Rize~Sakarya~Samsun~Siirt~Sinop~Sivas~Şanlıurfa~Şırnak~Tekirdağ~Tokat~Trabzon~Tunceli~Uşak~Van~Yalova~Yozgat~Zonguldak\",\n    sub_zips:\n      \"01~02~03~04~68~05~06~07~75~08~09~10~74~72~69~11~12~13~14~15~16~17~18~19~20~21~81~22~23~24~25~26~27~28~29~30~31~76~32~34~35~46~78~70~36~37~38~71~39~40~79~41~42~43~44~45~47~33~48~49~50~51~52~80~53~54~55~56~57~58~63~73~59~60~61~62~64~65~77~66~67\",\n    zip: \"\\\\d{5}\",\n    zipex: \"01960,06101\",\n  },\n  \"data/TT\": { id: \"data/TT\", key: \"TT\", name: \"TRINIDAD AND TOBAGO\" },\n  \"data/TV\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S\",\n    id: \"data/TV\",\n    key: \"TV\",\n    lang: \"tyv\",\n    languages: \"tyv\",\n    name: \"TUVALU\",\n    state_name_type: \"island\",\n    sub_isoids: \"FUN~NMG~NMA~~NIT~NUI~NKF~NKL~VAI\",\n    sub_keys:\n      \"Funafuti~Nanumanga~Nanumea~Niulakita~Niutao~Nui~Nukufetau~Nukulaelae~Vaitupu\",\n    upper: \"ACS\",\n  },\n  \"data/TW\": {\n    fmt: \"%Z%n%S%C%n%A%n%O%n%N\",\n    id: \"data/TW\",\n    key: \"TW\",\n    lang: \"zh-Hant\",\n    languages: \"zh-Hant\",\n    lfmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    name: \"TAIWAN\",\n    posturl:\n      \"http://www.post.gov.tw/post/internet/f_searchzone/index.jsp?ID=190102\",\n    require: \"ACSZ\",\n    state_name_type: \"county\",\n    sub_isoids:\n      \"TXG~TPE~TTT~TNN~ILA~HUA~~NAN~PIF~MIA~TAO~KHH~KEE~~YUN~NWT~HSZ~HSQ~CYI~CYQ~CHA~PEN\",\n    sub_keys:\n      \"台中市~台北市~台東縣~台南市~宜蘭縣~花蓮縣~金門縣~南投縣~屏東縣~苗栗縣~桃園市~高雄市~基隆市~連江縣~雲林縣~新北市~新竹市~新竹縣~嘉義市~嘉義縣~彰化縣~澎湖縣\",\n    sub_lnames:\n      \"Taichung City~Taipei City~Taitung County~Tainan City~Yilan County~Hualien County~Kinmen County~Nantou County~Pingtung County~Miaoli County~Taoyuan City~Kaohsiung City~Keelung City~Lienchiang County~Yunlin County~New Taipei City~Hsinchu City~Hsinchu County~Chiayi City~Chiayi County~Changhua County~Penghu County\",\n    sub_mores:\n      \"true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true~true\",\n    sub_zipexs:\n      \"400,408,411,439~100,119~950,966~700,745~260,272~970,983~890,896~540,558~900,947~350,369~320,338~800,815,817,852~200,206~209,212~630,655~207,208,220,253~~302,315~~602,625~500,530~880,885\",\n    sub_zips:\n      \"4[0-3]~1[01]~9[56]~7[0-4]~2[67]~9[78]~89~5[45]~9[0-4]~3[56]~3[23]~8[02-5]|81[1-579]~20[0-6]~209|21[012]~6[3-5]~20[78]|2[2345]~300~30[2-8]|31~600~60[1-9]|6[12]~5[0123]~88\",\n    zip: \"\\\\d{3}(?:\\\\d{2})?\",\n    zipex: \"104,106,10603,40867\",\n  },\n  \"data/TZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/TZ\",\n    key: \"TZ\",\n    name: \"TANZANIA (UNITED REP.)\",\n    zip: \"\\\\d{4,5}\",\n    zipex: \"6090,34413\",\n  },\n  \"data/UA\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    id: \"data/UA\",\n    key: \"UA\",\n    lang: \"uk\",\n    languages: \"uk\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S%n%Z\",\n    name: \"UKRAINE\",\n    posturl: \"http://services.ukrposhta.com/postindex_new/\",\n    require: \"ACSZ\",\n    state_name_type: \"oblast\",\n    sub_isoids:\n      \"43~05~07~12~14~18~21~23~26~30~32~35~09~46~48~51~53~56~40~59~61~63~65~68~71~77~74\",\n    sub_keys:\n      \"Автономна Республіка Крим~Вінницька область~Волинська область~Дніпропетровська область~Донецька область~Житомирська область~Закарпатська область~Запорізька область~Івано-Франківська область~місто Київ~Київська область~Кіровоградська область~Луганська область~Львівська область~Миколаївська область~Одеська область~Полтавська область~Рівненська область~місто Севастополь~Сумська область~Тернопільська область~Харківська область~Херсонська область~Хмельницька область~Черкаська область~Чернівецька область~Чернігівська область\",\n    sub_lnames:\n      \"Crimea~Vinnyts'ka oblast~Volyns'ka oblast~Dnipropetrovsk oblast~Donetsk oblast~Zhytomyrs'ka oblast~Zakarpats'ka oblast~Zaporiz'ka oblast~Ivano-Frankivs'ka oblast~Kyiv city~Kiev oblast~Kirovohrads'ka oblast~Luhans'ka oblast~Lviv oblast~Mykolaivs'ka oblast~Odessa oblast~Poltavs'ka oblast~Rivnens'ka oblast~Sevastopol' city~Sums'ka oblast~Ternopil's'ka oblast~Kharkiv oblast~Khersons'ka oblast~Khmel'nyts'ka oblast~Cherkas'ka oblast~Chernivets'ka oblast~Chernihivs'ka oblast\",\n    sub_names:\n      \"Автономна Республіка Крим~Вінницька область~Волинська область~Дніпропетровська область~Донецька область~Житомирська область~Закарпатська область~Запорізька область~Івано-Франківська область~Київ~Київська область~Кіровоградська область~Луганська область~Львівська область~Миколаївська область~Одеська область~Полтавська область~Рівненська область~Севастополь~Сумська область~Тернопільська область~Харківська область~Херсонська область~Хмельницька область~Черкаська область~Чернівецька область~Чернігівська область\",\n    sub_zips:\n      \"9[5-8]~2[1-4]~4[3-5]~49|5[0-3]~8[3-7]~1[0-3]~8[89]|90~69|7[0-2]~7[6-8]~0[1-6]~0[7-9]~2[5-8]~9[1-4]~79|8[0-2]~5[4-7]~6[5-8]~3[6-9]~3[3-5]~99~4[0-2]~4[6-8]~6[1-4]~7[3-5]~29|3[0-2]~1[89]|20~5[89]|60~1[4-7]\",\n    zip: \"\\\\d{5}\",\n    zipex: \"15432,01055,01001\",\n  },\n  \"data/UG\": { id: \"data/UG\", key: \"UG\", name: \"UGANDA\" },\n  \"data/US\": {\n    fmt: \"%N%n%O%n%A%n%C, %S %Z\",\n    id: \"data/US\",\n    key: \"US\",\n    lang: \"en\",\n    languages: \"en\",\n    name: \"UNITED STATES\",\n    posturl: \"https://tools.usps.com/go/ZipLookupAction!input.action\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    sub_isoids:\n      \"AL~AK~~AZ~AR~~~~CA~CO~CT~DE~DC~FL~GA~~HI~ID~IL~IN~IA~KS~KY~LA~ME~~MD~MA~MI~~MN~MS~MO~MT~NE~NV~NH~NJ~NM~NY~NC~ND~~OH~OK~OR~~PA~~RI~SC~SD~TN~TX~UT~VT~~VA~WA~WV~WI~WY\",\n    sub_keys:\n      \"AL~AK~AS~AZ~AR~AA~AE~AP~CA~CO~CT~DE~DC~FL~GA~GU~HI~ID~IL~IN~IA~KS~KY~LA~ME~MH~MD~MA~MI~FM~MN~MS~MO~MT~NE~NV~NH~NJ~NM~NY~NC~ND~MP~OH~OK~OR~PW~PA~PR~RI~SC~SD~TN~TX~UT~VT~VI~VA~WA~WV~WI~WY\",\n    sub_names:\n      \"Alabama~Alaska~American Samoa~Arizona~Arkansas~Armed Forces (AA)~Armed Forces (AE)~Armed Forces (AP)~California~Colorado~Connecticut~Delaware~District of Columbia~Florida~Georgia~Guam~Hawaii~Idaho~Illinois~Indiana~Iowa~Kansas~Kentucky~Louisiana~Maine~Marshall Islands~Maryland~Massachusetts~Michigan~Micronesia~Minnesota~Mississippi~Missouri~Montana~Nebraska~Nevada~New Hampshire~New Jersey~New Mexico~New York~North Carolina~North Dakota~Northern Mariana Islands~Ohio~Oklahoma~Oregon~Palau~Pennsylvania~Puerto Rico~Rhode Island~South Carolina~South Dakota~Tennessee~Texas~Utah~Vermont~Virgin Islands~Virginia~Washington~West Virginia~Wisconsin~Wyoming\",\n    sub_zipexs:\n      \"35000,36999~99500,99999~96799~85000,86999~71600,72999~34000,34099~09000,09999~96200,96699~90000,96199~80000,81999~06000,06999~19700,19999~20000,56999~32000,34999~30000,39901~96910,96932~96700,96899~83200,83999~60000,62999~46000,47999~50000,52999~66000,67999~40000,42799~70000,71599~03900,04999~96960,96979~20600,21999~01000,05544~48000,49999~96941,96944~55000,56799~38600,39799~63000,65999~59000,59999~68000,69999~88900,89999~03000,03899~07000,08999~87000,88499~10000,00544~27000,28999~58000,58999~96950,96952~43000,45999~73000,74999~97000,97999~96940~15000,19699~00600,00999~02800,02999~29000,29999~57000,57999~37000,38599~75000,73344~84000,84999~05000,05999~00800,00899~20100,24699~98000,99499~24700,26999~53000,54999~82000,83414\",\n    sub_zips:\n      \"3[56]~99[5-9]~96799~8[56]~71[6-9]|72~340~09~96[2-6]~9[0-5]|96[01]~8[01]~06~19[7-9]~20[02-5]|569~3[23]|34[1-9]~3[01]|398|39901~969([1-2]\\\\d|3[12])~967[0-8]|9679[0-8]|968~83[2-9]~6[0-2]~4[67]~5[0-2]~6[67]~4[01]|42[0-7]~70|71[0-5]~039|04~969[67]~20[6-9]|21~01|02[0-7]|05501|05544~4[89]~9694[1-4]~55|56[0-7]~38[6-9]|39[0-7]~6[3-5]~59~6[89]~889|89~03[0-8]~0[78]~87|88[0-4]~1[0-4]|06390|00501|00544~2[78]~58~9695[0-2]~4[3-5]~7[34]~97~969(39|40)~1[5-8]|19[0-6]~00[679]~02[89]~29~57~37|38[0-5]~7[5-9]|885|73301|73344~84~05~008~201|2[23]|24[0-6]~98|99[0-4]~24[7-9]|2[56]~5[34]~82|83[01]|83414\",\n    upper: \"CS\",\n    zip: \"(\\\\d{5})(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"95014,22162-1010\",\n  },\n  \"data/UY\": {\n    fmt: \"%N%n%O%n%A%n%Z %C %S\",\n    id: \"data/UY\",\n    key: \"UY\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"URUGUAY\",\n    posturl:\n      \"http://www.correo.com.uy/index.asp?codPag=codPost&switchMapa=codPost\",\n    sub_isoids: \"AR~CA~CL~CO~DU~FS~FD~LA~MA~MO~PA~RN~RV~RO~SA~SJ~SO~TA~TT\",\n    sub_keys:\n      \"Artigas~Canelones~Cerro Largo~Colonia~Durazno~Flores~Florida~Lavalleja~Maldonado~Montevideo~Paysandú~Río Negro~Rivera~Rocha~Salto~San José~Soriano~Tacuarembó~Treinta y Tres\",\n    sub_zips:\n      \"55~9[01]|1[456]~37~70|75204~97~85~94|9060|97005~30~20~1|91600~60~65|60002~40~27~50~80~75|70003~45~33|30203|30204|30302|37007\",\n    upper: \"CS\",\n    zip: \"\\\\d{5}\",\n    zipex: \"11600\",\n  },\n  \"data/UZ\": {\n    fmt: \"%N%n%O%n%A%n%Z %C%n%S\",\n    id: \"data/UZ\",\n    key: \"UZ\",\n    name: \"UZBEKISTAN\",\n    posturl: \"http://www.pochta.uz/ru/uslugi/indexsearch.html\",\n    upper: \"CS\",\n    zip: \"\\\\d{6}\",\n    zipex: \"702100,700000\",\n  },\n  \"data/VA\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/VA\",\n    key: \"VA\",\n    name: \"VATICAN\",\n    zip: \"00120\",\n    zipex: \"00120\",\n  },\n  \"data/VC\": {\n    fmt: \"%N%n%O%n%A%n%C %Z\",\n    id: \"data/VC\",\n    key: \"VC\",\n    name: \"SAINT VINCENT AND THE GRENADINES (ANTILLES)\",\n    posturl:\n      \"http://www.svgpost.gov.vc/?option=com_content&view=article&id=3&Itemid=16\",\n    zip: \"VC\\\\d{4}\",\n    zipex: \"VC0100,VC0110,VC0400\",\n  },\n  \"data/VE\": {\n    fmt: \"%N%n%O%n%A%n%C %Z, %S\",\n    id: \"data/VE\",\n    key: \"VE\",\n    lang: \"es\",\n    languages: \"es\",\n    name: \"VENEZUELA\",\n    posturl: \"http://www.ipostel.gob.ve/index.php/oficinas-postales\",\n    require: \"ACS\",\n    state_name_type: \"state\",\n    sub_isoids: \"Z~B~C~D~E~F~G~H~Y~W~A~I~J~K~L~M~N~O~P~R~S~T~X~U~V\",\n    sub_keys:\n      \"Amazonas~Anzoátegui~Apure~Aragua~Barinas~Bolívar~Carabobo~Cojedes~Delta Amacuro~Dependencias Federales~Distrito Federal~Falcón~Guárico~Lara~Mérida~Miranda~Monagas~Nueva Esparta~Portuguesa~Sucre~Táchira~Trujillo~Vargas~Yaracuy~Zulia\",\n    upper: \"CS\",\n    zip: \"\\\\d{4}\",\n    zipex: \"1010,3001,8011,1020\",\n  },\n  \"data/VG\": {\n    fmt: \"%N%n%O%n%A%n%C%n%Z\",\n    id: \"data/VG\",\n    key: \"VG\",\n    name: \"VIRGIN ISLANDS (BRITISH)\",\n    require: \"A\",\n    zip: \"VG\\\\d{4}\",\n    zipex: \"VG1110,VG1150,VG1160\",\n  },\n  \"data/VI\": {\n    fmt: \"%N%n%O%n%A%n%C %S %Z\",\n    id: \"data/VI\",\n    key: \"VI\",\n    name: \"VIRGIN ISLANDS (U.S.)\",\n    posturl: \"http://zip4.usps.com/zip4/welcome.jsp\",\n    require: \"ACSZ\",\n    state_name_type: \"state\",\n    upper: \"ACNOS\",\n    zip: \"(008(?:(?:[0-4]\\\\d)|(?:5[01])))(?:[ \\\\-](\\\\d{4}))?\",\n    zip_name_type: \"zip\",\n    zipex: \"00802-1222,00850-9802\",\n  },\n  \"data/VN\": {\n    fmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    id: \"data/VN\",\n    key: \"VN\",\n    lang: \"vi\",\n    languages: \"vi\",\n    lfmt: \"%N%n%O%n%A%n%C%n%S %Z\",\n    name: \"VIET NAM\",\n    posturl: \"http://postcode.vnpost.vn/services/search.aspx\",\n    sub_isoids:\n      \"44~43~55~54~53~56~50~57~31~58~40~59~04~CT~DN~33~72~71~39~45~30~03~63~HN~23~61~HP~73~14~66~34~47~28~01~09~02~35~41~67~22~18~36~68~32~24~27~29~13~25~52~05~37~20~69~21~SG~26~46~51~07~49~70~06\",\n    sub_keys:\n      \"An Giang~Bà Rịa–Vũng Tàu~Bạc Liêu~Bắc Giang~Bắc Kạn~Bắc Ninh~Bến Tre~Bình Dương~Bình Định~Bình Phước~Bình Thuận~Cà Mau~Cao Bằng~Cần Thơ~Đà Nẵng~Đắk Lắk~Đăk Nông~Điện Biên~Đồng Nai~Đồng Tháp~Gia Lai~Hà Giang~Hà Nam~Hà Nội~Hà Tĩnh~Hải Dương~Hải Phòng~Hậu Giang~Hòa Bình~Hưng Yên~Khánh Hòa~Kiên Giang~Kon Tum~Lai Châu~Lạng Sơn~Lào Cai~Lâm Đồng~Long An~Nam Định~Nghệ An~Ninh Bình~Ninh Thuận~Phú Thọ~Phú Yên~Quảng Bình~Quảng Nam~Quảng Ngãi~Quảng Ninh~Quảng Trị~Sóc Trăng~Sơn La~Tây Ninh~Thái Bình~Thái Nguyên~Thanh Hóa~Thành phố Hồ Chí Minh~Thừa Thiên–Huế~Tiền Giang~Trà Vinh~Tuyên Quang~Vĩnh Long~Vĩnh Phúc~Yên Bái\",\n    sub_lnames:\n      \"An Giang Province~Ba Ria-Vung Tau Province~Bac Lieu Province~Bac Giang Province~Bac Kan Province~Bac Ninh Province~Ben Tre Province~Binh Duong Province~Binh Dinh Province~Binh Phuoc Province~Binh Thuan Province~Ca Mau Province~Cao Bang Province~Can Tho City~Da Nang City~Dak Lak Province~Dak Nong Province~Dien Bien Province~Dong Nai Province~Dong Thap Province~Gia Lai Province~Ha Giang Province~Ha Nam Province~Hanoi City~Ha Tinh Province~Hai Duong Province~Haiphong City~Hau Giang Province~Hoa Binh Province~Hung Yen Province~Khanh Hoa Province~Kien Giang Province~Kon Tum Province~Lai Chau Province~Lang Song Province~Lao Cai Province~Lam Dong Province~Long An Province~Nam Dinh Province~Nghe An Province~Ninh Binh Province~Ninh Thuan Province~Phu Tho Province~Phu Yen Province~Quang Binh Province~Quang Nam Province~Quang Ngai Province~Quang Ninh Province~Quang Tri Province~Soc Trang Province~Son La Province~Tay Ninh Province~Thai Binh Province~Thai Nguyen Province~Thanh Hoa Province~Ho Chi Minh City~Thua Thien-Hue Province~Tien Giang Province~Tra Vinh Province~Tuyen Quang Province~Vinh Long Province~Vinh Phuc Province~Yen Bai Province\",\n    zip: \"\\\\d{5}\\\\d?\",\n    zipex: \"70010,55999\",\n  },\n  \"data/VU\": { id: \"data/VU\", key: \"VU\", name: \"VANUATU\" },\n  \"data/WF\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/WF\",\n    key: \"WF\",\n    name: \"WALLIS AND FUTUNA ISLANDS\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"986\\\\d{2}\",\n    zipex: \"98600\",\n  },\n  \"data/WS\": { id: \"data/WS\", key: \"WS\", name: \"SAMOA\" },\n  \"data/XK\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/XK\",\n    key: \"XK\",\n    name: \"KOSOVO\",\n    zip: \"[1-7]\\\\d{4}\",\n    zipex: \"10000\",\n  },\n  \"data/YE\": { id: \"data/YE\", key: \"YE\", name: \"YEMEN\" },\n  \"data/YT\": {\n    fmt: \"%O%n%N%n%A%n%Z %C %X\",\n    id: \"data/YT\",\n    key: \"YT\",\n    name: \"MAYOTTE\",\n    require: \"ACZ\",\n    upper: \"ACX\",\n    zip: \"976\\\\d{2}\",\n    zipex: \"97600\",\n  },\n  \"data/ZA\": {\n    fmt: \"%N%n%O%n%A%n%D%n%C%n%Z\",\n    id: \"data/ZA\",\n    key: \"ZA\",\n    name: \"SOUTH AFRICA\",\n    posturl: \"https://www.postoffice.co.za/Questions/postalcode.html\",\n    require: \"ACZ\",\n    zip: \"\\\\d{4}\",\n    zipex: \"0083,1451,0001\",\n  },\n  \"data/ZM\": {\n    fmt: \"%N%n%O%n%A%n%Z %C\",\n    id: \"data/ZM\",\n    key: \"ZM\",\n    name: \"ZAMBIA\",\n    zip: \"\\\\d{5}\",\n    zipex: \"50100,50101\",\n  },\n  \"data/ZW\": { id: \"data/ZW\", key: \"ZW\", name: \"ZIMBABWE\" },\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddressMetaData);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs":
/*!******************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddressMetaDataExtension\": () => (/* binding */ AddressMetaDataExtension),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst AddressMetaDataExtension = {\n  \"data/AF\": {\n    alpha_3_code: \"AFG\",\n  },\n  \"data/AX\": {\n    alpha_3_code: \"ALA\",\n  },\n  \"data/AL\": {\n    alpha_3_code: \"ALB\",\n  },\n  \"data/DZ\": {\n    alpha_3_code: \"DZA\",\n  },\n  \"data/AS\": {\n    alpha_3_code: \"ASM\",\n  },\n  \"data/AD\": {\n    alpha_3_code: \"AND\",\n  },\n  \"data/AO\": {\n    alpha_3_code: \"AGO\",\n  },\n  \"data/AI\": {\n    alpha_3_code: \"AIA\",\n  },\n  \"data/AQ\": {\n    alpha_3_code: \"ATA\",\n  },\n  \"data/AG\": {\n    alpha_3_code: \"ATG\",\n  },\n  \"data/AR\": {\n    alpha_3_code: \"ARG\",\n  },\n  \"data/AM\": {\n    alpha_3_code: \"ARM\",\n  },\n  \"data/AW\": {\n    alpha_3_code: \"ABW\",\n  },\n  \"data/AU\": {\n    alpha_3_code: \"AUS\",\n  },\n  \"data/AT\": {\n    alpha_3_code: \"AUT\",\n  },\n  \"data/AZ\": {\n    alpha_3_code: \"AZE\",\n  },\n  \"data/BS\": {\n    alpha_3_code: \"BHS\",\n  },\n  \"data/BH\": {\n    alpha_3_code: \"BHR\",\n  },\n  \"data/BD\": {\n    alpha_3_code: \"BGD\",\n  },\n  \"data/BB\": {\n    alpha_3_code: \"BRB\",\n  },\n  \"data/BY\": {\n    alpha_3_code: \"BLR\",\n  },\n  \"data/BE\": {\n    alpha_3_code: \"BEL\",\n  },\n  \"data/BZ\": {\n    alpha_3_code: \"BLZ\",\n  },\n  \"data/BJ\": {\n    alpha_3_code: \"BEN\",\n  },\n  \"data/BM\": {\n    alpha_3_code: \"BMU\",\n  },\n  \"data/BT\": {\n    alpha_3_code: \"BTN\",\n  },\n  \"data/BO\": {\n    alpha_3_code: \"BOL\",\n  },\n  \"data/BQ\": {\n    alpha_3_code: \"BES\",\n  },\n  \"data/BA\": {\n    alpha_3_code: \"BIH\",\n  },\n  \"data/BW\": {\n    alpha_3_code: \"BWA\",\n  },\n  \"data/BV\": {\n    alpha_3_code: \"BVT\",\n  },\n  \"data/BR\": {\n    alpha_3_code: \"BRA\",\n  },\n  \"data/IO\": {\n    alpha_3_code: \"IOT\",\n  },\n  \"data/BN\": {\n    alpha_3_code: \"BRN\",\n  },\n  \"data/BG\": {\n    alpha_3_code: \"BGR\",\n  },\n  \"data/BF\": {\n    alpha_3_code: \"BFA\",\n  },\n  \"data/BI\": {\n    alpha_3_code: \"BDI\",\n  },\n  \"data/CV\": {\n    alpha_3_code: \"CPV\",\n  },\n  \"data/KH\": {\n    alpha_3_code: \"KHM\",\n  },\n  \"data/CM\": {\n    alpha_3_code: \"CMR\",\n  },\n  \"data/CA\": {\n    alpha_3_code: \"CAN\",\n  },\n  \"data/KY\": {\n    alpha_3_code: \"CYM\",\n  },\n  \"data/CF\": {\n    alpha_3_code: \"CAF\",\n  },\n  \"data/TD\": {\n    alpha_3_code: \"TCD\",\n  },\n  \"data/CL\": {\n    alpha_3_code: \"CHL\",\n  },\n  \"data/CN\": {\n    alpha_3_code: \"CHN\",\n  },\n  \"data/CX\": {\n    alpha_3_code: \"CXR\",\n  },\n  \"data/CC\": {\n    alpha_3_code: \"CCK\",\n  },\n  \"data/CO\": {\n    alpha_3_code: \"COL\",\n  },\n  \"data/KM\": {\n    alpha_3_code: \"COM\",\n  },\n  \"data/CG\": {\n    alpha_3_code: \"COG\",\n  },\n  \"data/CD\": {\n    alpha_3_code: \"COD\",\n  },\n  \"data/CK\": {\n    alpha_3_code: \"COK\",\n  },\n  \"data/CR\": {\n    alpha_3_code: \"CRI\",\n  },\n  \"data/CI\": {\n    alpha_3_code: \"CIV\",\n  },\n  \"data/HR\": {\n    alpha_3_code: \"HRV\",\n  },\n  \"data/CU\": {\n    alpha_3_code: \"CUB\",\n  },\n  \"data/CW\": {\n    alpha_3_code: \"CUW\",\n  },\n  \"data/CY\": {\n    alpha_3_code: \"CYP\",\n  },\n  \"data/CZ\": {\n    alpha_3_code: \"CZE\",\n  },\n  \"data/DK\": {\n    alpha_3_code: \"DNK\",\n  },\n  \"data/DJ\": {\n    alpha_3_code: \"DJI\",\n  },\n  \"data/DM\": {\n    alpha_3_code: \"DMA\",\n  },\n  \"data/DO\": {\n    alpha_3_code: \"DOM\",\n  },\n  \"data/EC\": {\n    alpha_3_code: \"ECU\",\n  },\n  \"data/EG\": {\n    alpha_3_code: \"EGY\",\n  },\n  \"data/SV\": {\n    alpha_3_code: \"SLV\",\n  },\n  \"data/GQ\": {\n    alpha_3_code: \"GNQ\",\n  },\n  \"data/ER\": {\n    alpha_3_code: \"ERI\",\n  },\n  \"data/EE\": {\n    alpha_3_code: \"EST\",\n  },\n  \"data/SZ\": {\n    alpha_3_code: \"SWZ\",\n  },\n  \"data/ET\": {\n    alpha_3_code: \"ETH\",\n  },\n  \"data/FK\": {\n    alpha_3_code: \"FLK\",\n  },\n  \"data/FO\": {\n    alpha_3_code: \"FRO\",\n  },\n  \"data/FJ\": {\n    alpha_3_code: \"FJI\",\n  },\n  \"data/FI\": {\n    alpha_3_code: \"FIN\",\n  },\n  \"data/FR\": {\n    alpha_3_code: \"FRA\",\n  },\n  \"data/GF\": {\n    alpha_3_code: \"GUF\",\n  },\n  \"data/PF\": {\n    alpha_3_code: \"PYF\",\n  },\n  \"data/TF\": {\n    alpha_3_code: \"ATF\",\n  },\n  \"data/GA\": {\n    alpha_3_code: \"GAB\",\n  },\n  \"data/GM\": {\n    alpha_3_code: \"GMB\",\n  },\n  \"data/GE\": {\n    alpha_3_code: \"GEO\",\n  },\n  \"data/DE\": {\n    alpha_3_code: \"DEU\",\n  },\n  \"data/GH\": {\n    alpha_3_code: \"GHA\",\n  },\n  \"data/GI\": {\n    alpha_3_code: \"GIB\",\n  },\n  \"data/GR\": {\n    alpha_3_code: \"GRC\",\n  },\n  \"data/GL\": {\n    alpha_3_code: \"GRL\",\n  },\n  \"data/GD\": {\n    alpha_3_code: \"GRD\",\n  },\n  \"data/GP\": {\n    alpha_3_code: \"GLP\",\n  },\n  \"data/GU\": {\n    alpha_3_code: \"GUM\",\n  },\n  \"data/GT\": {\n    alpha_3_code: \"GTM\",\n  },\n  \"data/GG\": {\n    alpha_3_code: \"GGY\",\n  },\n  \"data/GN\": {\n    alpha_3_code: \"GIN\",\n  },\n  \"data/GW\": {\n    alpha_3_code: \"GNB\",\n  },\n  \"data/GY\": {\n    alpha_3_code: \"GUY\",\n  },\n  \"data/HT\": {\n    alpha_3_code: \"HTI\",\n  },\n  \"data/HM\": {\n    alpha_3_code: \"HMD\",\n  },\n  \"data/VA\": {\n    alpha_3_code: \"VAT\",\n  },\n  \"data/HN\": {\n    alpha_3_code: \"HND\",\n  },\n  \"data/HK\": {\n    alpha_3_code: \"HKG\",\n  },\n  \"data/HU\": {\n    alpha_3_code: \"HUN\",\n  },\n  \"data/IS\": {\n    alpha_3_code: \"ISL\",\n  },\n  \"data/IN\": {\n    alpha_3_code: \"IND\",\n  },\n  \"data/ID\": {\n    alpha_3_code: \"IDN\",\n  },\n  \"data/IR\": {\n    alpha_3_code: \"IRN\",\n  },\n  \"data/IQ\": {\n    alpha_3_code: \"IRQ\",\n  },\n  \"data/IE\": {\n    alpha_3_code: \"IRL\",\n  },\n  \"data/IM\": {\n    alpha_3_code: \"IMN\",\n  },\n  \"data/IL\": {\n    alpha_3_code: \"ISR\",\n  },\n  \"data/IT\": {\n    alpha_3_code: \"ITA\",\n  },\n  \"data/JM\": {\n    alpha_3_code: \"JAM\",\n  },\n  \"data/JP\": {\n    alpha_3_code: \"JPN\",\n  },\n  \"data/JE\": {\n    alpha_3_code: \"JEY\",\n  },\n  \"data/JO\": {\n    alpha_3_code: \"JOR\",\n  },\n  \"data/KZ\": {\n    alpha_3_code: \"KAZ\",\n  },\n  \"data/KE\": {\n    alpha_3_code: \"KEN\",\n  },\n  \"data/KI\": {\n    alpha_3_code: \"KIR\",\n  },\n  \"data/KP\": {\n    alpha_3_code: \"PRK\",\n  },\n  \"data/KR\": {\n    alpha_3_code: \"KOR\",\n  },\n  \"data/KW\": {\n    alpha_3_code: \"KWT\",\n  },\n  \"data/KG\": {\n    alpha_3_code: \"KGZ\",\n  },\n  \"data/LA\": {\n    alpha_3_code: \"LAO\",\n  },\n  \"data/LV\": {\n    alpha_3_code: \"LVA\",\n  },\n  \"data/LB\": {\n    alpha_3_code: \"LBN\",\n  },\n  \"data/LS\": {\n    alpha_3_code: \"LSO\",\n  },\n  \"data/LR\": {\n    alpha_3_code: \"LBR\",\n  },\n  \"data/LY\": {\n    alpha_3_code: \"LBY\",\n  },\n  \"data/LI\": {\n    alpha_3_code: \"LIE\",\n  },\n  \"data/LT\": {\n    alpha_3_code: \"LTU\",\n  },\n  \"data/LU\": {\n    alpha_3_code: \"LUX\",\n  },\n  \"data/MO\": {\n    alpha_3_code: \"MAC\",\n  },\n  \"data/MG\": {\n    alpha_3_code: \"MDG\",\n  },\n  \"data/MW\": {\n    alpha_3_code: \"MWI\",\n  },\n  \"data/MY\": {\n    alpha_3_code: \"MYS\",\n  },\n  \"data/MV\": {\n    alpha_3_code: \"MDV\",\n  },\n  \"data/ML\": {\n    alpha_3_code: \"MLI\",\n  },\n  \"data/MT\": {\n    alpha_3_code: \"MLT\",\n  },\n  \"data/MH\": {\n    alpha_3_code: \"MHL\",\n  },\n  \"data/MQ\": {\n    alpha_3_code: \"MTQ\",\n  },\n  \"data/MR\": {\n    alpha_3_code: \"MRT\",\n  },\n  \"data/MU\": {\n    alpha_3_code: \"MUS\",\n  },\n  \"data/YT\": {\n    alpha_3_code: \"MYT\",\n  },\n  \"data/MX\": {\n    alpha_3_code: \"MEX\",\n  },\n  \"data/FM\": {\n    alpha_3_code: \"FSM\",\n  },\n  \"data/MD\": {\n    alpha_3_code: \"MDA\",\n  },\n  \"data/MC\": {\n    alpha_3_code: \"MCO\",\n  },\n  \"data/MN\": {\n    alpha_3_code: \"MNG\",\n  },\n  \"data/ME\": {\n    alpha_3_code: \"MNE\",\n  },\n  \"data/MS\": {\n    alpha_3_code: \"MSR\",\n  },\n  \"data/MA\": {\n    alpha_3_code: \"MAR\",\n  },\n  \"data/MZ\": {\n    alpha_3_code: \"MOZ\",\n  },\n  \"data/MM\": {\n    alpha_3_code: \"MMR\",\n  },\n  \"data/NA\": {\n    alpha_3_code: \"NAM\",\n  },\n  \"data/NR\": {\n    alpha_3_code: \"NRU\",\n  },\n  \"data/NP\": {\n    alpha_3_code: \"NPL\",\n  },\n  \"data/NL\": {\n    alpha_3_code: \"NLD\",\n  },\n  \"data/NC\": {\n    alpha_3_code: \"NCL\",\n  },\n  \"data/NZ\": {\n    alpha_3_code: \"NZL\",\n  },\n  \"data/NI\": {\n    alpha_3_code: \"NIC\",\n  },\n  \"data/NE\": {\n    alpha_3_code: \"NER\",\n  },\n  \"data/NG\": {\n    alpha_3_code: \"NGA\",\n  },\n  \"data/NU\": {\n    alpha_3_code: \"NIU\",\n  },\n  \"data/NF\": {\n    alpha_3_code: \"NFK\",\n  },\n  \"data/MK\": {\n    alpha_3_code: \"MKD\",\n  },\n  \"data/MP\": {\n    alpha_3_code: \"MNP\",\n  },\n  \"data/NO\": {\n    alpha_3_code: \"NOR\",\n  },\n  \"data/OM\": {\n    alpha_3_code: \"OMN\",\n  },\n  \"data/PK\": {\n    alpha_3_code: \"PAK\",\n  },\n  \"data/PW\": {\n    alpha_3_code: \"PLW\",\n  },\n  \"data/PS\": {\n    alpha_3_code: \"PSE\",\n  },\n  \"data/PA\": {\n    alpha_3_code: \"PAN\",\n  },\n  \"data/PG\": {\n    alpha_3_code: \"PNG\",\n  },\n  \"data/PY\": {\n    alpha_3_code: \"PRY\",\n  },\n  \"data/PE\": {\n    alpha_3_code: \"PER\",\n  },\n  \"data/PH\": {\n    alpha_3_code: \"PHL\",\n  },\n  \"data/PN\": {\n    alpha_3_code: \"PCN\",\n  },\n  \"data/PL\": {\n    alpha_3_code: \"POL\",\n  },\n  \"data/PT\": {\n    alpha_3_code: \"PRT\",\n  },\n  \"data/PR\": {\n    alpha_3_code: \"PRI\",\n  },\n  \"data/QA\": {\n    alpha_3_code: \"QAT\",\n  },\n  \"data/RE\": {\n    alpha_3_code: \"REU\",\n  },\n  \"data/RO\": {\n    alpha_3_code: \"ROU\",\n  },\n  \"data/RU\": {\n    alpha_3_code: \"RUS\",\n  },\n  \"data/RW\": {\n    alpha_3_code: \"RWA\",\n  },\n  \"data/BL\": {\n    alpha_3_code: \"BLM\",\n  },\n  \"data/SH\": {\n    alpha_3_code: \"SHN\",\n  },\n  \"data/KN\": {\n    alpha_3_code: \"KNA\",\n  },\n  \"data/LC\": {\n    alpha_3_code: \"LCA\",\n  },\n  \"data/MF\": {\n    alpha_3_code: \"MAF\",\n  },\n  \"data/PM\": {\n    alpha_3_code: \"SPM\",\n  },\n  \"data/VC\": {\n    alpha_3_code: \"VCT\",\n  },\n  \"data/WS\": {\n    alpha_3_code: \"WSM\",\n  },\n  \"data/SM\": {\n    alpha_3_code: \"SMR\",\n  },\n  \"data/ST\": {\n    alpha_3_code: \"STP\",\n  },\n  \"data/SA\": {\n    alpha_3_code: \"SAU\",\n  },\n  \"data/SN\": {\n    alpha_3_code: \"SEN\",\n  },\n  \"data/RS\": {\n    alpha_3_code: \"SRB\",\n  },\n  \"data/SC\": {\n    alpha_3_code: \"SYC\",\n  },\n  \"data/SL\": {\n    alpha_3_code: \"SLE\",\n  },\n  \"data/SG\": {\n    alpha_3_code: \"SGP\",\n  },\n  \"data/SX\": {\n    alpha_3_code: \"SXM\",\n  },\n  \"data/SK\": {\n    alpha_3_code: \"SVK\",\n  },\n  \"data/SI\": {\n    alpha_3_code: \"SVN\",\n  },\n  \"data/SB\": {\n    alpha_3_code: \"SLB\",\n  },\n  \"data/SO\": {\n    alpha_3_code: \"SOM\",\n  },\n  \"data/ZA\": {\n    alpha_3_code: \"ZAF\",\n  },\n  \"data/GS\": {\n    alpha_3_code: \"SGS\",\n  },\n  \"data/SS\": {\n    alpha_3_code: \"SSD\",\n  },\n  \"data/ES\": {\n    alpha_3_code: \"ESP\",\n  },\n  \"data/LK\": {\n    alpha_3_code: \"LKA\",\n  },\n  \"data/SD\": {\n    alpha_3_code: \"SDN\",\n  },\n  \"data/SR\": {\n    alpha_3_code: \"SUR\",\n  },\n  \"data/SJ\": {\n    alpha_3_code: \"SJM\",\n  },\n  \"data/SE\": {\n    alpha_3_code: \"SWE\",\n  },\n  \"data/CH\": {\n    alpha_3_code: \"CHE\",\n  },\n  \"data/SY\": {\n    alpha_3_code: \"SYR\",\n  },\n  \"data/TW\": {\n    alpha_3_code: \"TWN\",\n  },\n  \"data/TJ\": {\n    alpha_3_code: \"TJK\",\n  },\n  \"data/TZ\": {\n    alpha_3_code: \"TZA\",\n  },\n  \"data/TH\": {\n    alpha_3_code: \"THA\",\n  },\n  \"data/TL\": {\n    alpha_3_code: \"TLS\",\n  },\n  \"data/TG\": {\n    alpha_3_code: \"TGO\",\n  },\n  \"data/TK\": {\n    alpha_3_code: \"TKL\",\n  },\n  \"data/TO\": {\n    alpha_3_code: \"TON\",\n  },\n  \"data/TT\": {\n    alpha_3_code: \"TTO\",\n  },\n  \"data/TN\": {\n    alpha_3_code: \"TUN\",\n  },\n  \"data/TR\": {\n    alpha_3_code: \"TUR\",\n  },\n  \"data/TM\": {\n    alpha_3_code: \"TKM\",\n  },\n  \"data/TC\": {\n    alpha_3_code: \"TCA\",\n  },\n  \"data/TV\": {\n    alpha_3_code: \"TUV\",\n  },\n  \"data/UG\": {\n    alpha_3_code: \"UGA\",\n  },\n  \"data/UA\": {\n    alpha_3_code: \"UKR\",\n  },\n  \"data/AE\": {\n    alpha_3_code: \"ARE\",\n  },\n  \"data/GB\": {\n    alpha_3_code: \"GBR\",\n  },\n  \"data/US\": {\n    alternative_names: [\n      \"US\",\n      \"United States of America\",\n      \"United States\",\n      \"America\",\n      \"U.S.\",\n      \"USA\",\n      \"U.S.A.\",\n      \"U.S.A\",\n    ],\n    alpha_3_code: \"USA\",\n  },\n  \"data/UM\": {\n    alpha_3_code: \"UMI\",\n  },\n  \"data/UY\": {\n    alpha_3_code: \"URY\",\n  },\n  \"data/UZ\": {\n    alpha_3_code: \"UZB\",\n  },\n  \"data/VU\": {\n    alpha_3_code: \"VUT\",\n  },\n  \"data/VE\": {\n    alpha_3_code: \"VEN\",\n  },\n  \"data/VN\": {\n    alpha_3_code: \"VNM\",\n  },\n  \"data/VG\": {\n    alpha_3_code: \"VGB\",\n  },\n  \"data/VI\": {\n    alpha_3_code: \"VIR\",\n  },\n  \"data/WF\": {\n    alpha_3_code: \"WLF\",\n  },\n  \"data/EH\": {\n    alpha_3_code: \"ESH\",\n  },\n  \"data/YE\": {\n    alpha_3_code: \"YEM\",\n  },\n  \"data/ZM\": {\n    alpha_3_code: \"ZMB\",\n  },\n  \"data/ZW\": {\n    alpha_3_code: \"ZWE\",\n  },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddressMetaDataExtension);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddressMetaDataLoader\": () => (/* binding */ AddressMetaDataLoader),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  AddressMetaData: \"resource://gre/modules/shared/AddressMetaData.sys.mjs\",\n  AddressMetaDataExtension:\n    \"resource://gre/modules/shared/AddressMetaDataExtension.sys.mjs\",\n});\n\nclass AddressMetaDataLoader {\n  // Status of address data loading. We'll load all the countries with basic level 1\n  // information while requesting conutry information, and set country to true.\n  // Level 1 Set is for recording which country's level 1/level 2 data is loaded,\n  // since we only load this when getCountryAddressData called with level 1 parameter.\n  static dataLoaded = {\n    country: false,\n    level1: new Set(),\n  };\n\n  static addressData = {};\n\n  static DATA_PREFIX = \"data/\";\n\n  /**\n   * Load address meta data and extension into one object.\n   *\n   * @returns {object}\n   *          An object containing address data object with properties from extension.\n   */\n  static loadAddressMetaData() {\n    const addressMetaData = lazy.AddressMetaData;\n\n    for (const key in lazy.AddressMetaDataExtension) {\n      let addressDataForKey = addressMetaData[key];\n      if (!addressDataForKey) {\n        addressDataForKey = addressMetaData[key] = {};\n      }\n\n      Object.assign(addressDataForKey, lazy.AddressMetaDataExtension[key]);\n    }\n    return addressMetaData;\n  }\n\n  /**\n   * Convert certain properties' string value into array. We should make sure\n   * the cached data is parsed.\n   *\n   * @param   {object} data Original metadata from addressReferences.\n   * @returns {object} parsed metadata with property value that converts to array.\n   */\n  static #parse(data) {\n    if (!data) {\n      return null;\n    }\n\n    const properties = [\n      \"languages\",\n      \"sub_keys\",\n      \"sub_isoids\",\n      \"sub_names\",\n      \"sub_lnames\",\n    ];\n    for (const key of properties) {\n      if (!data[key]) {\n        continue;\n      }\n      // No need to normalize data if the value is array already.\n      if (Array.isArray(data[key])) {\n        return data;\n      }\n\n      data[key] = data[key].split(\"~\");\n    }\n    return data;\n  }\n\n  /**\n   * We'll cache addressData in the loader once the data loaded from scripts.\n   * It'll become the example below after loading addressReferences with extension:\n   * addressData: {\n   *               \"data/US\": {\"lang\": [\"en\"], ...// Data defined in libaddressinput metadata\n   *                           \"alternative_names\": ... // Data defined in extension }\n   *               \"data/CA\": {} // Other supported country metadata\n   *               \"data/TW\": {} // Other supported country metadata\n   *               \"data/TW/台北市\": {} // Other supported country level 1 metadata\n   *              }\n   *\n   * @param   {string} country\n   * @param   {string?} level1\n   * @returns {object} Default locale metadata\n   */\n  static #loadData(country, level1 = null) {\n    // Load the addressData if needed\n    if (!this.dataLoaded.country) {\n      this.addressData = this.loadAddressMetaData();\n      this.dataLoaded.country = true;\n    }\n    if (!level1) {\n      return this.#parse(this.addressData[`${this.DATA_PREFIX}${country}`]);\n    }\n    // If level1 is set, load addressReferences under country folder with specific\n    // country/level 1 for level 2 information.\n    if (!this.dataLoaded.level1.has(country)) {\n      Object.assign(this.addressData, this.loadAddressMetaData());\n      this.dataLoaded.level1.add(country);\n    }\n    return this.#parse(\n      this.addressData[`${this.DATA_PREFIX}${country}/${level1}`]\n    );\n  }\n\n  /**\n   * Return the region metadata with default locale and other locales (if exists).\n   *\n   * @param   {string} country\n   * @param   {string?} level1\n   * @returns {object} Return default locale and other locales metadata.\n   */\n  static getData(country, level1 = null) {\n    const defaultLocale = this.#loadData(country, level1);\n    if (!defaultLocale) {\n      return null;\n    }\n\n    const countryData = this.#parse(\n      this.addressData[`${this.DATA_PREFIX}${country}`]\n    );\n    let locales = [];\n    // TODO: Should be able to support multi-locale level 1/ level 2 metadata query\n    //      in Bug 1421886\n    if (countryData.languages) {\n      const list = countryData.languages.filter(\n        key => key !== countryData.lang\n      );\n      locales = list.map(key =>\n        this.#parse(this.addressData[`${defaultLocale.id}--${key}`])\n      );\n    }\n    return { defaultLocale, locales };\n  }\n\n  /**\n   * Return an array containing countries alpha2 codes.\n   *\n   * @returns {Array} Return an array containing countries alpha2 codes.\n   */\n  static get #countryCodes() {\n    return Object.keys(lazy.AddressMetaDataExtension).map(dataKey =>\n      dataKey.replace(this.DATA_PREFIX, \"\")\n    );\n  }\n\n  static getCountries(locales = []) {\n    const displayNames = new Intl.DisplayNames(locales, {\n      type: \"region\",\n      fallback: \"none\",\n    });\n    const countriesMap = new Map();\n    for (const countryCode of this.#countryCodes) {\n      countriesMap.set(countryCode, displayNames.of(countryCode));\n    }\n    return countriesMap;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AddressMetaDataLoader);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs":
/*!*******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddressRecord\": () => (/* binding */ AddressRecord)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_PhoneNumber_sys_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! resource://gre/modules/shared/PhoneNumber.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs\");\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* eslint-disable no-useless-concat */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n\n\n/**\n * The AddressRecord class serves to handle and normalize internal address records.\n * AddressRecord is used for processing and consistent data representation.\n */\nclass AddressRecord {\n  static NAME_COMPONENTS = [\"given-name\", \"additional-name\", \"family-name\"];\n\n  static STREET_ADDRESS_COMPONENTS = [\n    \"address-line1\",\n    \"address-line2\",\n    \"address-line3\",\n  ];\n  static TEL_COMPONENTS = [\n    \"tel-country-code\",\n    \"tel-national\",\n    \"tel-area-code\",\n    \"tel-local\",\n    \"tel-local-prefix\",\n    \"tel-local-suffix\",\n  ];\n\n  static computeFields(address) {\n    this.#computeNameFields(address);\n    this.#computeAddressLineFields(address);\n    this.#computeCountryFields(address);\n    this.#computeTelFields(address);\n  }\n\n  static #computeNameFields(address) {\n    // Compute split names\n    if (!(\"given-name\" in address)) {\n      const nameParts = resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillNameUtils.splitName(address.name);\n      address[\"given-name\"] = nameParts.given;\n      address[\"additional-name\"] = nameParts.middle;\n      address[\"family-name\"] = nameParts.family;\n    }\n  }\n\n  static #computeAddressLineFields(address) {\n    // Compute address lines\n    if (!(\"address-line1\" in address)) {\n      let streetAddress = [];\n      if (address[\"street-address\"]) {\n        streetAddress = address[\"street-address\"]\n          .split(\"\\n\")\n          .map(s => s.trim());\n      }\n      for (let i = 0; i < 3; i++) {\n        address[`address-line${i + 1}`] = streetAddress[i] || \"\";\n      }\n      if (streetAddress.length > 3) {\n        address[\"address-line3\"] = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.toOneLineAddress(\n          streetAddress.slice(2)\n        );\n      }\n    }\n  }\n\n  static #computeCountryFields(address) {\n    // Compute country name\n    if (!(\"country-name\" in address)) {\n      address[\"country-name\"] =\n        resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofill.countries.get(address.country) ?? \"\";\n    }\n  }\n\n  static #computeTelFields(address) {\n    // Compute tel\n    if (!(\"tel-national\" in address)) {\n      if (address.tel) {\n        let tel = resource_gre_modules_shared_PhoneNumber_sys_mjs__WEBPACK_IMPORTED_MODULE_2__.PhoneNumber.Parse(\n          address.tel,\n          address.country || resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.FormAutofill.DEFAULT_REGION\n        );\n        if (tel) {\n          if (tel.countryCode) {\n            address[\"tel-country-code\"] = tel.countryCode;\n          }\n          if (tel.nationalNumber) {\n            address[\"tel-national\"] = tel.nationalNumber;\n          }\n\n          // PhoneNumberUtils doesn't support parsing the components of a telephone\n          // number so we hard coded the parser for US numbers only. We will need\n          // to figure out how to parse numbers from other regions when we support\n          // new countries in the future.\n          if (tel.nationalNumber && tel.countryCode == \"+1\") {\n            let telComponents = tel.nationalNumber.match(\n              /(\\d{3})((\\d{3})(\\d{4}))$/\n            );\n            if (telComponents) {\n              address[\"tel-area-code\"] = telComponents[1];\n              address[\"tel-local\"] = telComponents[2];\n              address[\"tel-local-prefix\"] = telComponents[3];\n              address[\"tel-local-suffix\"] = telComponents[4];\n            }\n          }\n        } else {\n          // Treat \"tel\" as \"tel-national\" directly if it can't be parsed.\n          address[\"tel-national\"] = address.tel;\n        }\n      }\n\n      this.TEL_COMPONENTS.forEach(c => {\n        address[c] = address[c] || \"\";\n      });\n    }\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs":
/*!***********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddressTelemetry\": () => (/* binding */ AddressTelemetry),\n/* harmony export */   \"AutofillTelemetry\": () => (/* binding */ AutofillTelemetry)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillSection.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconst { FIELD_STATES } = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils;\n\nclass AutofillTelemetryBase {\n  SUPPORTED_FIELDS = {};\n\n  EVENT_CATEGORY = null;\n  EVENT_OBJECT_FORM_INTERACTION = null;\n\n  SCALAR_DETECTED_SECTION_COUNT = null;\n  SCALAR_SUBMITTED_SECTION_COUNT = null;\n\n  HISTOGRAM_NUM_USES = null;\n  HISTOGRAM_PROFILE_NUM_USES = null;\n  HISTOGRAM_PROFILE_NUM_USES_KEY = null;\n\n  #initFormEventExtra(value) {\n    let extra = {};\n    for (const field of Object.values(this.SUPPORTED_FIELDS)) {\n      extra[field] = value;\n    }\n    return extra;\n  }\n\n  #setFormEventExtra(extra, key, value) {\n    if (!this.SUPPORTED_FIELDS[key]) {\n      return;\n    }\n\n    extra[this.SUPPORTED_FIELDS[key]] = value;\n  }\n\n  /**\n   * Building the extra keys object that is included in the Legacy Telemetry event `cc_form_v2`\n   * or `address_form` event and the Glean event `cc_form`, and `address_form`.\n   * It indicates the detected credit card or address fields and which method (autocomplete property, regular expression heuristics or fathom) identified them.\n   *\n   * @param {object} section Using section.fieldDetails to extract which fields were identified and how\n   * @param {string} undetected Default value when a field is not detected: 'undetected' (Glean) and 'false' in (Legacy)\n   * @param {string} autocomplete Value when a field is identified with autocomplete property: 'autocomplete' (Glean), 'true' (Legacy)\n   * @param {string} regexp Value when a field is identified with regex expression heuristics: 'regexp' (Glean), '0' (Legacy)\n   * @param {boolean} includeMultiPart Include multi part data or not\n   * @returns {object} Extra keys to include in the form event\n   */\n  #buildFormDetectedEventExtra(\n    section,\n    undetected,\n    autocomplete,\n    regexp,\n    includeMultiPart\n  ) {\n    let extra = this.#initFormEventExtra(undetected);\n\n    let identified = new Set();\n    section.fieldDetails.forEach(detail => {\n      identified.add(detail.fieldName);\n\n      if (detail.reason == \"autocomplete\") {\n        this.#setFormEventExtra(extra, detail.fieldName, autocomplete);\n      } else {\n        // confidence exists only when a field is identified by fathom.\n        let confidence =\n          detail.confidence > 0 ? Math.floor(100 * detail.confidence) / 100 : 0;\n\n        this.#setFormEventExtra(\n          extra,\n          detail.fieldName,\n          confidence ? confidence.toString() : regexp\n        );\n      }\n\n      if (\n        detail.fieldName === \"cc-number\" &&\n        this.SUPPORTED_FIELDS[detail.fieldName] &&\n        includeMultiPart\n      ) {\n        extra.cc_number_multi_parts = detail.part ?? 1;\n      }\n    });\n    return extra;\n  }\n\n  recordFormDetected(section) {\n    this.recordFormEvent(\n      \"detected\",\n      section.flowId,\n      this.#buildFormDetectedEventExtra(section, \"false\", \"true\", \"0\", false)\n    );\n\n    this.recordGleanFormEvent(\n      \"formDetected\",\n      section.flowId,\n      this.#buildFormDetectedEventExtra(\n        section,\n        \"undetected\",\n        \"autocomplete\",\n        \"regexp\",\n        true\n      )\n    );\n  }\n\n  recordPopupShown(section, fieldName) {\n    const extra = { field_name: fieldName };\n    this.recordFormEvent(\"popup_shown\", section.flowId, extra);\n    this.recordGleanFormEvent(\"formPopupShown\", section.flowId, extra);\n  }\n\n  recordFormFilled(section, profile) {\n    // Calculate values for telemetry\n    let extra = this.#initFormEventExtra(\"unavailable\");\n\n    for (let fieldDetail of section.fieldDetails) {\n      let element = fieldDetail.element;\n      let state = profile[fieldDetail.fieldName] ? \"filled\" : \"not_filled\";\n      if (\n        section.handler.getFilledStateByElement(element) ==\n          FIELD_STATES.NORMAL &&\n        (HTMLSelectElement.isInstance(element) ||\n          (HTMLInputElement.isInstance(element) && element.value.length))\n      ) {\n        state = \"user_filled\";\n      }\n      this.#setFormEventExtra(extra, fieldDetail.fieldName, state);\n    }\n\n    this.recordFormEvent(\"filled\", section.flowId, extra);\n    this.recordGleanFormEvent(\"formFilled\", section.flowId, extra);\n  }\n\n  recordFilledModified(section, fieldName) {\n    const extra = { field_name: fieldName };\n    this.recordFormEvent(\"filled_modified\", section.flowId, extra);\n    this.recordGleanFormEvent(\"formFilledModified\", section.flowId, extra);\n  }\n\n  recordFormSubmitted(section, record, _form) {\n    let extra = this.#initFormEventExtra(\"unavailable\");\n\n    if (record.guid !== null) {\n      // If the `guid` is not null, it means we're editing an existing record.\n      // In that case, all fields in the record are autofilled, and fields in\n      // `untouchedFields` are unmodified.\n      for (const [fieldName, value] of Object.entries(record.record)) {\n        if (record.untouchedFields?.includes(fieldName)) {\n          this.#setFormEventExtra(extra, fieldName, \"autofilled\");\n        } else if (value) {\n          this.#setFormEventExtra(extra, fieldName, \"user_filled\");\n        } else {\n          this.#setFormEventExtra(extra, fieldName, \"not_filled\");\n        }\n      }\n    } else {\n      Object.keys(record.record).forEach(fieldName =>\n        this.#setFormEventExtra(extra, fieldName, \"user_filled\")\n      );\n    }\n\n    this.recordFormEvent(\"submitted\", section.flowId, extra);\n    this.recordGleanFormEvent(\"formSubmitted\", section.flowId, extra);\n  }\n\n  recordFormCleared(section, fieldName) {\n    const extra = { field_name: fieldName };\n\n    // Note that when a form is cleared, we also record `filled_modified` events\n    // for all the fields that have been cleared.\n    this.recordFormEvent(\"cleared\", section.flowId, extra);\n    this.recordGleanFormEvent(\"formCleared\", section.flowId, extra);\n  }\n\n  recordFormEvent(method, flowId, extra) {\n    Services.telemetry.recordEvent(\n      this.EVENT_CATEGORY,\n      method,\n      this.EVENT_OBJECT_FORM_INTERACTION,\n      flowId,\n      extra\n    );\n  }\n\n  recordGleanFormEvent(_eventName, _flowId, _extra) {\n    throw new Error(\"Not implemented.\");\n  }\n\n  recordFormInteractionEvent(\n    method,\n    section,\n    { fieldName, profile, record, form } = {}\n  ) {\n    if (!this.EVENT_OBJECT_FORM_INTERACTION) {\n      return undefined;\n    }\n    switch (method) {\n      case \"detected\":\n        return this.recordFormDetected(section);\n      case \"popup_shown\":\n        return this.recordPopupShown(section, fieldName);\n      case \"filled\":\n        return this.recordFormFilled(section, profile);\n      case \"filled_modified\":\n        return this.recordFilledModified(section, fieldName);\n      case \"submitted\":\n        return this.recordFormSubmitted(section, record, form);\n      case \"cleared\":\n        return this.recordFormCleared(section, fieldName);\n    }\n    return undefined;\n  }\n\n  recordDoorhangerEvent(method, object, flowId) {\n    Services.telemetry.recordEvent(this.EVENT_CATEGORY, method, object, flowId);\n  }\n\n  recordManageEvent(method) {\n    Services.telemetry.recordEvent(this.EVENT_CATEGORY, method, \"manage\");\n  }\n\n  recordAutofillProfileCount(_count) {\n    throw new Error(\"Not implemented.\");\n  }\n\n  recordDetectedSectionCount() {\n    if (!this.SCALAR_DETECTED_SECTION_COUNT) {\n      return;\n    }\n\n    Services.telemetry.scalarAdd(this.SCALAR_DETECTED_SECTION_COUNT, 1);\n  }\n\n  recordSubmittedSectionCount(count) {\n    if (!this.SCALAR_SUBMITTED_SECTION_COUNT || !count) {\n      return;\n    }\n\n    Services.telemetry.scalarAdd(this.SCALAR_SUBMITTED_SECTION_COUNT, count);\n  }\n\n  recordNumberOfUse(records) {\n    let histogram = Services.telemetry.getKeyedHistogramById(\n      this.HISTOGRAM_PROFILE_NUM_USES\n    );\n    histogram.clear();\n\n    for (let record of records) {\n      histogram.add(this.HISTOGRAM_PROFILE_NUM_USES_KEY, record.timesUsed);\n    }\n  }\n}\n\nclass AddressTelemetry extends AutofillTelemetryBase {\n  EVENT_CATEGORY = \"address\";\n  EVENT_OBJECT_FORM_INTERACTION = \"address_form\";\n  EVENT_OBJECT_FORM_INTERACTION_EXT = \"address_form_ext\";\n\n  SCALAR_DETECTED_SECTION_COUNT =\n    \"formautofill.addresses.detected_sections_count\";\n  SCALAR_SUBMITTED_SECTION_COUNT =\n    \"formautofill.addresses.submitted_sections_count\";\n  SCALAR_AUTOFILL_PROFILE_COUNT =\n    \"formautofill.addresses.autofill_profiles_count\";\n\n  HISTOGRAM_PROFILE_NUM_USES = \"AUTOFILL_PROFILE_NUM_USES\";\n  HISTOGRAM_PROFILE_NUM_USES_KEY = \"address\";\n\n  // Fields that are record in `address_form` and `address_form_ext` telemetry\n  SUPPORTED_FIELDS = {\n    \"street-address\": \"street_address\",\n    \"address-line1\": \"address_line1\",\n    \"address-line2\": \"address_line2\",\n    \"address-line3\": \"address_line3\",\n    \"address-level1\": \"address_level1\",\n    \"address-level2\": \"address_level2\",\n    \"postal-code\": \"postal_code\",\n    country: \"country\",\n    name: \"name\",\n    \"given-name\": \"given_name\",\n    \"additional-name\": \"additional_name\",\n    \"family-name\": \"family_name\",\n    email: \"email\",\n    organization: \"organization\",\n    tel: \"tel\",\n  };\n\n  // Fields that are record in `address_form` event telemetry extra_keys\n  static SUPPORTED_FIELDS_IN_FORM = [\n    \"street_address\",\n    \"address_line1\",\n    \"address_line2\",\n    \"address_line3\",\n    \"address_level2\",\n    \"address_level1\",\n    \"postal_code\",\n    \"country\",\n  ];\n\n  // Fields that are record in `address_form_ext` event telemetry extra_keys\n  static SUPPORTED_FIELDS_IN_FORM_EXT = [\n    \"name\",\n    \"given_name\",\n    \"additional_name\",\n    \"family_name\",\n    \"email\",\n    \"organization\",\n    \"tel\",\n  ];\n\n  recordGleanFormEvent(_eventName, _flowId, _extra) {\n    // To be implemented when migrating the legacy event address.address_form to Glean\n  }\n\n  recordFormEvent(method, flowId, extra) {\n    let extExtra = {};\n    if ([\"detected\", \"filled\", \"submitted\"].includes(method)) {\n      for (const [key, value] of Object.entries(extra)) {\n        if (AddressTelemetry.SUPPORTED_FIELDS_IN_FORM_EXT.includes(key)) {\n          extExtra[key] = value;\n          delete extra[key];\n        }\n      }\n    }\n\n    Services.telemetry.recordEvent(\n      this.EVENT_CATEGORY,\n      method,\n      this.EVENT_OBJECT_FORM_INTERACTION,\n      flowId,\n      extra\n    );\n\n    if (Object.keys(extExtra).length) {\n      Services.telemetry.recordEvent(\n        this.EVENT_CATEGORY,\n        method,\n        this.EVENT_OBJECT_FORM_INTERACTION_EXT,\n        flowId,\n        extExtra\n      );\n    }\n  }\n\n  recordAutofillProfileCount(count) {\n    Services.telemetry.scalarSet(this.SCALAR_AUTOFILL_PROFILE_COUNT, count);\n  }\n}\n\nclass CreditCardTelemetry extends AutofillTelemetryBase {\n  EVENT_CATEGORY = \"creditcard\";\n  EVENT_OBJECT_FORM_INTERACTION = \"cc_form_v2\";\n\n  SCALAR_DETECTED_SECTION_COUNT =\n    \"formautofill.creditCards.detected_sections_count\";\n  SCALAR_SUBMITTED_SECTION_COUNT =\n    \"formautofill.creditCards.submitted_sections_count\";\n\n  HISTOGRAM_NUM_USES = \"CREDITCARD_NUM_USES\";\n  HISTOGRAM_PROFILE_NUM_USES = \"AUTOFILL_PROFILE_NUM_USES\";\n  HISTOGRAM_PROFILE_NUM_USES_KEY = \"credit_card\";\n\n  // Mapping of field name used in formautofill code to the field name\n  // used in the telemetry.\n  SUPPORTED_FIELDS = {\n    \"cc-name\": \"cc_name\",\n    \"cc-number\": \"cc_number\",\n    \"cc-type\": \"cc_type\",\n    \"cc-exp\": \"cc_exp\",\n    \"cc-exp-month\": \"cc_exp_month\",\n    \"cc-exp-year\": \"cc_exp_year\",\n  };\n\n  recordLegacyFormEvent(method, flowId, extra = null) {\n    Services.telemetry.recordEvent(\n      this.EVENT_CATEGORY,\n      method,\n      \"cc_form\",\n      flowId,\n      extra\n    );\n  }\n\n  recordGleanFormEvent(eventName, flowId, extra) {\n    extra.flow_id = flowId;\n    Glean.formautofillCreditcards[eventName].record(extra);\n  }\n\n  recordFormDetected(section) {\n    super.recordFormDetected(section);\n\n    let identified = new Set();\n    section.fieldDetails.forEach(detail => {\n      identified.add(detail.fieldName);\n    });\n    let extra = {\n      cc_name_found: identified.has(\"cc-name\") ? \"true\" : \"false\",\n      cc_number_found: identified.has(\"cc-number\") ? \"true\" : \"false\",\n      cc_exp_found:\n        identified.has(\"cc-exp\") ||\n        (identified.has(\"cc-exp-month\") && identified.has(\"cc-exp-year\"))\n          ? \"true\"\n          : \"false\",\n    };\n\n    this.recordLegacyFormEvent(\"detected\", section.flowId, extra);\n  }\n\n  recordPopupShown(section, fieldName) {\n    super.recordPopupShown(section, fieldName);\n\n    this.recordLegacyFormEvent(\"popup_shown\", section.flowId);\n  }\n\n  recordFormFilled(section, profile) {\n    super.recordFormFilled(section, profile);\n    // Calculate values for telemetry\n    let extra = {\n      cc_name: \"unavailable\",\n      cc_number: \"unavailable\",\n      cc_exp: \"unavailable\",\n    };\n\n    for (let fieldDetail of section.fieldDetails) {\n      let element = fieldDetail.element;\n      let state = profile[fieldDetail.fieldName] ? \"filled\" : \"not_filled\";\n      if (\n        section.handler.getFilledStateByElement(element) ==\n          FIELD_STATES.NORMAL &&\n        (HTMLSelectElement.isInstance(element) ||\n          (HTMLInputElement.isInstance(element) && element.value.length))\n      ) {\n        state = \"user_filled\";\n      }\n      switch (fieldDetail.fieldName) {\n        case \"cc-name\":\n          extra.cc_name = state;\n          break;\n        case \"cc-number\":\n          extra.cc_number = state;\n          break;\n        case \"cc-exp\":\n        case \"cc-exp-month\":\n        case \"cc-exp-year\":\n          extra.cc_exp = state;\n          break;\n      }\n    }\n\n    this.recordLegacyFormEvent(\"filled\", section.flowId, extra);\n  }\n\n  recordFilledModified(section, fieldName) {\n    super.recordFilledModified(section, fieldName);\n\n    let extra = { field_name: fieldName };\n    this.recordLegacyFormEvent(\"filled_modified\", section.flowId, extra);\n  }\n\n  /**\n   * Called when a credit card form is submitted\n   *\n   * @param {object} section Section that produces this record\n   * @param {object} record Credit card record filled in the form.\n   * @param {Array<HTMLForm>} form Form that contains the section\n   */\n  recordFormSubmitted(section, record, form) {\n    super.recordFormSubmitted(section, record, form);\n\n    // For legacy cc_form event telemetry\n    let extra = {\n      fields_not_auto: \"0\",\n      fields_auto: \"0\",\n      fields_modified: \"0\",\n    };\n\n    if (record.guid !== null) {\n      let totalCount = form.elements.length;\n      let autofilledCount = Object.keys(record.record).length;\n      let unmodifiedCount = record.untouchedFields.length;\n\n      extra.fields_not_auto = (totalCount - autofilledCount).toString();\n      extra.fields_auto = autofilledCount.toString();\n      extra.fields_modified = (autofilledCount - unmodifiedCount).toString();\n    } else {\n      // If the `guid` is null, we're filling a new form.\n      // In that case, all not-null fields are manually filled.\n      extra.fields_not_auto = Array.from(form.elements)\n        .filter(element => !!element.value?.trim().length)\n        .length.toString();\n    }\n\n    this.recordLegacyFormEvent(\"submitted\", section.flowId, extra);\n  }\n\n  recordNumberOfUse(records) {\n    super.recordNumberOfUse(records);\n\n    if (!this.HISTOGRAM_NUM_USES) {\n      return;\n    }\n\n    let histogram = Services.telemetry.getHistogramById(\n      this.HISTOGRAM_NUM_USES\n    );\n    histogram.clear();\n\n    for (let record of records) {\n      histogram.add(record.timesUsed);\n    }\n  }\n\n  recordAutofillProfileCount(count) {\n    Glean.formautofillCreditcards.autofillProfilesCount.set(count);\n  }\n}\n\nclass AutofillTelemetry {\n  static #creditCardTelemetry = new CreditCardTelemetry();\n  static #addressTelemetry = new AddressTelemetry();\n\n  // const for `type` parameter used in the utility functions\n  static ADDRESS = \"address\";\n  static CREDIT_CARD = \"creditcard\";\n\n  static #getTelemetryBySection(section) {\n    return section instanceof resource_gre_modules_shared_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillCreditCardSection\n      ? this.#creditCardTelemetry\n      : this.#addressTelemetry;\n  }\n\n  static #getTelemetryByType(type) {\n    return type == AutofillTelemetry.CREDIT_CARD\n      ? this.#creditCardTelemetry\n      : this.#addressTelemetry;\n  }\n\n  /**\n   * Utility functions for `doorhanger` event (defined in Events.yaml)\n   *\n   * Category: address or creditcard\n   * Event name: doorhanger\n   */\n  static recordDoorhangerShown(type, object, flowId) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordDoorhangerEvent(\"show\", object, flowId);\n  }\n\n  static recordDoorhangerClicked(type, method, object, flowId) {\n    const telemetry = this.#getTelemetryByType(type);\n\n    // We don't have `create` method in telemetry, we treat `create` as `save`\n    switch (method) {\n      case \"create\":\n        method = \"save\";\n        break;\n      case \"open-pref\":\n        method = \"pref\";\n        break;\n      case \"learn-more\":\n        method = \"learn_more\";\n        break;\n    }\n\n    telemetry.recordDoorhangerEvent(method, object, flowId);\n  }\n\n  /**\n   * Utility functions for form event (defined in Events.yaml)\n   *\n   * Category: address or creditcard\n   * Event name: cc_form, cc_form_v2, or address_form\n   */\n\n  static recordFormInteractionEvent(\n    method,\n    section,\n    { fieldName, profile, record, form } = {}\n  ) {\n    const telemetry = this.#getTelemetryBySection(section);\n    telemetry.recordFormInteractionEvent(method, section, {\n      fieldName,\n      profile,\n      record,\n      form,\n    });\n  }\n\n  /**\n   * Utility functions for submitted section count scalar (defined in Scalars.yaml)\n   *\n   * Category: formautofill.creditCards or formautofill.addresses\n   * Scalar name: submitted_sections_count\n   */\n  static recordDetectedSectionCount(section) {\n    const telemetry = this.#getTelemetryBySection(section);\n    telemetry.recordDetectedSectionCount();\n  }\n\n  static recordSubmittedSectionCount(type, count) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordSubmittedSectionCount(count);\n  }\n\n  static recordManageEvent(type, method) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordManageEvent(method);\n  }\n\n  static recordAutofillProfileCount(type, count) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordAutofillProfileCount(count);\n  }\n\n  /**\n   * Utility functions for address/credit card number of use\n   */\n  static recordNumberOfUse(type, records) {\n    const telemetry = this.#getTelemetryByType(type);\n    telemetry.recordNumberOfUse(records);\n  }\n\n  static recordFormSubmissionHeuristicCount(label) {\n    Glean.formautofill.formSubmissionHeuristic[label].add(1);\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs":
/*!***************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IOSAppConstants\": () => (/* binding */ IOSAppConstants),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst IOS_DEFAULT_PREFERENCES = {\n  \"extensions.formautofill.creditCards.heuristics.mode\": 1,\n  \"extensions.formautofill.creditCards.heuristics.fathom.confidenceThreshold\": 0.5,\n  \"extensions.formautofill.creditCards.heuristics.fathom.highConfidenceThreshold\": 0.95,\n  \"extensions.formautofill.creditCards.heuristics.fathom.testConfidence\": 0,\n  \"extensions.formautofill.creditCards.heuristics.fathom.types\":\n    \"cc-number,cc-name\",\n  \"extensions.formautofill.addresses.capture.requiredFields\":\n    \"street-address,postal-code,address-level1,address-level2\",\n  \"extensions.formautofill.loglevel\": \"Warn\",\n  \"extensions.formautofill.addresses.supported\": \"off\",\n  \"extensions.formautofill.creditCards.supported\": \"detect\",\n  \"browser.search.region\": \"US\",\n  \"extensions.formautofill.creditCards.supportedCountries\": \"US,CA,GB,FR,DE\",\n  \"extensions.formautofill.addresses.enabled\": true,\n  \"extensions.formautofill.addresses.experiments.enabled\": true,\n  \"extensions.formautofill.addresses.capture.enabled\": false,\n  \"extensions.formautofill.addresses.supportedCountries\": \"\",\n  \"extensions.formautofill.creditCards.enabled\": true,\n  \"extensions.formautofill.reauth.enabled\": true,\n  \"extensions.formautofill.creditCards.hideui\": false,\n  \"extensions.formautofill.supportRTL\": false,\n  \"extensions.formautofill.creditCards.ignoreAutocompleteOff\": true,\n  \"extensions.formautofill.addresses.ignoreAutocompleteOff\": true,\n  \"extensions.formautofill.heuristics.enabled\": true,\n  \"extensions.formautofill.section.enabled\": true,\n  \"extensions.formautofill.heuristics.captureOnFormRemoval\": false,\n  \"extensions.formautofill.heuristics.captureOnPageNavigation\": false,\n  \"extensions.formautofill.focusOnAutofill\": false,\n  \"extensions.formautofill.test.ignoreVisibilityCheck\": false,\n};\n\n// Used Mimic the behavior of .getAutocompleteInfo()\n// List from: https://searchfox.org/mozilla-central/source/dom/base/AutocompleteFieldList.h#89-149\n// Also found here: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete\nconst VALID_AUTOCOMPLETE_FIELDS = [\n  \"off\",\n  \"on\",\n  \"name\",\n  \"honorific-prefix\",\n  \"given-name\",\n  \"additional-name\",\n  \"family-name\",\n  \"honorific-suffix\",\n  \"nickname\",\n  \"email\",\n  \"username\",\n  \"new-password\",\n  \"current-password\",\n  \"one-time-code\",\n  \"organization-title\",\n  \"organization\",\n  \"street-address\",\n  \"address-line1\",\n  \"address-line2\",\n  \"address-line3\",\n  \"address-level4\",\n  \"address-level3\",\n  \"address-level2\",\n  \"address-level1\",\n  \"country\",\n  \"country-name\",\n  \"postal-code\",\n  \"cc-name\",\n  \"cc-given-name\",\n  \"cc-additional-name\",\n  \"cc-family-name\",\n  \"cc-number\",\n  \"cc-exp\",\n  \"cc-exp-month\",\n  \"cc-exp-year\",\n  \"cc-csc\",\n  \"cc-type\",\n  \"transaction-currency\",\n  \"transaction-amount\",\n  \"language\",\n  \"bday\",\n  \"bday-day\",\n  \"bday-month\",\n  \"bday-year\",\n  \"sex\",\n  \"tel\",\n  \"tel-country-code\",\n  \"tel-national\",\n  \"tel-area-code\",\n  \"tel-local\",\n  \"tel-extension\",\n  \"impp\",\n  \"url\",\n  \"photo\",\n];\n\nconst IOSAppConstants = Object.freeze({\n  platform: \"ios\",\n  prefs: IOS_DEFAULT_PREFERENCES,\n  validAutocompleteFields: VALID_AUTOCOMPLETE_FIELDS,\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IOSAppConstants);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs":
/*!****************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CreditCard\": () => (/* binding */ CreditCard),\n/* harmony export */   \"NETWORK_NAMES\": () => (/* binding */ NETWORK_NAMES)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// The list of known and supported credit card network ids (\"types\")\n// This list mirrors the networks from dom/payments/BasicCardPayment.cpp\n// and is defined by https://www.w3.org/Payments/card-network-ids\nconst SUPPORTED_NETWORKS = Object.freeze([\n  \"amex\",\n  \"cartebancaire\",\n  \"diners\",\n  \"discover\",\n  \"jcb\",\n  \"mastercard\",\n  \"mir\",\n  \"unionpay\",\n  \"visa\",\n]);\n\n// This lists stores lower cased variations of popular credit card network\n// names for matching against strings.\nconst NETWORK_NAMES = {\n  \"american express\": \"amex\",\n  \"master card\": \"mastercard\",\n  \"union pay\": \"unionpay\",\n};\n\n// Based on https://en.wikipedia.org/wiki/Payment_card_number\n//\n// Notice:\n//   - CarteBancaire (`4035`, `4360`) is now recognized as Visa.\n//   - UnionPay (`63--`) is now recognized as Discover.\n// This means that the order matters.\n// First we'll try to match more specific card,\n// and if that doesn't match we'll test against the more generic range.\nconst CREDIT_CARD_IIN = [\n  { type: \"amex\", start: 34, end: 34, len: 15 },\n  { type: \"amex\", start: 37, end: 37, len: 15 },\n  { type: \"cartebancaire\", start: 4035, end: 4035, len: 16 },\n  { type: \"cartebancaire\", start: 4360, end: 4360, len: 16 },\n  // We diverge from Wikipedia here, because Diners card\n  // support length of 14-19.\n  { type: \"diners\", start: 300, end: 305, len: [14, 19] },\n  { type: \"diners\", start: 3095, end: 3095, len: [14, 19] },\n  { type: \"diners\", start: 36, end: 36, len: [14, 19] },\n  { type: \"diners\", start: 38, end: 39, len: [14, 19] },\n  { type: \"discover\", start: 6011, end: 6011, len: [16, 19] },\n  { type: \"discover\", start: 622126, end: 622925, len: [16, 19] },\n  { type: \"discover\", start: 624000, end: 626999, len: [16, 19] },\n  { type: \"discover\", start: 628200, end: 628899, len: [16, 19] },\n  { type: \"discover\", start: 64, end: 65, len: [16, 19] },\n  { type: \"jcb\", start: 3528, end: 3589, len: [16, 19] },\n  { type: \"mastercard\", start: 2221, end: 2720, len: 16 },\n  { type: \"mastercard\", start: 51, end: 55, len: 16 },\n  { type: \"mir\", start: 2200, end: 2204, len: 16 },\n  { type: \"unionpay\", start: 62, end: 62, len: [16, 19] },\n  { type: \"unionpay\", start: 81, end: 81, len: [16, 19] },\n  { type: \"visa\", start: 4, end: 4, len: 16 },\n].sort((a, b) => b.start - a.start);\n\nclass CreditCard {\n  /**\n   * A CreditCard object represents a credit card, with\n   * number, name, expiration, network, and CCV.\n   * The number is the only required information when creating\n   * an object, all other members are optional. The number\n   * is validated during construction and will throw if invalid.\n   *\n   * @param {string} name, optional\n   * @param {string} number\n   * @param {string} expirationString, optional\n   * @param {string|number} expirationMonth, optional\n   * @param {string|number} expirationYear, optional\n   * @param {string} network, optional\n   * @param {string|number} ccv, optional\n   * @param {string} encryptedNumber, optional\n   * @throws if number is an invalid credit card number\n   */\n  constructor({\n    name,\n    number,\n    expirationString,\n    expirationMonth,\n    expirationYear,\n    network,\n    ccv,\n    encryptedNumber,\n  }) {\n    this._name = name;\n    this._unmodifiedNumber = number;\n    this._encryptedNumber = encryptedNumber;\n    this._ccv = ccv;\n    this.number = number;\n    let { month, year } = CreditCard.normalizeExpiration({\n      expirationString,\n      expirationMonth,\n      expirationYear,\n    });\n    this._expirationMonth = month;\n    this._expirationYear = year;\n    this.network = network;\n  }\n\n  set name(value) {\n    this._name = value;\n  }\n\n  set expirationMonth(value) {\n    if (typeof value == \"undefined\") {\n      this._expirationMonth = undefined;\n      return;\n    }\n    this._expirationMonth = CreditCard.normalizeExpirationMonth(value);\n  }\n\n  get expirationMonth() {\n    return this._expirationMonth;\n  }\n\n  set expirationYear(value) {\n    if (typeof value == \"undefined\") {\n      this._expirationYear = undefined;\n      return;\n    }\n    this._expirationYear = CreditCard.normalizeExpirationYear(value);\n  }\n\n  get expirationYear() {\n    return this._expirationYear;\n  }\n\n  set expirationString(value) {\n    let { month, year } = CreditCard.parseExpirationString(value);\n    this.expirationMonth = month;\n    this.expirationYear = year;\n  }\n\n  set ccv(value) {\n    this._ccv = value;\n  }\n\n  get number() {\n    return this._number;\n  }\n\n  /**\n   * Sets the number member of a CreditCard object. If the number\n   * is not valid according to the Luhn algorithm then the member\n   * will get set to the empty string before throwing an exception.\n   *\n   * @param {string} value\n   * @throws if the value is an invalid credit card number\n   */\n  set number(value) {\n    if (value) {\n      let normalizedNumber = CreditCard.normalizeCardNumber(value);\n      // Based on the information on wiki[1], the shortest valid length should be\n      // 12 digits (Maestro).\n      // [1] https://en.wikipedia.org/wiki/Payment_card_number\n      normalizedNumber = normalizedNumber.match(/^\\d{12,}$/)\n        ? normalizedNumber\n        : \"\";\n      this._number = normalizedNumber;\n    } else {\n      this._number = \"\";\n    }\n\n    if (value && !this.isValidNumber()) {\n      this._number = \"\";\n      throw new Error(\"Invalid credit card number\");\n    }\n  }\n\n  get network() {\n    return this._network;\n  }\n\n  set network(value) {\n    this._network = value || undefined;\n  }\n\n  // Implements the Luhn checksum algorithm as described at\n  // http://wikipedia.org/wiki/Luhn_algorithm\n  // Number digit lengths vary with network, but should fall within 12-19 range. [2]\n  // More details at https://en.wikipedia.org/wiki/Payment_card_number\n  isValidNumber() {\n    if (!this._number) {\n      return false;\n    }\n\n    // Remove dashes and whitespace\n    const number = CreditCard.normalizeCardNumber(this._number);\n\n    const len = number.length;\n    if (len < 12 || len > 19) {\n      return false;\n    }\n\n    if (!/^\\d+$/.test(number)) {\n      return false;\n    }\n\n    let total = 0;\n    for (let i = 0; i < len; i++) {\n      let ch = parseInt(number[len - i - 1], 10);\n      if (i % 2 == 1) {\n        // Double it, add digits together if > 10\n        ch *= 2;\n        if (ch > 9) {\n          ch -= 9;\n        }\n      }\n      total += ch;\n    }\n    return total % 10 == 0;\n  }\n\n  /**\n   * Normalizes a credit card number.\n   * @param {string} number\n   * @return {string | null}\n   * @memberof CreditCard\n   */\n  static normalizeCardNumber(number) {\n    if (!number) {\n      return null;\n    }\n    return number.replace(/[\\-\\s]/g, \"\");\n  }\n\n  /**\n   * Attempts to match the number against known network identifiers.\n   *\n   * @param {string} ccNumber Credit card number with no spaces or special characters in it.\n   *\n   * @returns {string|null}\n   */\n  static getType(ccNumber) {\n    if (!ccNumber) {\n      return null;\n    }\n\n    for (let i = 0; i < CREDIT_CARD_IIN.length; i++) {\n      const range = CREDIT_CARD_IIN[i];\n      if (typeof range.len == \"number\") {\n        if (range.len != ccNumber.length) {\n          continue;\n        }\n      } else if (\n        ccNumber.length < range.len[0] ||\n        ccNumber.length > range.len[1]\n      ) {\n        continue;\n      }\n\n      const prefixLength = Math.floor(Math.log10(range.start)) + 1;\n      const prefix = parseInt(ccNumber.substring(0, prefixLength), 10);\n      if (prefix >= range.start && prefix <= range.end) {\n        return range.type;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Attempts to retrieve a card network identifier based\n   * on a name.\n   *\n   * @param {string|undefined|null} name\n   *\n   * @returns {string|null}\n   */\n  static getNetworkFromName(name) {\n    if (!name) {\n      return null;\n    }\n    let lcName = name.trim().toLowerCase().normalize(\"NFKC\");\n    if (SUPPORTED_NETWORKS.includes(lcName)) {\n      return lcName;\n    }\n    for (let term in NETWORK_NAMES) {\n      if (lcName.includes(term)) {\n        return NETWORK_NAMES[term];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the card number is valid and the\n   * expiration date has not passed. Otherwise false.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    if (!this.isValidNumber()) {\n      return false;\n    }\n\n    let currentDate = new Date();\n    let currentYear = currentDate.getFullYear();\n    if (this._expirationYear > currentYear) {\n      return true;\n    }\n\n    // getMonth is 0-based, so add 1 because credit cards are 1-based\n    let currentMonth = currentDate.getMonth() + 1;\n    return (\n      this._expirationYear == currentYear &&\n      this._expirationMonth >= currentMonth\n    );\n  }\n\n  get maskedNumber() {\n    return CreditCard.getMaskedNumber(this._number);\n  }\n\n  get longMaskedNumber() {\n    return CreditCard.getLongMaskedNumber(this._number);\n  }\n\n  /**\n   * Get credit card display label. It should display masked numbers, the\n   * cardholder's name, and the expiration date, separated by a commas.\n   * In addition, the card type is provided in the accessibility label.\n   */\n  static getLabelInfo({ number, name, month, year, type }) {\n    let formatSelector = [\"number\"];\n    if (name) {\n      formatSelector.push(\"name\");\n    }\n    if (month && year) {\n      formatSelector.push(\"expiration\");\n    }\n    let stringId = `credit-card-label-${formatSelector.join(\"-\")}-2`;\n    return {\n      id: stringId,\n      args: {\n        number: CreditCard.getMaskedNumber(number),\n        name,\n        month: month?.toString(),\n        year: year?.toString(),\n        type,\n      },\n    };\n  }\n\n  /**\n   *\n   * Please use getLabelInfo above, as it allows for localization.\n   * @deprecated\n   */\n  static getLabel({ number, name }) {\n    let parts = [];\n\n    if (number) {\n      parts.push(CreditCard.getMaskedNumber(number));\n    }\n    if (name) {\n      parts.push(name);\n    }\n    return parts.join(\", \");\n  }\n\n  static normalizeExpirationMonth(month) {\n    month = parseInt(month, 10);\n    if (isNaN(month) || month < 1 || month > 12) {\n      return undefined;\n    }\n    return month;\n  }\n\n  static normalizeExpirationYear(year) {\n    year = parseInt(year, 10);\n    if (isNaN(year) || year < 0) {\n      return undefined;\n    }\n    if (year < 100) {\n      year += 2000;\n    }\n    return year;\n  }\n\n  static parseExpirationString(expirationString) {\n    let rules = [\n      {\n        regex: /(?:^|\\D)(\\d{2})(\\d{2})(?!\\d)/,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{4})[-/](\\d{1,2})(?!\\d)/,\n        yearIndex: 0,\n        monthIndex: 1,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{1,2})[-/](\\d{4})(?!\\d)/,\n        yearIndex: 1,\n        monthIndex: 0,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{1,2})[-/](\\d{1,2})(?!\\d)/,\n      },\n      {\n        regex: /(?:^|\\D)(\\d{2})(\\d{2})(?!\\d)/,\n      },\n    ];\n\n    expirationString = expirationString.replaceAll(\" \", \"\");\n    for (let rule of rules) {\n      let result = rule.regex.exec(expirationString);\n      if (!result) {\n        continue;\n      }\n\n      let year, month;\n      const parsedResults = [parseInt(result[1], 10), parseInt(result[2], 10)];\n      if (!rule.yearIndex || !rule.monthIndex) {\n        month = parsedResults[0];\n        if (month > 12) {\n          year = parsedResults[0];\n          month = parsedResults[1];\n        } else {\n          year = parsedResults[1];\n        }\n      } else {\n        year = parsedResults[rule.yearIndex];\n        month = parsedResults[rule.monthIndex];\n      }\n\n      if (month >= 1 && month <= 12 && (year < 100 || year > 2000)) {\n        return { month, year };\n      }\n    }\n    return { month: undefined, year: undefined };\n  }\n\n  static normalizeExpiration({\n    expirationString,\n    expirationMonth,\n    expirationYear,\n  }) {\n    // Only prefer the string version if missing one or both parsed formats.\n    let parsedExpiration = {};\n    if (expirationString && (!expirationMonth || !expirationYear)) {\n      parsedExpiration = CreditCard.parseExpirationString(expirationString);\n    }\n    return {\n      month: CreditCard.normalizeExpirationMonth(\n        parsedExpiration.month || expirationMonth\n      ),\n      year: CreditCard.normalizeExpirationYear(\n        parsedExpiration.year || expirationYear\n      ),\n    };\n  }\n\n  static formatMaskedNumber(maskedNumber) {\n    return \"*\".repeat(4) + maskedNumber.substr(-4);\n  }\n\n  static getMaskedNumber(number) {\n    return \"*\".repeat(4) + \" \" + number.substr(-4);\n  }\n\n  static getLongMaskedNumber(number) {\n    return \"*\".repeat(number.length - 4) + number.substr(-4);\n  }\n\n  static getCreditCardLogo(network) {\n    const PATH = \"chrome://formautofill/content/\";\n    const THIRD_PARTY_PATH = PATH + \"third-party/\";\n    switch (network) {\n      case \"amex\":\n        return THIRD_PARTY_PATH + \"cc-logo-amex.png\";\n      case \"cartebancaire\":\n        return THIRD_PARTY_PATH + \"cc-logo-cartebancaire.png\";\n      case \"diners\":\n        return THIRD_PARTY_PATH + \"cc-logo-diners.svg\";\n      case \"discover\":\n        return THIRD_PARTY_PATH + \"cc-logo-discover.png\";\n      case \"jcb\":\n        return THIRD_PARTY_PATH + \"cc-logo-jcb.svg\";\n      case \"mastercard\":\n        return THIRD_PARTY_PATH + \"cc-logo-mastercard.svg\";\n      case \"mir\":\n        return THIRD_PARTY_PATH + \"cc-logo-mir.svg\";\n      case \"unionpay\":\n        return THIRD_PARTY_PATH + \"cc-logo-unionpay.svg\";\n      case \"visa\":\n        return THIRD_PARTY_PATH + \"cc-logo-visa.svg\";\n      default:\n        return PATH + \"icon-credit-card-generic.svg\";\n    }\n  }\n\n  /*\n   * Validates the number according to the Luhn algorithm. This\n   * method does not throw an exception if the number is invalid.\n   */\n  static isValidNumber(number) {\n    try {\n      new CreditCard({ number });\n    } catch (ex) {\n      return false;\n    }\n    return true;\n  }\n\n  static isValidNetwork(network) {\n    return SUPPORTED_NETWORKS.includes(network);\n  }\n\n  static getSupportedNetworks() {\n    return SUPPORTED_NETWORKS;\n  }\n\n  /**\n   * Localised names for supported networks are available in\n   * `browser/preferences/formAutofill.ftl`.\n   */\n  static getNetworkL10nId(network) {\n    return this.isValidNetwork(network)\n      ? `autofill-card-network-${network}`\n      : null;\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CreditCardRecord\": () => (/* binding */ CreditCardRecord)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/CreditCard.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\");\n/* eslint-disable no-useless-concat */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n/**\n * The CreditCardRecord class serves to handle and normalize internal credit card records.\n * Unlike the CreditCard class, which represents actual card data, CreditCardRecord is used\n * for processing and consistent data representation.\n */\nclass CreditCardRecord {\n  static normalizeFields(creditCard) {\n    this.#normalizeCCNameFields(creditCard);\n    this.#normalizeCCNumberFields(creditCard);\n    this.#normalizeCCExpirationDateFields(creditCard);\n    this.#normalizeCCTypeFields(creditCard);\n  }\n\n  static #normalizeCCNameFields(creditCard) {\n    if (!creditCard[\"cc-name\"]) {\n      creditCard[\"cc-name\"] = resource_gre_modules_shared_FormAutofillNameUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillNameUtils.joinNameParts({\n        given: creditCard[\"cc-given-name\"] ?? \"\",\n        middle: creditCard[\"cc-additional-name\"] ?? \"\",\n        family: creditCard[\"cc-family-name\"] ?? \"\",\n      });\n    }\n\n    delete creditCard[\"cc-given-name\"];\n    delete creditCard[\"cc-additional-name\"];\n    delete creditCard[\"cc-family-name\"];\n  }\n\n  static #normalizeCCNumberFields(creditCard) {\n    if (!(\"cc-number\" in creditCard)) {\n      return;\n    }\n\n    if (!resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard.isValidNumber(creditCard[\"cc-number\"])) {\n      delete creditCard[\"cc-number\"];\n      return;\n    }\n\n    const card = new resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard({ number: creditCard[\"cc-number\"] });\n    creditCard[\"cc-number\"] = card.number;\n  }\n\n  static #normalizeCCExpirationDateFields(creditCard) {\n    let normalizedExpiration = resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard.normalizeExpiration({\n      expirationMonth: creditCard[\"cc-exp-month\"],\n      expirationYear: creditCard[\"cc-exp-year\"],\n      expirationString: creditCard[\"cc-exp\"],\n    });\n\n    creditCard[\"cc-exp-month\"] = normalizedExpiration.month ?? \"\";\n    creditCard[\"cc-exp-year\"] = normalizedExpiration.year ?? \"\";\n    delete creditCard[\"cc-exp\"];\n  }\n\n  static #normalizeCCTypeFields(creditCard) {\n    // Let's overwrite the credit card type with auto-detect algorithm\n    creditCard[\"cc-type\"] = resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.CreditCard.getType(creditCard[\"cc-number\"]) ?? \"\";\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs":
/*!***********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CreditCardRulesets\": () => (/* binding */ CreditCardRulesets),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/third_party/fathom/fathom.mjs */ \"./firefox-ios/Client/Assets/CC_Script/fathom.mjs\");\n/* harmony import */ var resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/XPCOMUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resource://gre/modules/CreditCard.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\");\n/* harmony import */ var resource_gre_modules_FormLikeFactory_sys_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! resource://gre/modules/FormLikeFactory.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_LabelUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! resource://gre/modules/shared/LabelUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * Fathom ML model for identifying the fields of credit-card forms\n *\n * This is developed out-of-tree at https://github.com/mozilla-services/fathom-\n * form-autofill, where there is also over a GB of training, validation, and\n * testing data. To make changes, do your edits there (whether adding new\n * training pages, adding new rules, or both), retrain and evaluate as\n * documented at https://mozilla.github.io/fathom/training.html, paste the\n * coefficients emitted by the trainer into the ruleset, and finally copy the\n * ruleset's \"CODE TO COPY INTO PRODUCTION\" section to this file's \"CODE FROM\n * TRAINING REPOSITORY\" section.\n */\n\n/**\n * CODE UNIQUE TO PRODUCTION--NOT IN THE TRAINING REPOSITORY:\n */\n\n\n\n\n\n\n\n\n\n/**\n * Callthrough abstraction to allow .getAutocompleteInfo() to be mocked out\n * during training\n *\n * @param {Element} element DOM element to get info about\n * @returns {object} Page-author-provided autocomplete metadata\n */\nfunction getAutocompleteInfo(element) {\n  return element.getAutocompleteInfo();\n}\n\n/**\n * @param {string} selector A CSS selector that prunes away ineligible elements\n * @returns {Lhs} An LHS yielding the element the user has clicked or, if\n *  pruned, none\n */\nfunction queriedOrClickedElements(selector) {\n  return (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.element)(selector);\n}\n\n/**\n * START OF CODE PASTED FROM TRAINING REPOSITORY\n */\n\nvar FathomHeuristicsRegExp = {\n  RULES: {\n    \"cc-name\": undefined,\n    \"cc-number\": undefined,\n    \"cc-exp-month\": undefined,\n    \"cc-exp-year\": undefined,\n    \"cc-exp\": undefined,\n    \"cc-type\": undefined,\n  },\n\n  RULE_SETS: [\n    {\n      /* eslint-disable */\n      // Let us keep our consistent wrapping.\n      \"cc-name\":\n        // Firefox-specific rules\n        \"account.*holder.*name\" +\n        \"|^(credit[-\\\\s]?card|card).*name\" +\n        // de-DE\n        \"|^(kredit)?(karten|konto)inhaber\" +\n        \"|^(name).*karte\" +\n        // fr-FR\n        \"|nom.*(titulaire|détenteur)\" +\n        \"|(titulaire|détenteur).*(carte)\" +\n        // it-IT\n        \"|titolare.*carta\" +\n        // pl-PL\n        \"|posiadacz.*karty\" +\n        // es-ES\n        \"|nombre.*(titular|tarjeta)\" +\n        // nl-NL\n        \"|naam.*op.*kaart\" +\n        // Rules from Bitwarden\n        \"|cc-?name\" +\n        \"|card-?name\" +\n        \"|cardholder-?name\" +\n        \"|(^nom$)\" +\n        // Rules are from Chromium source codes\n        \"|card.?(?:holder|owner)|name.*(\\\\b)?on(\\\\b)?.*card\" +\n        \"|(?:card|cc).?name|cc.?full.?name\" +\n        \"|(?:card|cc).?owner\" +\n        \"|nom.*carte\" + // fr-FR\n        \"|nome.*cart\" + // it-IT\n        \"|名前\" + // ja-JP\n        \"|Имя.*карты\" + // ru\n        \"|信用卡开户名|开户名|持卡人姓名\" + // zh-CN\n        \"|持卡人姓名\", // zh-TW\n\n      \"cc-number\":\n        // Firefox-specific rules\n        // de-DE\n        \"(cc|kk)nr\" +\n        \"|(kredit)?(karten)(nummer|nr)\" +\n        // it-IT\n        \"|numero.*carta\" +\n        // fr-FR\n        \"|(numero|número|numéro).*(carte)\" +\n        // pl-PL\n        \"|numer.*karty\" +\n        // es-ES\n        \"|(número|numero).*tarjeta\" +\n        // nl-NL\n        \"|kaartnummer\" +\n        // Rules from Bitwarden\n        \"|cc-?number\" +\n        \"|cc-?num\" +\n        \"|card-?number\" +\n        \"|card-?num\" +\n        \"|cc-?no\" +\n        \"|card-?no\" +\n        \"|numero-?carte\" +\n        \"|num-?carte\" +\n        \"|cb-?num\" +\n        // Rules are from Chromium source codes\n        \"|(add)?(?:card|cc|acct).?(?:number|#|no|num)\" +\n        \"|カード番号\" + // ja-JP\n        \"|Номер.*карты\" + // ru\n        \"|信用卡号|信用卡号码\" + // zh-CN\n        \"|信用卡卡號\" + // zh-TW\n        \"|카드\", // ko-KR\n\n      \"cc-exp\":\n        // Firefox-specific rules\n        \"mm\\\\s*(\\/|\\\\|-)\\\\s*(yy|jj|aa)\" +\n        \"|(month|mois)\\\\s*(\\/|\\\\|-|et)\\\\s*(year|année)\" +\n        // de-DE\n        // fr-FR\n        // Rules from Bitwarden\n        \"|(^cc-?exp$)\" +\n        \"|(^card-?exp$)\" +\n        \"|(^cc-?expiration$)\" +\n        \"|(^card-?expiration$)\" +\n        \"|(^cc-?ex$)\" +\n        \"|(^card-?ex$)\" +\n        \"|(^card-?expire$)\" +\n        \"|(^card-?expiry$)\" +\n        \"|(^validite$)\" +\n        \"|(^expiration$)\" +\n        \"|(^expiry$)\" +\n        \"|mm-?yy\" +\n        \"|mm-?yyyy\" +\n        \"|yy-?mm\" +\n        \"|yyyy-?mm\" +\n        \"|expiration-?date\" +\n        \"|payment-?card-?expiration\" +\n        \"|(^payment-?cc-?date$)\" +\n        // Rules are from Chromium source codes\n        \"|expir|exp.*date|^expfield$\" +\n        \"|ablaufdatum|gueltig|gültig\" + // de-DE\n        \"|fecha\" + // es\n        \"|date.*exp\" + // fr-FR\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\", // ru\n\n      \"cc-exp-month\":\n        // Firefox-specific rules\n        \"(cc|kk)month\" + // de-DE\n        // Rules from Bitwarden\n        \"|(^exp-?month$)\" +\n        \"|(^cc-?exp-?month$)\" +\n        \"|(^cc-?month$)\" +\n        \"|(^card-?month$)\" +\n        \"|(^cc-?mo$)\" +\n        \"|(^card-?mo$)\" +\n        \"|(^exp-?mo$)\" +\n        \"|(^card-?exp-?mo$)\" +\n        \"|(^cc-?exp-?mo$)\" +\n        \"|(^card-?expiration-?month$)\" +\n        \"|(^expiration-?month$)\" +\n        \"|(^cc-?mm$)\" +\n        \"|(^cc-?m$)\" +\n        \"|(^card-?mm$)\" +\n        \"|(^card-?m$)\" +\n        \"|(^card-?exp-?mm$)\" +\n        \"|(^cc-?exp-?mm$)\" +\n        \"|(^exp-?mm$)\" +\n        \"|(^exp-?m$)\" +\n        \"|(^expire-?month$)\" +\n        \"|(^expire-?mo$)\" +\n        \"|(^expiry-?month$)\" +\n        \"|(^expiry-?mo$)\" +\n        \"|(^card-?expire-?month$)\" +\n        \"|(^card-?expire-?mo$)\" +\n        \"|(^card-?expiry-?month$)\" +\n        \"|(^card-?expiry-?mo$)\" +\n        \"|(^mois-?validite$)\" +\n        \"|(^mois-?expiration$)\" +\n        \"|(^m-?validite$)\" +\n        \"|(^m-?expiration$)\" +\n        \"|(^expiry-?date-?field-?month$)\" +\n        \"|(^expiration-?date-?month$)\" +\n        \"|(^expiration-?date-?mm$)\" +\n        \"|(^exp-?mon$)\" +\n        \"|(^validity-?mo$)\" +\n        \"|(^exp-?date-?mo$)\" +\n        \"|(^cb-?date-?mois$)\" +\n        \"|(^date-?m$)\" +\n        // Rules are from Chromium source codes\n        \"|exp.*mo|ccmonth|cardmonth|addmonth\" +\n        \"|monat\" + // de-DE\n        // \"|fecha\" + // es\n        // \"|date.*exp\" + // fr-FR\n        // \"|scadenza\" + // it-IT\n        // \"|有効期限\" + // ja-JP\n        // \"|validade\" + // pt-BR, pt-PT\n        // \"|Срок действия карты\" + // ru\n        \"|月\", // zh-CN\n\n      \"cc-exp-year\":\n        // Firefox-specific rules\n        \"(cc|kk)year\" + // de-DE\n        // Rules from Bitwarden\n        \"|(^exp-?year$)\" +\n        \"|(^cc-?exp-?year$)\" +\n        \"|(^cc-?year$)\" +\n        \"|(^card-?year$)\" +\n        \"|(^cc-?yr$)\" +\n        \"|(^card-?yr$)\" +\n        \"|(^exp-?yr$)\" +\n        \"|(^card-?exp-?yr$)\" +\n        \"|(^cc-?exp-?yr$)\" +\n        \"|(^card-?expiration-?year$)\" +\n        \"|(^expiration-?year$)\" +\n        \"|(^cc-?yy$)\" +\n        \"|(^cc-?y$)\" +\n        \"|(^card-?yy$)\" +\n        \"|(^card-?y$)\" +\n        \"|(^card-?exp-?yy$)\" +\n        \"|(^cc-?exp-?yy$)\" +\n        \"|(^exp-?yy$)\" +\n        \"|(^exp-?y$)\" +\n        \"|(^cc-?yyyy$)\" +\n        \"|(^card-?yyyy$)\" +\n        \"|(^card-?exp-?yyyy$)\" +\n        \"|(^cc-?exp-?yyyy$)\" +\n        \"|(^expire-?year$)\" +\n        \"|(^expire-?yr$)\" +\n        \"|(^expiry-?year$)\" +\n        \"|(^expiry-?yr$)\" +\n        \"|(^card-?expire-?year$)\" +\n        \"|(^card-?expire-?yr$)\" +\n        \"|(^card-?expiry-?year$)\" +\n        \"|(^card-?expiry-?yr$)\" +\n        \"|(^an-?validite$)\" +\n        \"|(^an-?expiration$)\" +\n        \"|(^annee-?validite$)\" +\n        \"|(^annee-?expiration$)\" +\n        \"|(^expiry-?date-?field-?year$)\" +\n        \"|(^expiration-?date-?year$)\" +\n        \"|(^cb-?date-?ann$)\" +\n        \"|(^expiration-?date-?yy$)\" +\n        \"|(^expiration-?date-?yyyy$)\" +\n        \"|(^validity-?year$)\" +\n        \"|(^exp-?date-?year$)\" +\n        \"|(^date-?y$)\" +\n        // Rules are from Chromium source codes\n        \"|(add)?year\" +\n        \"|jahr\" + // de-DE\n        // \"|fecha\" + // es\n        // \"|scadenza\" + // it-IT\n        // \"|有効期限\" + // ja-JP\n        // \"|validade\" + // pt-BR, pt-PT\n        // \"|Срок действия карты\" + // ru\n        \"|年|有效期\", // zh-CN\n\n      \"cc-type\":\n        // Firefox-specific rules\n        \"type\" +\n        // de-DE\n        \"|Kartenmarke\" +\n        // Rules from Bitwarden\n        \"|(^cc-?type$)\" +\n        \"|(^card-?type$)\" +\n        \"|(^card-?brand$)\" +\n        \"|(^cc-?brand$)\" +\n        \"|(^cb-?type$)\",\n        // Rules are from Chromium source codes\n    },\n  ],\n\n  _getRule(name) {\n    let rules = [];\n    this.RULE_SETS.forEach(set => {\n      if (set[name]) {\n        rules.push(`(${set[name]})`.normalize(\"NFKC\"));\n      }\n    });\n\n    const value = new RegExp(rules.join(\"|\"), \"iu\");\n    Object.defineProperty(this.RULES, name, { get: undefined });\n    Object.defineProperty(this.RULES, name, { value });\n    return value;\n  },\n\n  init() {\n    Object.keys(this.RULES).forEach(field =>\n      Object.defineProperty(this.RULES, field, {\n        get() {\n          return FathomHeuristicsRegExp._getRule(field);\n        },\n      })\n    );\n  },\n};\n\nFathomHeuristicsRegExp.init();\n\nconst MMRegExp = /^mm$|\\(mm\\)/i;\nconst YYorYYYYRegExp = /^(yy|yyyy)$|\\(yy\\)|\\(yyyy\\)/i;\nconst monthRegExp = /month/i;\nconst yearRegExp = /year/i;\nconst MMYYRegExp = /mm\\s*(\\/|\\\\)\\s*yy/i;\nconst VisaCheckoutRegExp = /visa(-|\\s)checkout/i;\nconst CREDIT_CARD_NETWORK_REGEXP = new RegExp(\n  resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.CreditCard.getSupportedNetworks()\n    .concat(Object.keys(resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.NETWORK_NAMES))\n    .join(\"|\"),\n  \"gui\"\n  );\nconst TwoDigitYearRegExp = /(?:exp.*date[^y\\\\n\\\\r]*|mm\\\\s*[-/]?\\\\s*)yy(?:[^y]|$)/i;\nconst FourDigitYearRegExp = /(?:exp.*date[^y\\\\n\\\\r]*|mm\\\\s*[-/]?\\\\s*)yyyy(?:[^y]|$)/i;\nconst dwfrmRegExp = /^dwfrm/i;\nconst bmlRegExp = /bml/i;\nconst templatedValue = /^\\{\\{.*\\}\\}$/;\nconst firstRegExp = /first/i;\nconst lastRegExp = /last/i;\nconst giftRegExp = /gift/i;\nconst subscriptionRegExp = /subscription/i;\n\nfunction autocompleteStringMatches(element, ccString) {\n  const info = getAutocompleteInfo(element);\n  return info.fieldName === ccString;\n}\n\nfunction getFillableFormElements(element) {\n  const formLike = resource_gre_modules_FormLikeFactory_sys_mjs__WEBPACK_IMPORTED_MODULE_4__.FormLikeFactory.createFromField(element);\n  return Array.from(formLike.elements).filter(el =>\n    resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_2__.FormAutofillUtils.isCreditCardOrAddressFieldType(el)\n  );\n}\n\nfunction nextFillableFormField(element) {\n  const fillableFormElements = getFillableFormElements(element);\n  const elementIndex = fillableFormElements.indexOf(element);\n  return fillableFormElements[elementIndex + 1];\n}\n\nfunction previousFillableFormField(element) {\n  const fillableFormElements = getFillableFormElements(element);\n  const elementIndex = fillableFormElements.indexOf(element);\n  return fillableFormElements[elementIndex - 1];\n}\n\nfunction nextFieldPredicateIsTrue(element, predicate) {\n  const nextField = nextFillableFormField(element);\n  return !!nextField && predicate(nextField);\n}\n\nfunction previousFieldPredicateIsTrue(element, predicate) {\n  const previousField = previousFillableFormField(element);\n  return !!previousField && predicate(previousField);\n}\n\nfunction nextFieldMatchesExpYearAutocomplete(fnode) {\n  return nextFieldPredicateIsTrue(fnode.element, nextField =>\n    autocompleteStringMatches(nextField, \"cc-exp-year\")\n  );\n}\n\nfunction previousFieldMatchesExpMonthAutocomplete(fnode) {\n  return previousFieldPredicateIsTrue(fnode.element, previousField =>\n    autocompleteStringMatches(previousField, \"cc-exp-month\")\n  );\n}\n\n//////////////////////////////////////////////\n// Attribute Regular Expression Rules\nfunction idOrNameMatchRegExp(element, regExp) {\n  for (const str of [element.id, element.name]) {\n    if (regExp.test(str)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getElementLabels(element) {\n  return {\n    *[Symbol.iterator]() {\n      const labels = resource_gre_modules_shared_LabelUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_5__.LabelUtils.findLabelElements(element);\n      for (let label of labels) {\n        yield* resource_gre_modules_shared_LabelUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_5__.LabelUtils.extractLabelStrings(label);\n      }\n    },\n  };\n}\n\nfunction labelsMatchRegExp(element, regExp) {\n  const elemStrings = getElementLabels(element);\n  for (const str of elemStrings) {\n    if (regExp.test(str)) {\n      return true;\n    }\n  }\n\n  const parentElement = element.parentElement;\n  // Bug 1634819: element.parentElement is null if element.parentNode is a ShadowRoot\n  if (!parentElement) {\n    return false;\n  }\n  // Check if the input is in a <td>, and, if so, check the textContent of the containing <tr>\n  if (parentElement.tagName === \"TD\" && parentElement.parentElement) {\n    // TODO: How bad is the assumption that the <tr> won't be the parent of the <td>?\n    return regExp.test(parentElement.parentElement.textContent);\n  }\n\n  // Check if the input is in a <dd>, and, if so, check the textContent of the preceding <dt>\n  if (\n    parentElement.tagName === \"DD\" &&\n    // previousElementSibling can be null\n    parentElement.previousElementSibling\n  ) {\n    return regExp.test(parentElement.previousElementSibling.textContent);\n  }\n  return false;\n}\n\nfunction closestLabelMatchesRegExp(element, regExp) {\n  const previousElementSibling = element.previousElementSibling;\n  if (\n    previousElementSibling !== null &&\n    previousElementSibling.tagName === \"LABEL\"\n  ) {\n    return regExp.test(previousElementSibling.textContent);\n  }\n\n  const nextElementSibling = element.nextElementSibling;\n  if (nextElementSibling !== null && nextElementSibling.tagName === \"LABEL\") {\n    return regExp.test(nextElementSibling.textContent);\n  }\n\n  return false;\n}\n\nfunction ariaLabelMatchesRegExp(element, regExp) {\n  const ariaLabel = element.getAttribute(\"aria-label\");\n  return !!ariaLabel && regExp.test(ariaLabel);\n}\n\nfunction placeholderMatchesRegExp(element, regExp) {\n  const placeholder = element.getAttribute(\"placeholder\");\n  return !!placeholder && regExp.test(placeholder);\n}\n\nfunction nextFieldIdOrNameMatchRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    idOrNameMatchRegExp(nextField, regExp)\n  );\n}\n\nfunction nextFieldLabelsMatchRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    labelsMatchRegExp(nextField, regExp)\n  );\n}\n\nfunction nextFieldPlaceholderMatchesRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    placeholderMatchesRegExp(nextField, regExp)\n  );\n}\n\nfunction nextFieldAriaLabelMatchesRegExp(element, regExp) {\n  return nextFieldPredicateIsTrue(element, nextField =>\n    ariaLabelMatchesRegExp(nextField, regExp)\n  );\n}\n\nfunction previousFieldIdOrNameMatchRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    idOrNameMatchRegExp(previousField, regExp)\n  );\n}\n\nfunction previousFieldLabelsMatchRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    labelsMatchRegExp(previousField, regExp)\n  );\n}\n\nfunction previousFieldPlaceholderMatchesRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    placeholderMatchesRegExp(previousField, regExp)\n  );\n}\n\nfunction previousFieldAriaLabelMatchesRegExp(element, regExp) {\n  return previousFieldPredicateIsTrue(element, previousField =>\n    ariaLabelMatchesRegExp(previousField, regExp)\n  );\n}\n//////////////////////////////////////////////\n\nfunction isSelectWithCreditCardOptions(fnode) {\n  // Check every select for options that match credit card network names in\n  // value or label.\n  const element = fnode.element;\n  if (element.tagName === \"SELECT\") {\n    for (let option of element.querySelectorAll(\"option\")) {\n      if (\n        resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.CreditCard.getNetworkFromName(option.value) ||\n        resource_gre_modules_CreditCard_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.CreditCard.getNetworkFromName(option.text)\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * If any of the regular expressions match multiple times, we assume the tested\n * string belongs to a radio button for payment type instead of card type.\n *\n * @param {Fnode} fnode\n * @returns {boolean}\n */\nfunction isRadioWithCreditCardText(fnode) {\n  const element = fnode.element;\n  const inputType = element.type;\n  if (!!inputType && inputType === \"radio\") {\n    const valueMatches = element.value.match(CREDIT_CARD_NETWORK_REGEXP);\n    if (valueMatches) {\n      return valueMatches.length === 1;\n    }\n\n    // Here we are checking that only one label matches only one entry in the regular expression.\n    const labels = getElementLabels(element);\n    let labelsMatched = 0;\n    for (const label of labels) {\n      const labelMatches = label.match(CREDIT_CARD_NETWORK_REGEXP);\n      if (labelMatches) {\n        if (labelMatches.length > 1) {\n          return false;\n        }\n        labelsMatched++;\n      }\n    }\n    if (labelsMatched > 0) {\n      return labelsMatched === 1;\n    }\n\n    const textContentMatches = element.textContent.match(\n      CREDIT_CARD_NETWORK_REGEXP\n    );\n    if (textContentMatches) {\n      return textContentMatches.length === 1;\n    }\n  }\n  return false;\n}\n\nfunction matchContiguousSubArray(array, subArray) {\n  return array.some((elm, i) =>\n    subArray.every((sElem, j) => sElem === array[i + j])\n  );\n}\n\nfunction isExpirationMonthLikely(element) {\n  if (element.tagName !== \"SELECT\") {\n    return false;\n  }\n\n  const options = [...element.options];\n  const desiredValues = Array(12)\n    .fill(1)\n    .map((v, i) => v + i);\n\n  // The number of month options shouldn't be less than 12 or larger than 13\n  // including the default option.\n  if (options.length < 12 || options.length > 13) {\n    return false;\n  }\n\n  return (\n    matchContiguousSubArray(\n      options.map(e => +e.value),\n      desiredValues\n    ) ||\n    matchContiguousSubArray(\n      options.map(e => +e.label),\n      desiredValues\n    )\n  );\n}\n\nfunction isExpirationYearLikely(element) {\n  if (element.tagName !== \"SELECT\") {\n    return false;\n  }\n\n  const options = [...element.options];\n  // A normal expiration year select should contain at least the last three years\n  // in the list.\n  const curYear = new Date().getFullYear();\n  const desiredValues = Array(3)\n    .fill(0)\n    .map((v, i) => v + curYear + i);\n\n  return (\n    matchContiguousSubArray(\n      options.map(e => +e.value),\n      desiredValues\n    ) ||\n    matchContiguousSubArray(\n      options.map(e => +e.label),\n      desiredValues\n    )\n  );\n}\n\nfunction nextFieldIsExpirationYearLikely(fnode) {\n  return nextFieldPredicateIsTrue(fnode.element, isExpirationYearLikely);\n}\n\nfunction previousFieldIsExpirationMonthLikely(fnode) {\n  return previousFieldPredicateIsTrue(fnode.element, isExpirationMonthLikely);\n}\n\nfunction attrsMatchExpWith2Or4DigitYear(fnode, regExpMatchingFunction) {\n  const element = fnode.element;\n  return (\n    regExpMatchingFunction(element, TwoDigitYearRegExp) ||\n    regExpMatchingFunction(element, FourDigitYearRegExp)\n  );\n}\n\nfunction maxLengthIs(fnode, maxLengthValue) {\n  return fnode.element.maxLength === maxLengthValue;\n}\n\nfunction roleIsMenu(fnode) {\n  const role = fnode.element.getAttribute(\"role\");\n  return !!role && role === \"menu\";\n}\n\nfunction idOrNameMatchDwfrmAndBml(fnode) {\n  return (\n    idOrNameMatchRegExp(fnode.element, dwfrmRegExp) &&\n    idOrNameMatchRegExp(fnode.element, bmlRegExp)\n  );\n}\n\nfunction hasTemplatedValue(fnode) {\n  const value = fnode.element.getAttribute(\"value\");\n  return !!value && templatedValue.test(value);\n}\n\nfunction inputTypeNotNumbery(fnode) {\n  const inputType = fnode.element.type;\n  if (inputType) {\n    return ![\"text\", \"tel\", \"number\"].includes(inputType);\n  }\n  return false;\n}\n\nfunction idOrNameMatchFirstAndLast(fnode) {\n  return (\n    idOrNameMatchRegExp(fnode.element, firstRegExp) &&\n    idOrNameMatchRegExp(fnode.element, lastRegExp)\n  );\n}\n\n/**\n * Compactly generate a series of rules that all take a single LHS type with no\n * .when() clause and have only a score() call on the right- hand side.\n *\n * @param {Lhs} inType The incoming fnode type that all rules take\n * @param {object} ruleMap A simple object used as a map with rule names\n *   pointing to scoring callbacks\n * @yields {Rule}\n */\nfunction* simpleScoringRules(inType, ruleMap) {\n  for (const [name, scoringCallback] of Object.entries(ruleMap)) {\n    yield (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(inType), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.score)(scoringCallback), { name });\n  }\n}\n\nfunction makeRuleset(coeffs, biases) {\n  return (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.ruleset)(\n    [\n      /**\n       * Factor out the page scan just for a little more speed during training.\n       * This selector is good for most fields. cardType is an exception: it\n       * cannot be type=month.\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)(\n        queriedOrClickedElements(\n          \"input:not([type]), input[type=text], input[type=textbox], input[type=email], input[type=tel], input[type=number], input[type=month], select, button\"\n        ),\n        (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\")\n      ),\n\n      /**\n       * number rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-number\")),\n      ...simpleScoringRules(\"cc-number\", {\n        idOrNameMatchNumberRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-number\"]\n          ),\n        labelsMatchNumberRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-number\"]),\n        closestLabelMatchesNumberRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-number\"]),\n        placeholderMatchesNumberRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-number\"]\n          ),\n        ariaLabelMatchesNumberRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-number\"]\n          ),\n        idOrNameMatchGift: fnode =>\n          idOrNameMatchRegExp(fnode.element, giftRegExp),\n        labelsMatchGift: fnode => labelsMatchRegExp(fnode.element, giftRegExp),\n        placeholderMatchesGift: fnode =>\n          placeholderMatchesRegExp(fnode.element, giftRegExp),\n        ariaLabelMatchesGift: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, giftRegExp),\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n        inputTypeNotNumbery,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-number\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-number\")),\n\n      /**\n       * name rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-name\")),\n      ...simpleScoringRules(\"cc-name\", {\n        idOrNameMatchNameRegExp: fnode =>\n          idOrNameMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-name\"]),\n        labelsMatchNameRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-name\"]),\n        closestLabelMatchesNameRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-name\"]),\n        placeholderMatchesNameRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-name\"]\n          ),\n        ariaLabelMatchesNameRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-name\"]\n          ),\n        idOrNameMatchFirst: fnode =>\n          idOrNameMatchRegExp(fnode.element, firstRegExp),\n        labelsMatchFirst: fnode =>\n          labelsMatchRegExp(fnode.element, firstRegExp),\n        placeholderMatchesFirst: fnode =>\n          placeholderMatchesRegExp(fnode.element, firstRegExp),\n        ariaLabelMatchesFirst: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, firstRegExp),\n        idOrNameMatchLast: fnode =>\n          idOrNameMatchRegExp(fnode.element, lastRegExp),\n        labelsMatchLast: fnode => labelsMatchRegExp(fnode.element, lastRegExp),\n        placeholderMatchesLast: fnode =>\n          placeholderMatchesRegExp(fnode.element, lastRegExp),\n        ariaLabelMatchesLast: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, lastRegExp),\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchFirstAndLast,\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-name\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-name\")),\n\n      /**\n       * cardType rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)(\n        queriedOrClickedElements(\n          \"input:not([type]), input[type=text], input[type=textbox], input[type=email], input[type=tel], input[type=number], input[type=radio], select, button\"\n        ),\n        (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-type\")\n      ),\n      ...simpleScoringRules(\"cc-type\", {\n        idOrNameMatchTypeRegExp: fnode =>\n          idOrNameMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-type\"]),\n        labelsMatchTypeRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-type\"]),\n        closestLabelMatchesTypeRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-type\"]),\n        idOrNameMatchVisaCheckout: fnode =>\n          idOrNameMatchRegExp(fnode.element, VisaCheckoutRegExp),\n        ariaLabelMatchesVisaCheckout: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, VisaCheckoutRegExp),\n        isSelectWithCreditCardOptions,\n        isRadioWithCreditCardText,\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-type\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-type\")),\n\n      /**\n       * expiration rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp\")),\n      ...simpleScoringRules(\"cc-exp\", {\n        labelsMatchExpRegExp: fnode =>\n          labelsMatchRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-exp\"]),\n        closestLabelMatchesExpRegExp: fnode =>\n          closestLabelMatchesRegExp(fnode.element, FathomHeuristicsRegExp.RULES[\"cc-exp\"]),\n        placeholderMatchesExpRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp\"]\n          ),\n        labelsMatchExpWith2Or4DigitYear: fnode =>\n          attrsMatchExpWith2Or4DigitYear(fnode, labelsMatchRegExp),\n        placeholderMatchesExpWith2Or4DigitYear: fnode =>\n          attrsMatchExpWith2Or4DigitYear(fnode, placeholderMatchesRegExp),\n        labelsMatchMMYY: fnode => labelsMatchRegExp(fnode.element, MMYYRegExp),\n        placeholderMatchesMMYY: fnode =>\n          placeholderMatchesRegExp(fnode.element, MMYYRegExp),\n        maxLengthIs7: fnode => maxLengthIs(fnode, 7),\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n        isExpirationMonthLikely: fnode =>\n          isExpirationMonthLikely(fnode.element),\n        isExpirationYearLikely: fnode => isExpirationYearLikely(fnode.element),\n        idOrNameMatchMonth: fnode =>\n          idOrNameMatchRegExp(fnode.element, monthRegExp),\n        idOrNameMatchYear: fnode =>\n          idOrNameMatchRegExp(fnode.element, yearRegExp),\n        idOrNameMatchExpMonthRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        idOrNameMatchExpYearRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        idOrNameMatchValidation: fnode =>\n          idOrNameMatchRegExp(fnode.element, /validate|validation/i),\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-exp\")),\n\n      /**\n       * expirationMonth rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-month\")),\n      ...simpleScoringRules(\"cc-exp-month\", {\n        idOrNameMatchExpMonthRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        labelsMatchExpMonthRegExp: fnode =>\n          labelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        closestLabelMatchesExpMonthRegExp: fnode =>\n          closestLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        placeholderMatchesExpMonthRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        ariaLabelMatchesExpMonthRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        idOrNameMatchMonth: fnode =>\n          idOrNameMatchRegExp(fnode.element, monthRegExp),\n        labelsMatchMonth: fnode =>\n          labelsMatchRegExp(fnode.element, monthRegExp),\n        placeholderMatchesMonth: fnode =>\n          placeholderMatchesRegExp(fnode.element, monthRegExp),\n        ariaLabelMatchesMonth: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, monthRegExp),\n        nextFieldIdOrNameMatchExpYearRegExp: fnode =>\n          nextFieldIdOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldLabelsMatchExpYearRegExp: fnode =>\n          nextFieldLabelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldPlaceholderMatchExpYearRegExp: fnode =>\n          nextFieldPlaceholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldAriaLabelMatchExpYearRegExp: fnode =>\n          nextFieldAriaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        nextFieldIdOrNameMatchYear: fnode =>\n          nextFieldIdOrNameMatchRegExp(fnode.element, yearRegExp),\n        nextFieldLabelsMatchYear: fnode =>\n          nextFieldLabelsMatchRegExp(fnode.element, yearRegExp),\n        nextFieldPlaceholderMatchesYear: fnode =>\n          nextFieldPlaceholderMatchesRegExp(fnode.element, yearRegExp),\n        nextFieldAriaLabelMatchesYear: fnode =>\n          nextFieldAriaLabelMatchesRegExp(fnode.element, yearRegExp),\n        nextFieldMatchesExpYearAutocomplete,\n        isExpirationMonthLikely: fnode =>\n          isExpirationMonthLikely(fnode.element),\n        nextFieldIsExpirationYearLikely,\n        maxLengthIs2: fnode => maxLengthIs(fnode, 2),\n        placeholderMatchesMM: fnode =>\n          placeholderMatchesRegExp(fnode.element, MMRegExp),\n        roleIsMenu,\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-month\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-exp-month\")),\n\n      /**\n       * expirationYear rules\n       */\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"typicalCandidates\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-year\")),\n      ...simpleScoringRules(\"cc-exp-year\", {\n        idOrNameMatchExpYearRegExp: fnode =>\n          idOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        labelsMatchExpYearRegExp: fnode =>\n          labelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        closestLabelMatchesExpYearRegExp: fnode =>\n          closestLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        placeholderMatchesExpYearRegExp: fnode =>\n          placeholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        ariaLabelMatchesExpYearRegExp: fnode =>\n          ariaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-year\"]\n          ),\n        idOrNameMatchYear: fnode =>\n          idOrNameMatchRegExp(fnode.element, yearRegExp),\n        labelsMatchYear: fnode => labelsMatchRegExp(fnode.element, yearRegExp),\n        placeholderMatchesYear: fnode =>\n          placeholderMatchesRegExp(fnode.element, yearRegExp),\n        ariaLabelMatchesYear: fnode =>\n          ariaLabelMatchesRegExp(fnode.element, yearRegExp),\n        previousFieldIdOrNameMatchExpMonthRegExp: fnode =>\n          previousFieldIdOrNameMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldLabelsMatchExpMonthRegExp: fnode =>\n          previousFieldLabelsMatchRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldPlaceholderMatchExpMonthRegExp: fnode =>\n          previousFieldPlaceholderMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldAriaLabelMatchExpMonthRegExp: fnode =>\n          previousFieldAriaLabelMatchesRegExp(\n            fnode.element,\n            FathomHeuristicsRegExp.RULES[\"cc-exp-month\"]\n          ),\n        previousFieldIdOrNameMatchMonth: fnode =>\n          previousFieldIdOrNameMatchRegExp(fnode.element, monthRegExp),\n        previousFieldLabelsMatchMonth: fnode =>\n          previousFieldLabelsMatchRegExp(fnode.element, monthRegExp),\n        previousFieldPlaceholderMatchesMonth: fnode =>\n          previousFieldPlaceholderMatchesRegExp(fnode.element, monthRegExp),\n        previousFieldAriaLabelMatchesMonth: fnode =>\n          previousFieldAriaLabelMatchesRegExp(fnode.element, monthRegExp),\n        previousFieldMatchesExpMonthAutocomplete,\n        isExpirationYearLikely: fnode => isExpirationYearLikely(fnode.element),\n        previousFieldIsExpirationMonthLikely,\n        placeholderMatchesYYOrYYYY: fnode =>\n          placeholderMatchesRegExp(fnode.element, YYorYYYYRegExp),\n        roleIsMenu,\n        idOrNameMatchSubscription: fnode =>\n          idOrNameMatchRegExp(fnode.element, subscriptionRegExp),\n        idOrNameMatchDwfrmAndBml,\n        hasTemplatedValue,\n      }),\n      (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.rule)((0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.type)(\"cc-exp-year\"), (0,resource_gre_modules_third_party_fathom_fathom_mjs__WEBPACK_IMPORTED_MODULE_0__.out)(\"cc-exp-year\")),\n    ],\n    coeffs,\n    biases\n  );\n}\n\nconst coefficients = {\n  \"cc-number\": [\n    [\"idOrNameMatchNumberRegExp\", 7.679469585418701],\n    [\"labelsMatchNumberRegExp\", 5.122580051422119],\n    [\"closestLabelMatchesNumberRegExp\", 2.1256935596466064],\n    [\"placeholderMatchesNumberRegExp\", 9.471800804138184],\n    [\"ariaLabelMatchesNumberRegExp\", 6.067715644836426],\n    [\"idOrNameMatchGift\", -22.946273803710938],\n    [\"labelsMatchGift\", -7.852959632873535],\n    [\"placeholderMatchesGift\", -2.355496406555176],\n    [\"ariaLabelMatchesGift\", -2.940307855606079],\n    [\"idOrNameMatchSubscription\", 0.11255314946174622],\n    [\"idOrNameMatchDwfrmAndBml\", -0.0006645023822784424],\n    [\"hasTemplatedValue\", -0.11370040476322174],\n    [\"inputTypeNotNumbery\", -3.750155210494995]\n  ],\n  \"cc-name\": [\n    [\"idOrNameMatchNameRegExp\", 7.496212959289551],\n    [\"labelsMatchNameRegExp\", 6.081472873687744],\n    [\"closestLabelMatchesNameRegExp\", 2.600574254989624],\n    [\"placeholderMatchesNameRegExp\", 5.750874042510986],\n    [\"ariaLabelMatchesNameRegExp\", 5.162227153778076],\n    [\"idOrNameMatchFirst\", -6.742659091949463],\n    [\"labelsMatchFirst\", -0.5234538912773132],\n    [\"placeholderMatchesFirst\", -3.4615235328674316],\n    [\"ariaLabelMatchesFirst\", -1.3145145177841187],\n    [\"idOrNameMatchLast\", -12.561869621276855],\n    [\"labelsMatchLast\", -0.27417105436325073],\n    [\"placeholderMatchesLast\", -1.434966802597046],\n    [\"ariaLabelMatchesLast\", -2.9319725036621094],\n    [\"idOrNameMatchFirstAndLast\", 24.123435974121094],\n    [\"idOrNameMatchSubscription\", 0.08349418640136719],\n    [\"idOrNameMatchDwfrmAndBml\", 0.01882520318031311],\n    [\"hasTemplatedValue\", 0.182317852973938]\n  ],\n  \"cc-type\": [\n    [\"idOrNameMatchTypeRegExp\", 2.0581533908843994],\n    [\"labelsMatchTypeRegExp\", 1.0784518718719482],\n    [\"closestLabelMatchesTypeRegExp\", 0.6995877623558044],\n    [\"idOrNameMatchVisaCheckout\", -3.320356845855713],\n    [\"ariaLabelMatchesVisaCheckout\", -3.4196767807006836],\n    [\"isSelectWithCreditCardOptions\", 10.337477684020996],\n    [\"isRadioWithCreditCardText\", 4.530318737030029],\n    [\"idOrNameMatchSubscription\", -3.7206356525421143],\n    [\"idOrNameMatchDwfrmAndBml\", -0.08782318234443665],\n    [\"hasTemplatedValue\", 0.1772511601448059]\n  ],\n  \"cc-exp\": [\n    [\"labelsMatchExpRegExp\", 7.588159561157227],\n    [\"closestLabelMatchesExpRegExp\", 1.41484534740448],\n    [\"placeholderMatchesExpRegExp\", 8.759064674377441],\n    [\"labelsMatchExpWith2Or4DigitYear\", -3.876218795776367],\n    [\"placeholderMatchesExpWith2Or4DigitYear\", 2.8364884853363037],\n    [\"labelsMatchMMYY\", 8.836017608642578],\n    [\"placeholderMatchesMMYY\", -0.5231751799583435],\n    [\"maxLengthIs7\", 1.3565447330474854],\n    [\"idOrNameMatchSubscription\", 0.1779913753271103],\n    [\"idOrNameMatchDwfrmAndBml\", 0.21037884056568146],\n    [\"hasTemplatedValue\", 0.14900512993335724],\n    [\"isExpirationMonthLikely\", -3.223409652709961],\n    [\"isExpirationYearLikely\", -2.536919593811035],\n    [\"idOrNameMatchMonth\", -3.6893014907836914],\n    [\"idOrNameMatchYear\", -3.108184337615967],\n    [\"idOrNameMatchExpMonthRegExp\", -2.264357089996338],\n    [\"idOrNameMatchExpYearRegExp\", -2.7957723140716553],\n    [\"idOrNameMatchValidation\", -2.29402756690979]\n  ],\n  \"cc-exp-month\": [\n    [\"idOrNameMatchExpMonthRegExp\", 0.2787344455718994],\n    [\"labelsMatchExpMonthRegExp\", 1.298413634300232],\n    [\"closestLabelMatchesExpMonthRegExp\", -11.206244468688965],\n    [\"placeholderMatchesExpMonthRegExp\", 1.2605619430541992],\n    [\"ariaLabelMatchesExpMonthRegExp\", 1.1330018043518066],\n    [\"idOrNameMatchMonth\", 6.1464314460754395],\n    [\"labelsMatchMonth\", 0.7051732540130615],\n    [\"placeholderMatchesMonth\", 0.7463492751121521],\n    [\"ariaLabelMatchesMonth\", 1.8244760036468506],\n    [\"nextFieldIdOrNameMatchExpYearRegExp\", 0.06347066164016724],\n    [\"nextFieldLabelsMatchExpYearRegExp\", -0.1692247837781906],\n    [\"nextFieldPlaceholderMatchExpYearRegExp\", 1.0434566736221313],\n    [\"nextFieldAriaLabelMatchExpYearRegExp\", 1.751156210899353],\n    [\"nextFieldIdOrNameMatchYear\", -0.532447338104248],\n    [\"nextFieldLabelsMatchYear\", 1.3248541355133057],\n    [\"nextFieldPlaceholderMatchesYear\", 0.604235827922821],\n    [\"nextFieldAriaLabelMatchesYear\", 1.5364223718643188],\n    [\"nextFieldMatchesExpYearAutocomplete\", 6.285938262939453],\n    [\"isExpirationMonthLikely\", 13.117807388305664],\n    [\"nextFieldIsExpirationYearLikely\", 7.182341575622559],\n    [\"maxLengthIs2\", 4.477289199829102],\n    [\"placeholderMatchesMM\", 14.403288841247559],\n    [\"roleIsMenu\", 5.770959854125977],\n    [\"idOrNameMatchSubscription\", -0.043085768818855286],\n    [\"idOrNameMatchDwfrmAndBml\", 0.02823038399219513],\n    [\"hasTemplatedValue\", 0.07234494388103485]\n  ],\n  \"cc-exp-year\": [\n    [\"idOrNameMatchExpYearRegExp\", 5.426016807556152],\n    [\"labelsMatchExpYearRegExp\", 1.3240209817886353],\n    [\"closestLabelMatchesExpYearRegExp\", -8.702284812927246],\n    [\"placeholderMatchesExpYearRegExp\", 0.9059725999832153],\n    [\"ariaLabelMatchesExpYearRegExp\", 0.5550334453582764],\n    [\"idOrNameMatchYear\", 5.362994194030762],\n    [\"labelsMatchYear\", 2.7185044288635254],\n    [\"placeholderMatchesYear\", 0.7883157134056091],\n    [\"ariaLabelMatchesYear\", 0.311492383480072],\n    [\"previousFieldIdOrNameMatchExpMonthRegExp\", 1.8155208826065063],\n    [\"previousFieldLabelsMatchExpMonthRegExp\", -0.46133187413215637],\n    [\"previousFieldPlaceholderMatchExpMonthRegExp\", 1.0374903678894043],\n    [\"previousFieldAriaLabelMatchExpMonthRegExp\", -0.5901495814323425],\n    [\"previousFieldIdOrNameMatchMonth\", -5.960310935974121],\n    [\"previousFieldLabelsMatchMonth\", 0.6495584845542908],\n    [\"previousFieldPlaceholderMatchesMonth\", 0.7198042273521423],\n    [\"previousFieldAriaLabelMatchesMonth\", 3.4590985774993896],\n    [\"previousFieldMatchesExpMonthAutocomplete\", 2.986003875732422],\n    [\"isExpirationYearLikely\", 4.021566390991211],\n    [\"previousFieldIsExpirationMonthLikely\", 9.298635482788086],\n    [\"placeholderMatchesYYOrYYYY\", 10.457176208496094],\n    [\"roleIsMenu\", 1.1051956415176392],\n    [\"idOrNameMatchSubscription\", 0.000688597559928894],\n    [\"idOrNameMatchDwfrmAndBml\", 0.15687309205532074],\n    [\"hasTemplatedValue\", -0.19141331315040588]\n  ],\n};\n\nconst biases = [\n  [\"cc-number\", -4.948795795440674],\n  [\"cc-name\", -5.3578081130981445],\n  [\"cc-type\", -5.979659557342529],\n  [\"cc-exp\", -5.849575996398926],\n  [\"cc-exp-month\", -8.844199180603027],\n  [\"cc-exp-year\", -6.499860763549805],\n];\n\n/**\n * END OF CODE PASTED FROM TRAINING REPOSITORY\n */\n\n/**\n * MORE CODE UNIQUE TO PRODUCTION--NOT IN THE TRAINING REPOSITORY:\n */\n// Currently there is a bug when a ruleset has multple types (ex, cc-name, cc-number)\n// and those types also has the same rules (ex. rule `hasTemplatedValue` is used in\n// all the tyoes). When the above case exists, the coefficient of the rule will be\n// overwritten, which means, we can't have different coefficient for the same rule on\n// different types. To workaround this issue, we create a new ruleset for each type.\nvar CreditCardRulesets = {\n  init() {\n    resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n      this,\n      \"supportedTypes\",\n      \"extensions.formautofill.creditCards.heuristics.fathom.types\",\n      null,\n      null,\n      val => val.split(\",\")\n    );\n\n    for (const type of this.types) {\n      this[type] = makeRuleset([...coefficients[type]], biases);\n    }\n  },\n\n  get types() {\n    return this.supportedTypes;\n  },\n};\n\nCreditCardRulesets.init();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CreditCardRulesets);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs":
/*!******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FieldDetail\": () => (/* binding */ FieldDetail),\n/* harmony export */   \"FieldScanner\": () => (/* binding */ FieldScanner),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n});\n\n/**\n * Represents the detailed information about a form field, including\n * the inferred field name, the approach used for inferring, and additional metadata.\n */\nclass FieldDetail {\n  // Reference to the elemenet\n  elementWeakRef = null;\n\n  // id/name. This is only used for debugging\n  identifier = \"\";\n\n  // The inferred field name for this element\n  fieldName = null;\n\n  // The approach we use to infer the information for this element\n  // The possible values are \"autocomplete\", \"fathom\", and \"regex-heuristic\"\n  reason = null;\n\n  /*\n   * The \"section\", \"addressType\", and \"contactType\" values are\n   * used to identify the exact field when the serializable data is received\n   * from the backend.  There cannot be multiple fields which have\n   * the same exact combination of these values.\n   */\n\n  // Which section the field belongs to. The value comes from autocomplete attribute.\n  // See https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill-detail-tokens for more details\n  section = \"\";\n  addressType = \"\";\n  contactType = \"\";\n  credentialType = \"\";\n\n  // When a field is split into N fields, we use part to record which field it is\n  // For example, a credit card number field is split into 4 fields, the value of\n  // \"part\" for the first cc-number field is 1, for the last one is 4.\n  // If the field is not split, the value is null\n  part = null;\n\n  // Confidence value when the field name is inferred by \"fathom\"\n  confidence = null;\n\n  constructor(\n    element,\n    fieldName = null,\n    { autocompleteInfo = {}, confidence = null } = {}\n  ) {\n    this.elementWeakRef = new WeakRef(element);\n    this.identifier = `${element.id}/${element.name}`;\n    this.fieldName = fieldName;\n\n    if (autocompleteInfo) {\n      this.reason = \"autocomplete\";\n      this.section = autocompleteInfo.section;\n      this.addressType = autocompleteInfo.addressType;\n      this.contactType = autocompleteInfo.contactType;\n      this.credentialType = autocompleteInfo.credentialType;\n    } else if (confidence) {\n      this.reason = \"fathom\";\n      this.confidence = confidence;\n    } else {\n      this.reason = \"regex-heuristic\";\n    }\n  }\n\n  get element() {\n    return this.elementWeakRef.deref();\n  }\n\n  get sectionName() {\n    return this.section || this.addressType;\n  }\n\n  #isVisible = null;\n  get isVisible() {\n    if (this.#isVisible == null) {\n      this.#isVisible = lazy.FormAutofillUtils.isFieldVisible(this.element);\n    }\n    return this.#isVisible;\n  }\n}\n\n/**\n * A scanner for traversing all elements in a form. It also provides a\n * cursor (parsingIndex) to indicate which element is waiting for parsing.\n *\n * The scanner retrives the field detail by calling heuristics handlers\n * `inferFieldInfo` function.\n */\nclass FieldScanner {\n  #elementsWeakRef = null;\n  #inferFieldInfoFn = null;\n\n  #parsingIndex = 0;\n\n  fieldDetails = [];\n\n  /**\n   * Create a FieldScanner based on form elements with the existing\n   * fieldDetails.\n   *\n   * @param {Array.DOMElement} elements\n   *        The elements from a form for each parser.\n   * @param {Funcion} inferFieldInfoFn\n   *        The callback function that is used to infer the field info of a given element\n   */\n  constructor(elements, inferFieldInfoFn) {\n    this.#elementsWeakRef = new WeakRef(elements);\n    this.#inferFieldInfoFn = inferFieldInfoFn;\n  }\n\n  get #elements() {\n    return this.#elementsWeakRef.deref();\n  }\n\n  /**\n   * This cursor means the index of the element which is waiting for parsing.\n   *\n   * @returns {number}\n   *          The index of the element which is waiting for parsing.\n   */\n  get parsingIndex() {\n    return this.#parsingIndex;\n  }\n\n  get parsingFinished() {\n    return this.parsingIndex >= this.#elements.length;\n  }\n\n  /**\n   * Move the parsingIndex to the next elements. Any elements behind this index\n   * means the parsing tasks are finished.\n   *\n   * @param {number} index\n   *        The latest index of elements waiting for parsing.\n   */\n  set parsingIndex(index) {\n    if (index > this.#elements.length) {\n      throw new Error(\"The parsing index is out of range.\");\n    }\n    this.#parsingIndex = index;\n  }\n\n  /**\n   * Retrieve the field detail by the index. If the field detail is not ready,\n   * the elements will be traversed until matching the index.\n   *\n   * @param {number} index\n   *        The index of the element that you want to retrieve.\n   * @returns {object}\n   *          The field detail at the specific index.\n   */\n  getFieldDetailByIndex(index) {\n    if (index >= this.#elements.length) {\n      return null;\n    }\n\n    if (index < this.fieldDetails.length) {\n      return this.fieldDetails[index];\n    }\n\n    for (let i = this.fieldDetails.length; i < index + 1; i++) {\n      this.pushDetail();\n    }\n\n    return this.fieldDetails[index];\n  }\n\n  /**\n   * This function retrieves the first unparsed element and obtains its\n   * information by invoking the `inferFieldInfoFn` callback function.\n   * The field information is then stored in a FieldDetail object and\n   * appended to the `fieldDetails` array.\n   *\n   * Any element without the related detail will be used for adding the detail\n   * to the end of field details.\n   */\n  pushDetail() {\n    const elementIndex = this.fieldDetails.length;\n    if (elementIndex >= this.#elements.length) {\n      throw new Error(\"Try to push the non-existing element info.\");\n    }\n    const element = this.#elements[elementIndex];\n    const [fieldName, autocompleteInfo, confidence] =\n      this.#inferFieldInfoFn(element);\n    const fieldDetail = new FieldDetail(element, fieldName, {\n      autocompleteInfo,\n      confidence,\n    });\n\n    this.fieldDetails.push(fieldDetail);\n  }\n\n  /**\n   * When a field detail should be changed its fieldName after parsing, use\n   * this function to update the fieldName which is at a specific index.\n   *\n   * @param {number} index\n   *        The index indicates a field detail to be updated.\n   * @param {string} fieldName\n   *        The new name of the field\n   * @param {boolean} [ignoreAutocomplete=false]\n   *        Whether to change the field name when the field name is determined by\n   *        autocomplete attribute\n   */\n  updateFieldName(index, fieldName, ignoreAutocomplete = false) {\n    if (index >= this.fieldDetails.length) {\n      throw new Error(\"Try to update the non-existing field detail.\");\n    }\n\n    const fieldDetail = this.fieldDetails[index];\n    if (fieldDetail.fieldName == fieldName) {\n      return;\n    }\n\n    if (!ignoreAutocomplete && fieldDetail.reason == \"autocomplete\") {\n      return;\n    }\n\n    this.fieldDetails[index].fieldName = fieldName;\n    this.fieldDetails[index].reason = \"update-heuristic\";\n  }\n\n  elementExisting(index) {\n    return index < this.#elements.length;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FieldScanner);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofill\": () => (/* reexport safe */ resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\nresource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.defineLogGetter = (_scope, _logPrefix) => ({\n  // TODO: Bug 1828405. Explore how logging should be handled.\n  // Maybe it makes more sense to do it on swift side and have JS just send messages.\n  info: () => {},\n  error: () => {},\n  warn: () => {},\n  debug: () => {},\n});\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs":
/*!******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofill\": () => (/* binding */ FormAutofill)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/Region.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* harmony import */ var resource_gre_modules_shared_AddressMetaDataLoader_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n\nconst AUTOFILL_ADDRESSES_AVAILABLE_PREF =\n  \"extensions.formautofill.addresses.supported\";\n// This pref should be refactored after the migration of the old bool pref\nconst AUTOFILL_CREDITCARDS_AVAILABLE_PREF =\n  \"extensions.formautofill.creditCards.supported\";\nconst BROWSER_SEARCH_REGION_PREF = \"browser.search.region\";\nconst CREDITCARDS_AUTOFILL_SUPPORTED_COUNTRIES_PREF =\n  \"extensions.formautofill.creditCards.supportedCountries\";\nconst ENABLED_AUTOFILL_ADDRESSES_PREF =\n  \"extensions.formautofill.addresses.enabled\";\nconst ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF =\n  \"extensions.formautofill.addresses.capture.enabled\";\nconst ENABLED_AUTOFILL_ADDRESSES_CAPTURE_REQUIRED_FIELDS_PREF =\n  \"extensions.formautofill.addresses.capture.requiredFields\";\nconst ENABLED_AUTOFILL_ADDRESSES_SUPPORTED_COUNTRIES_PREF =\n  \"extensions.formautofill.addresses.supportedCountries\";\nconst ENABLED_AUTOFILL_CREDITCARDS_PREF =\n  \"extensions.formautofill.creditCards.enabled\";\nconst ENABLED_AUTOFILL_CREDITCARDS_REAUTH_PREF =\n  \"extensions.formautofill.reauth.enabled\";\nconst AUTOFILL_CREDITCARDS_HIDE_UI_PREF =\n  \"extensions.formautofill.creditCards.hideui\";\nconst FORM_AUTOFILL_SUPPORT_RTL_PREF = \"extensions.formautofill.supportRTL\";\nconst AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF =\n  \"extensions.formautofill.creditCards.ignoreAutocompleteOff\";\nconst AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF =\n  \"extensions.formautofill.addresses.ignoreAutocompleteOff\";\nconst ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF =\n  \"extensions.formautofill.heuristics.captureOnFormRemoval\";\nconst ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF =\n  \"extensions.formautofill.heuristics.captureOnPageNavigation\";\n\nconst FormAutofill = {\n  ENABLED_AUTOFILL_ADDRESSES_PREF,\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF,\n  ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF,\n  ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF,\n  ENABLED_AUTOFILL_CREDITCARDS_PREF,\n  ENABLED_AUTOFILL_CREDITCARDS_REAUTH_PREF,\n  AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF,\n  AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF,\n\n  _region: null,\n\n  get DEFAULT_REGION() {\n    return this._region || resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.Region.home || \"US\";\n  },\n\n  set DEFAULT_REGION(region) {\n    this._region = region;\n  },\n\n  /**\n   * Determines if an autofill feature should be enabled based on the \"available\"\n   * and \"supportedCountries\" parameters.\n   *\n   * @param {string} available Available can be one of the following: \"on\", \"detect\", \"off\".\n   * \"on\" forces the particular Form Autofill feature on, while \"detect\" utilizes the supported countries\n   * to see if the feature should be available.\n   * @param {string[]} supportedCountries\n   * @returns {boolean} `true` if autofill feature is supported in the current browser search region\n   */\n  _isSupportedRegion(available, supportedCountries) {\n    if (available == \"on\") {\n      return true;\n    } else if (available == \"detect\") {\n      if (!FormAutofill.supportRTL && Services.locale.isAppLocaleRTL) {\n        return false;\n      }\n\n      return supportedCountries.includes(FormAutofill.browserSearchRegion);\n    }\n    return false;\n  },\n  isAutofillAddressesAvailableInCountry(country) {\n    return FormAutofill._addressAutofillSupportedCountries.includes(\n      country.toUpperCase()\n    );\n  },\n  get isAutofillEnabled() {\n    return this.isAutofillAddressesEnabled || this.isAutofillCreditCardsEnabled;\n  },\n  /**\n   * Determines if the credit card autofill feature is available to use in the browser.\n   * If the feature is not available, then there are no user facing ways to enable it.\n   *\n   * @returns {boolean} `true` if credit card autofill is available\n   */\n  get isAutofillCreditCardsAvailable() {\n    return this._isSupportedRegion(\n      FormAutofill._isAutofillCreditCardsAvailable,\n      FormAutofill._creditCardAutofillSupportedCountries\n    );\n  },\n  /**\n   * Determines if the address autofill feature is available to use in the browser.\n   * If the feature is not available, then there are no user facing ways to enable it.\n   * Two conditions must be met for the autofill feature to be considered available:\n   *   1. Address autofill support is confirmed when:\n   *      - `extensions.formautofill.addresses.supported` is set to `on`.\n   *      - The user is located in a region supported by the feature\n   *        (`extensions.formautofill.creditCards.supportedCountries`).\n   *   2. Address autofill is enabled through a Nimbus experiment:\n   *      - The experiment pref `extensions.formautofill.addresses.experiments.enabled` is set to true.\n   *\n   * @returns {boolean} `true` if address autofill is available\n   */\n  get isAutofillAddressesAvailable() {\n    const isUserInSupportedRegion = this._isSupportedRegion(\n      FormAutofill._isAutofillAddressesAvailable,\n      FormAutofill._addressAutofillSupportedCountries\n    );\n    return (\n      isUserInSupportedRegion ||\n      FormAutofill._isAutofillAddressesAvailableInExperiment\n    );\n  },\n  /**\n   * Determines if the user has enabled or disabled credit card autofill.\n   *\n   * @returns {boolean} `true` if credit card autofill is enabled\n   */\n  get isAutofillCreditCardsEnabled() {\n    return (\n      this.isAutofillCreditCardsAvailable &&\n      FormAutofill._isAutofillCreditCardsEnabled\n    );\n  },\n  /**\n   * Determines if credit card autofill is locked by policy.\n   *\n   * @returns {boolean} `true` if credit card autofill is locked\n   */\n  get isAutofillCreditCardsLocked() {\n    return Services.prefs.prefIsLocked(ENABLED_AUTOFILL_CREDITCARDS_PREF);\n  },\n  /**\n   * Determines if the user has enabled or disabled address autofill.\n   *\n   * @returns {boolean} `true` if address autofill is enabled\n   */\n  get isAutofillAddressesEnabled() {\n    return (\n      this.isAutofillAddressesAvailable &&\n      FormAutofill._isAutofillAddressesEnabled\n    );\n  },\n  /**\n   * Determines if address autofill is locked by policy.\n   *\n   * @returns {boolean} `true` if address autofill is locked\n   */\n  get isAutofillAddressesLocked() {\n    return Services.prefs.prefIsLocked(ENABLED_AUTOFILL_ADDRESSES_PREF);\n  },\n\n  defineLogGetter(scope, logPrefix) {\n    // A logging helper for debug logging to avoid creating Console objects\n    // or triggering expensive JS -> C++ calls when debug logging is not\n    // enabled.\n    //\n    // Console objects, even natively-implemented ones, can consume a lot of\n    // memory, and since this code may run in every content process, that\n    // memory can add up quickly. And, even when debug-level messages are\n    // being ignored, console.debug() calls can be expensive.\n    //\n    // This helper avoids both of those problems by never touching the\n    // console object unless debug logging is enabled.\n    scope.debug = function debug() {\n      if (FormAutofill.logLevel.toLowerCase() == \"debug\") {\n        this.log.debug(...arguments);\n      }\n    };\n\n    let { ConsoleAPI } = ChromeUtils.importESModule(\n      \"resource://gre/modules/Console.sys.mjs\"\n    );\n    return new ConsoleAPI({\n      maxLogLevelPref: \"extensions.formautofill.loglevel\",\n      prefix: logPrefix,\n    });\n  },\n};\n\n// TODO: Bug 1747284. Use Region.home instead of reading \"browser.serach.region\"\n// by default. However, Region.home doesn't observe preference change at this point,\n// we should also fix that issue.\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"browserSearchRegion\",\n  BROWSER_SEARCH_REGION_PREF,\n  FormAutofill.DEFAULT_REGION\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"logLevel\",\n  \"extensions.formautofill.loglevel\",\n  \"Warn\"\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillAddressesAvailable\",\n  AUTOFILL_ADDRESSES_AVAILABLE_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillAddressesEnabled\",\n  ENABLED_AUTOFILL_ADDRESSES_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"isAutofillAddressesCaptureEnabled\",\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillCreditCardsAvailable\",\n  AUTOFILL_CREDITCARDS_AVAILABLE_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillCreditCardsEnabled\",\n  ENABLED_AUTOFILL_CREDITCARDS_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"isAutofillCreditCardsHideUI\",\n  AUTOFILL_CREDITCARDS_HIDE_UI_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_addressAutofillSupportedCountries\",\n  ENABLED_AUTOFILL_ADDRESSES_SUPPORTED_COUNTRIES_PREF,\n  null,\n  val => val.split(\",\")\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_creditCardAutofillSupportedCountries\",\n  CREDITCARDS_AUTOFILL_SUPPORTED_COUNTRIES_PREF,\n  null,\n  null,\n  val => val.split(\",\")\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"supportRTL\",\n  FORM_AUTOFILL_SUPPORT_RTL_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"creditCardsAutocompleteOff\",\n  AUTOFILL_CREDITCARDS_AUTOCOMPLETE_OFF_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"addressesAutocompleteOff\",\n  AUTOFILL_ADDRESSES_AUTOCOMPLETE_OFF_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"captureOnFormRemoval\",\n  ENABLED_AUTOFILL_CAPTURE_ON_FORM_REMOVAL_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"captureOnPageNavigation\",\n  ENABLED_AUTOFILL_CAPTURE_ON_PAGE_NAVIGATION_PREF\n);\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"addressCaptureRequiredFields\",\n  ENABLED_AUTOFILL_ADDRESSES_CAPTURE_REQUIRED_FIELDS_PREF,\n  null,\n  null,\n  val => val?.split(\",\").filter(v => !!v)\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofill,\n  \"_isAutofillAddressesAvailableInExperiment\",\n  \"extensions.formautofill.addresses.experiments.enabled\"\n);\n\nChromeUtils.defineLazyGetter(FormAutofill, \"countries\", () =>\n  resource_gre_modules_shared_AddressMetaDataLoader_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.AddressMetaDataLoader.getCountries()\n);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillChild\": () => (/* binding */ FormAutofillChild),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormStateManager_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormStateManager.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_CreditCardRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! resource://gre/modules/shared/CreditCardRecord.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_AddressRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! resource://gre/modules/shared/AddressRecord.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* eslint-disable no-undef,mozilla/balanced-listeners */\n\n\n\n\n\nclass FormAutofillChild {\n  /**\n   * Creates an instance of FormAutofillChild.\n   *\n   * @param {object} callbacks - An object containing callback functions.\n   * @param {object} callbacks.address - Callbacks related to addresses.\n   * @param {Function} callbacks.address.autofill - Function called to autofill address fields.\n   * @param {Function} callbacks.address.submit - Function called on address form submission.\n   * @param {object} callbacks.creditCard - Callbacks related to credit cards.\n   * @param {Function} callbacks.creditCard.autofill - Function called to autofill credit card fields.\n   * @param {Function} callbacks.creditCard.submit - Function called on credit card form submission.\n   */\n  constructor(callbacks) {\n    this.onFocusIn = this.onFocusIn.bind(this);\n    this.onSubmit = this.onSubmit.bind(this);\n\n    this.callbacks = callbacks;\n\n    this.fieldDetailsManager = new resource_gre_modules_shared_FormStateManager_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormStateManager();\n\n    document.addEventListener(\"focusin\", this.onFocusIn);\n    document.addEventListener(\"submit\", this.onSubmit);\n  }\n\n  _doIdentifyAutofillFields(element) {\n    this.fieldDetailsManager.updateActiveInput(element);\n    this.fieldDetailsManager.identifyAutofillFields(element);\n\n    const activeFieldName =\n      this.fieldDetailsManager.activeFieldDetail?.fieldName;\n\n    const activeFieldDetails =\n      this.fieldDetailsManager.activeSection?.fieldDetails;\n\n    // Only ping swift if current field is either a cc or address field\n    if (!activeFieldDetails?.find(field => field.element === element)) {\n      return;\n    }\n\n    const fieldNamesWithValues =\n      this.transformToFieldNamesWithValues(activeFieldDetails);\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isAddressField(activeFieldName)) {\n      this.callbacks.address.autofill(fieldNamesWithValues);\n    } else if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isCreditCardField(activeFieldName)) {\n      // Normalize record format so we always get a consistent\n      // credit card record format: {cc-number, cc-name, cc-exp-month, cc-exp-year}\n      resource_gre_modules_shared_CreditCardRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_2__.CreditCardRecord.normalizeFields(fieldNamesWithValues);\n      this.callbacks.creditCard.autofill(fieldNamesWithValues);\n    }\n  }\n\n  transformToFieldNamesWithValues(details) {\n    return details?.reduce(\n      (acc, field) => ({\n        ...acc,\n        [field.fieldName]: field.element.value,\n      }),\n      {}\n    );\n  }\n\n  onFocusIn(evt) {\n    const element = evt.target;\n    this.fieldDetailsManager.updateActiveInput(element);\n    if (!resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isCreditCardOrAddressFieldType(element)) {\n      return;\n    }\n    this._doIdentifyAutofillFields(element);\n  }\n\n  onSubmit(_event) {\n    if (!this.fieldDetailsManager.activeHandler) {\n      return;\n    }\n\n    this.fieldDetailsManager.activeHandler.onFormSubmitted();\n    const records = this.fieldDetailsManager.activeHandler.createRecords();\n\n    if (records.creditCard.length) {\n      // Normalize record format so we always get a consistent\n      // credit card record format: {cc-number, cc-name, cc-exp-month, cc-exp-year}\n      const creditCardRecords = records.creditCard.map(entry => {\n        resource_gre_modules_shared_CreditCardRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_2__.CreditCardRecord.normalizeFields(entry.record);\n        return entry.record;\n      });\n      this.callbacks.creditCard.submit(creditCardRecords);\n    }\n\n    // TODO(FXSP-133 Phase 3): Support address capture\n    // this.callbacks.address.submit();\n  }\n\n  fillFormFields(payload) {\n    // In iOS, we have access only to valid fields (https://github.com/mozilla/application-services/blob/9054db4bb5031881550ceab3448665ef6499a706/components/autofill/src/autofill.udl#L59-L76) for an address;\n    // all additional data must be computed. On Desktop, computed fields are handled in FormAutofillStorageBase.sys.mjs at the time of saving. Ideally, we should centralize\n    // all transformations, computations, and normalization processes within AddressRecord.sys.mjs to maintain a unified implementation across both platforms.\n    // This will be addressed in FXCM-810, aiming to simplify our data representation for both credit cards and addresses.\n    if (\n      resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isAddressField(\n        this.fieldDetailsManager.activeFieldDetail?.fieldName\n      )\n    ) {\n      resource_gre_modules_shared_AddressRecord_sys_mjs__WEBPACK_IMPORTED_MODULE_3__.AddressRecord.computeFields(payload);\n    }\n    this.fieldDetailsManager.activeHandler.autofillFormFields(payload);\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormAutofillChild);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs":
/*!************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillExtras\": () => (/* binding */ FormAutofillExtras),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nclass FormAutofillExtras {\n\n  isFocusable(element) {\n    let style = window.getComputedStyle(element);\n    return !(element.type === 'hidden' || element.offsetParent === null || style.visibility === 'hidden' || style.display === 'none' || style.opacity === '0' || element.hasAttribute('hidden'));\n  }\n\n  focusNextInputField() {\n    let inputFields = [...document.getElementsByTagName('input')];\n    inputFields = inputFields.filter(this.isFocusable);\n    const activeElement = document.activeElement;\n    const currentIndex = inputFields.indexOf(activeElement);\n    const inputFieldCount = inputFields.length - 1;\n\n    if (currentIndex < inputFieldCount) {\n      const nextField = inputFields[currentIndex + 1];\n      nextField.focus();\n    }\n  }\n\n  focusPreviousInputField() {\n    let inputFields = [...document.getElementsByTagName('input')];\n    inputFields = inputFields.filter(this.isFocusable);\n    const activeElement = document.activeElement;\n    const currentIndex = inputFields.indexOf(activeElement);\n\n    if (currentIndex > 0) {\n      const previousField = inputFields[currentIndex - 1];\n      previousField.focus();\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormAutofillExtras);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillHandler\": () => (/* binding */ FormAutofillHandler)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  FormAutofillAddressSection:\n    \"resource://gre/modules/shared/FormAutofillSection.sys.mjs\",\n  FormAutofillCreditCardSection:\n    \"resource://gre/modules/shared/FormAutofillSection.sys.mjs\",\n  FormAutofillHeuristics:\n    \"resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs\",\n  FormLikeFactory: \"resource://gre/modules/FormLikeFactory.sys.mjs\",\n  FormSection: \"resource://gre/modules/shared/FormAutofillHeuristics.sys.mjs\",\n});\n\nconst { FIELD_STATES } = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils;\n\n/**\n * Handles profile autofill for a DOM Form element.\n */\nclass FormAutofillHandler {\n  // The window to which this form belongs\n  window = null;\n\n  // A WindowUtils reference of which Window the form belongs\n  winUtils = null;\n\n  // DOM Form element to which this object is attached\n  form = null;\n\n  // An array of section that are found in this form\n  sections = [];\n\n  // The section contains the focused input\n  #focusedSection = null;\n\n  // Caches the element to section mapping\n  #cachedSectionByElement = new WeakMap();\n\n  // Keeps track of filled state for all identified elements\n  #filledStateByElement = new WeakMap();\n  /**\n   * Array of collected data about relevant form fields.  Each item is an object\n   * storing the identifying details of the field and a reference to the\n   * originally associated element from the form.\n   *\n   * The \"section\", \"addressType\", \"contactType\", and \"fieldName\" values are\n   * used to identify the exact field when the serializable data is received\n   * from the backend.  There cannot be multiple fields which have\n   * the same exact combination of these values.\n   *\n   * A direct reference to the associated element cannot be sent to the user\n   * interface because processing may be done in the parent process.\n   */\n  fieldDetails = null;\n\n  /**\n   * Initialize the form from `FormLike` object to handle the section or form\n   * operations.\n   *\n   * @param {FormLike} form Form that need to be auto filled\n   * @param {Function} onFormSubmitted Function that can be invoked\n   *                   to simulate form submission. Function is passed\n   *                   four arguments: (1) a FormLike for the form being\n   *                   submitted, (2) the reason for infering the form\n   *                   submission (3) the corresponding Window, and (4)\n   *                   the responsible FormAutofillHandler.\n   * @param {Function} onAutofillCallback Function that can be invoked\n   *                   when we want to suggest autofill on a form.\n   */\n  constructor(form, onFormSubmitted = () => {}, onAutofillCallback = () => {}) {\n    this._updateForm(form);\n\n    this.window = this.form.rootElement.ownerGlobal;\n    this.winUtils = this.window.windowUtils;\n\n    // Enum for form autofill MANUALLY_MANAGED_STATES values\n    this.FIELD_STATE_ENUM = {\n      // not themed\n      [FIELD_STATES.NORMAL]: null,\n      // highlighted\n      [FIELD_STATES.AUTO_FILLED]: \"autofill\",\n      // highlighted && grey color text\n      [FIELD_STATES.PREVIEW]: \"-moz-autofill-preview\",\n    };\n\n    /**\n     * This function is used if the form handler (or one of its sections)\n     * determines that it needs to act as if the form had been submitted.\n     */\n    this.onFormSubmitted = formSubmissionReason => {\n      onFormSubmitted(this.form, formSubmissionReason, this.window, this);\n    };\n\n    this.onAutofillCallback = onAutofillCallback;\n\n    ChromeUtils.defineLazyGetter(this, \"log\", () =>\n      resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.defineLogGetter(this, \"FormAutofillHandler\")\n    );\n  }\n\n  handleEvent(event) {\n    switch (event.type) {\n      case \"input\": {\n        if (!event.isTrusted) {\n          return;\n        }\n        const target = event.target;\n        const targetFieldDetail = this.getFieldDetailByElement(target);\n        const isCreditCardField = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofillUtils.isCreditCardField(\n          targetFieldDetail.fieldName\n        );\n\n        // If the user manually blanks a credit card field, then\n        // we want the popup to be activated.\n        if (\n          !HTMLSelectElement.isInstance(target) &&\n          isCreditCardField &&\n          target.value === \"\"\n        ) {\n          this.onAutofillCallback();\n        }\n\n        if (this.getFilledStateByElement(target) == FIELD_STATES.NORMAL) {\n          return;\n        }\n\n        this.changeFieldState(targetFieldDetail, FIELD_STATES.NORMAL);\n        const section = this.getSectionByElement(targetFieldDetail.element);\n        section?.clearFilled(targetFieldDetail);\n      }\n    }\n  }\n\n  set focusedInput(element) {\n    const section = this.getSectionByElement(element);\n    if (!section) {\n      return;\n    }\n\n    this.#focusedSection = section;\n    this.#focusedSection.focusedInput = element;\n  }\n\n  getSectionByElement(element) {\n    const section =\n      this.#cachedSectionByElement.get(element) ??\n      this.sections.find(s => s.getFieldDetailByElement(element));\n    if (!section) {\n      return null;\n    }\n\n    this.#cachedSectionByElement.set(element, section);\n    return section;\n  }\n\n  getFieldDetailByElement(element) {\n    for (const section of this.sections) {\n      const detail = section.getFieldDetailByElement(element);\n      if (detail) {\n        return detail;\n      }\n    }\n    return null;\n  }\n\n  get activeSection() {\n    return this.#focusedSection;\n  }\n\n  /**\n   * Check the form is necessary to be updated. This function should be able to\n   * detect any changes including all control elements in the form.\n   *\n   * @param {HTMLElement} element The element supposed to be in the form.\n   * @returns {boolean} FormAutofillHandler.form is updated or not.\n   */\n  updateFormIfNeeded(element) {\n    // When the following condition happens, FormAutofillHandler.form should be\n    // updated:\n    // * The count of form controls is changed.\n    // * When the element can not be found in the current form.\n    //\n    // However, we should improve the function to detect the element changes.\n    // e.g. a tel field is changed from type=\"hidden\" to type=\"tel\".\n\n    let _formLike;\n    const getFormLike = () => {\n      if (!_formLike) {\n        _formLike = lazy.FormLikeFactory.createFromField(element);\n      }\n      return _formLike;\n    };\n\n    const currentForm = element.form ?? getFormLike();\n    if (currentForm.elements.length != this.form.elements.length) {\n      this.log.debug(\"The count of form elements is changed.\");\n      this._updateForm(getFormLike());\n      return true;\n    }\n\n    if (!this.form.elements.includes(element)) {\n      this.log.debug(\"The element can not be found in the current form.\");\n      this._updateForm(getFormLike());\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Update the form with a new FormLike, and the related fields should be\n   * updated or clear to ensure the data consistency.\n   *\n   * @param {FormLike} form a new FormLike to replace the original one.\n   */\n  _updateForm(form) {\n    this.form = form;\n\n    this.fieldDetails = null;\n\n    this.sections = [];\n    this.#cachedSectionByElement = new WeakMap();\n  }\n\n  /**\n   * Set fieldDetails from the form about fields that can be autofilled.\n   *\n   * @returns {Array} The valid address and credit card details.\n   */\n  collectFormFields(ignoreInvalid = true) {\n    const sections = lazy.FormAutofillHeuristics.getFormInfo(this.form);\n    const allValidDetails = [];\n    for (const section of sections) {\n      // We don't support csc field, so remove csc fields from section\n      const fieldDetails = section.fieldDetails.filter(\n        f => ![\"cc-csc\"].includes(f.fieldName)\n      );\n      if (!fieldDetails.length) {\n        continue;\n      }\n\n      let autofillableSection;\n      if (section.type == lazy.FormSection.ADDRESS) {\n        autofillableSection = new lazy.FormAutofillAddressSection(\n          fieldDetails,\n          this\n        );\n      } else {\n        autofillableSection = new lazy.FormAutofillCreditCardSection(\n          fieldDetails,\n          this\n        );\n      }\n\n      // Do not include section that is either disabled or invalid.\n      // We only include invalid section for testing purpose.\n      if (\n        !autofillableSection.isEnabled() ||\n        (ignoreInvalid && !autofillableSection.isValidSection())\n      ) {\n        continue;\n      }\n\n      this.sections.push(autofillableSection);\n      allValidDetails.push(...autofillableSection.fieldDetails);\n    }\n\n    this.fieldDetails = allValidDetails;\n    return allValidDetails;\n  }\n\n  #hasFilledSection() {\n    return this.sections.some(section => section.isFilled());\n  }\n\n  getFilledStateByElement(element) {\n    return this.#filledStateByElement.get(element);\n  }\n\n  /**\n   * Change the state of a field to correspond with different presentations.\n   *\n   * @param {object} fieldDetail\n   *        A fieldDetail of which its element is about to update the state.\n   * @param {string} nextState\n   *        Used to determine the next state\n   */\n  changeFieldState(fieldDetail, nextState) {\n    const element = fieldDetail.element;\n    if (!element) {\n      this.log.warn(\n        fieldDetail.fieldName,\n        \"is unreachable while changing state\"\n      );\n      return;\n    }\n    if (!(nextState in this.FIELD_STATE_ENUM)) {\n      this.log.warn(\n        fieldDetail.fieldName,\n        \"is trying to change to an invalid state\"\n      );\n      return;\n    }\n\n    if (this.#filledStateByElement.get(element) == nextState) {\n      return;\n    }\n\n    let nextStateValue = null;\n    for (const [state, mmStateValue] of Object.entries(this.FIELD_STATE_ENUM)) {\n      // The NORMAL state is simply the absence of other manually\n      // managed states so we never need to add or remove it.\n      if (!mmStateValue) {\n        continue;\n      }\n\n      if (state == nextState) {\n        nextStateValue = mmStateValue;\n      } else {\n        this.winUtils.removeManuallyManagedState(element, mmStateValue);\n      }\n    }\n\n    if (nextStateValue) {\n      this.winUtils.addManuallyManagedState(element, nextStateValue);\n    }\n\n    if (nextState == FIELD_STATES.AUTO_FILLED) {\n      element.addEventListener(\"input\", this, { mozSystemGroup: true });\n    }\n\n    this.#filledStateByElement.set(element, nextState);\n  }\n\n  /**\n   * Processes form fields that can be autofilled, and populates them with the\n   * profile provided by backend.\n   *\n   * @param {object} profile\n   *        A profile to be filled in.\n   */\n  async autofillFormFields(profile) {\n    const noFilledSectionsPreviously = !this.#hasFilledSection();\n    await this.activeSection.autofillFields(profile);\n\n    const onChangeHandler = e => {\n      if (!e.isTrusted) {\n        return;\n      }\n      if (e.type == \"reset\") {\n        this.sections.map(section => section.resetFieldStates());\n      }\n      // Unregister listeners once no field is in AUTO_FILLED state.\n      if (!this.#hasFilledSection()) {\n        this.form.rootElement.removeEventListener(\"input\", onChangeHandler, {\n          mozSystemGroup: true,\n        });\n        this.form.rootElement.removeEventListener(\"reset\", onChangeHandler, {\n          mozSystemGroup: true,\n        });\n      }\n    };\n\n    if (noFilledSectionsPreviously) {\n      // Handle the highlight style resetting caused by user's correction afterward.\n      this.log.debug(\"register change handler for filled form:\", this.form);\n      this.form.rootElement.addEventListener(\"input\", onChangeHandler, {\n        mozSystemGroup: true,\n      });\n      this.form.rootElement.addEventListener(\"reset\", onChangeHandler, {\n        mozSystemGroup: true,\n      });\n    }\n  }\n\n  /**\n   * Collect the filled sections within submitted form and convert all the valid\n   * field data into multiple records.\n   *\n   * @returns {object} records\n   *          {Array.<Object>} records.address\n   *          {Array.<Object>} records.creditCard\n   */\n  createRecords() {\n    const records = {\n      address: [],\n      creditCard: [],\n    };\n\n    for (const section of this.sections) {\n      const secRecord = section.createRecord();\n      if (!secRecord) {\n        continue;\n      }\n      if (section instanceof lazy.FormAutofillAddressSection) {\n        records.address.push(secRecord);\n      } else if (section instanceof lazy.FormAutofillCreditCardSection) {\n        records.creditCard.push(secRecord);\n      } else {\n        throw new Error(\"Unknown section type\");\n      }\n    }\n\n    return records;\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs":
/*!****************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillHeuristics\": () => (/* binding */ FormAutofillHeuristics),\n/* harmony export */   \"FormSection\": () => (/* binding */ FormSection),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* harmony import */ var resource_gre_modules_shared_HeuristicsRegExp_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/HeuristicsRegExp.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  CreditCard: \"resource://gre/modules/CreditCard.sys.mjs\",\n  CreditCardRulesets: \"resource://gre/modules/shared/CreditCardRuleset.sys.mjs\",\n  FieldScanner: \"resource://gre/modules/shared/FieldScanner.sys.mjs\",\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n  LabelUtils: \"resource://gre/modules/shared/LabelUtils.sys.mjs\",\n});\n\n/**\n * To help us classify sections, we want to know what fields can appear\n * multiple times in a row.\n * Such fields, like `address-line{X}`, should not break sections.\n */\nconst MULTI_FIELD_NAMES = [\n  \"address-level3\",\n  \"address-level2\",\n  \"address-level1\",\n  \"tel\",\n  \"postal-code\",\n  \"email\",\n  \"street-address\",\n];\n\n/**\n * To help us classify sections that can appear only N times in a row.\n * For example, the only time multiple cc-number fields are valid is when\n * there are four of these fields in a row.\n * Otherwise, multiple cc-number fields should be in separate sections.\n */\nconst MULTI_N_FIELD_NAMES = {\n  \"cc-number\": 4,\n};\n\nclass FormSection {\n  static ADDRESS = \"address\";\n  static CREDIT_CARD = \"creditCard\";\n\n  #fieldDetails = [];\n\n  #name = \"\";\n\n  constructor(fieldDetails) {\n    if (!fieldDetails.length) {\n      throw new TypeError(\"A section should contain at least one field\");\n    }\n\n    fieldDetails.forEach(field => this.addField(field));\n\n    const fieldName = fieldDetails[0].fieldName;\n    if (lazy.FormAutofillUtils.isAddressField(fieldName)) {\n      this.type = FormSection.ADDRESS;\n    } else if (lazy.FormAutofillUtils.isCreditCardField(fieldName)) {\n      this.type = FormSection.CREDIT_CARD;\n    } else {\n      throw new Error(\"Unknown field type to create a section.\");\n    }\n  }\n\n  get fieldDetails() {\n    return this.#fieldDetails;\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  addField(fieldDetail) {\n    this.#name ||= fieldDetail.sectionName;\n    this.#fieldDetails.push(fieldDetail);\n  }\n}\n\n/**\n * Returns the autocomplete information of fields according to heuristics.\n */\nconst FormAutofillHeuristics = {\n  RULES: resource_gre_modules_shared_HeuristicsRegExp_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.HeuristicsRegExp.getRules(),\n  LABEL_RULES: resource_gre_modules_shared_HeuristicsRegExp_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.HeuristicsRegExp.getLabelRules(),\n\n  CREDIT_CARD_FIELDNAMES: [],\n  ADDRESS_FIELDNAMES: [],\n  /**\n   * Try to find a contiguous sub-array within an array.\n   *\n   * @param {Array} array\n   * @param {Array} subArray\n   *\n   * @returns {boolean}\n   *          Return whether subArray was found within the array or not.\n   */\n  _matchContiguousSubArray(array, subArray) {\n    return array.some((elm, i) =>\n      subArray.every((sElem, j) => sElem == array[i + j])\n    );\n  },\n\n  /**\n   * Try to find the field that is look like a month select.\n   *\n   * @param {DOMElement} element\n   * @returns {boolean}\n   *          Return true if we observe the trait of month select in\n   *          the current element.\n   */\n  _isExpirationMonthLikely(element) {\n    if (!HTMLSelectElement.isInstance(element)) {\n      return false;\n    }\n\n    const options = [...element.options];\n    const desiredValues = Array(12)\n      .fill(1)\n      .map((v, i) => v + i);\n\n    // The number of month options shouldn't be less than 12 or larger than 13\n    // including the default option.\n    if (options.length < 12 || options.length > 13) {\n      return false;\n    }\n\n    return (\n      this._matchContiguousSubArray(\n        options.map(e => +e.value),\n        desiredValues\n      ) ||\n      this._matchContiguousSubArray(\n        options.map(e => +e.label),\n        desiredValues\n      )\n    );\n  },\n\n  /**\n   * Try to find the field that is look like a year select.\n   *\n   * @param {DOMElement} element\n   * @returns {boolean}\n   *          Return true if we observe the trait of year select in\n   *          the current element.\n   */\n  _isExpirationYearLikely(element) {\n    if (!HTMLSelectElement.isInstance(element)) {\n      return false;\n    }\n\n    const options = [...element.options];\n    // A normal expiration year select should contain at least the last three years\n    // in the list.\n    const curYear = new Date().getFullYear();\n    const desiredValues = Array(3)\n      .fill(0)\n      .map((v, i) => v + curYear + i);\n\n    return (\n      this._matchContiguousSubArray(\n        options.map(e => +e.value),\n        desiredValues\n      ) ||\n      this._matchContiguousSubArray(\n        options.map(e => +e.label),\n        desiredValues\n      )\n    );\n  },\n\n  /**\n   * Try to match the telephone related fields to the grammar\n   * list to see if there is any valid telephone set and correct their\n   * field names.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parsePhoneFields(scanner, _fieldDetail) {\n    let matchingResult;\n    const GRAMMARS = this.PHONE_FIELD_GRAMMARS;\n\n    function isGrammarSeparator(index) {\n      return !GRAMMARS[index][0];\n    }\n\n    const savedIndex = scanner.parsingIndex;\n    for (let ruleFrom = 0; ruleFrom < GRAMMARS.length; ) {\n      const detailStart = scanner.parsingIndex;\n      let ruleTo = ruleFrom;\n      for (let count = 0; ruleTo < GRAMMARS.length; ruleTo++, count++) {\n        // Bail out when reaching the end of the current set of grammars\n        // or there are no more elements to parse\n        if (\n          isGrammarSeparator(ruleTo) ||\n          !scanner.elementExisting(detailStart + count)\n        ) {\n          break;\n        }\n\n        const [category, , length] = GRAMMARS[ruleTo];\n        const detail = scanner.getFieldDetailByIndex(detailStart + count);\n\n        // If the field is not what this grammar rule is interested in, skip processing.\n        if (\n          !detail ||\n          detail.fieldName != category ||\n          detail.reason == \"autocomplete\"\n        ) {\n          break;\n        }\n\n        const element = detail.element;\n        if (length && (!element.maxLength || length < element.maxLength)) {\n          break;\n        }\n      }\n\n      // if we reach the grammar separator, that means all the previous rules are matched.\n      // Set the matchingResult so we update field names accordingly.\n      if (isGrammarSeparator(ruleTo)) {\n        matchingResult = { ruleFrom, ruleTo };\n        break;\n      }\n\n      // Fast forward to the next rule set.\n      for (; ruleFrom < GRAMMARS.length; ) {\n        if (isGrammarSeparator(ruleFrom++)) {\n          break;\n        }\n      }\n    }\n\n    if (matchingResult) {\n      const { ruleFrom, ruleTo } = matchingResult;\n      for (let i = ruleFrom; i < ruleTo; i++) {\n        scanner.updateFieldName(scanner.parsingIndex, GRAMMARS[i][1]);\n        scanner.parsingIndex++;\n      }\n    }\n\n    // If the previous parsed field is a \"tel\" field, run heuristic to see\n    // if the current field is a \"tel-extension\" field\n    const field = scanner.getFieldDetailByIndex(scanner.parsingIndex);\n    if (field && field.reason != \"autocomplete\") {\n      const prev = scanner.getFieldDetailByIndex(scanner.parsingIndex - 1);\n      if (\n        prev &&\n        lazy.FormAutofillUtils.getCategoryFromFieldName(prev.fieldName) == \"tel\"\n      ) {\n        const regExpTelExtension = new RegExp(\n          \"\\\\bext|ext\\\\b|extension|ramal\", // pt-BR, pt-PT\n          \"iug\"\n        );\n        if (this._matchRegexp(field.element, regExpTelExtension)) {\n          scanner.updateFieldName(scanner.parsingIndex, \"tel-extension\");\n          scanner.parsingIndex++;\n        }\n      }\n    }\n    return savedIndex != scanner.parsingIndex;\n  },\n\n  /**\n   * Try to find the correct address-line[1-3] sequence and correct their field\n   * names.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parseStreetAddressFields(scanner, _fieldDetail) {\n    const INTERESTED_FIELDS = [\n      \"street-address\",\n      \"address-line1\",\n      \"address-line2\",\n      \"address-line3\",\n    ];\n\n    const fields = [];\n    for (let idx = scanner.parsingIndex; !scanner.parsingFinished; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n    }\n\n    if (!fields.length) {\n      return false;\n    }\n\n    switch (fields.length) {\n      case 1:\n        if (\n          fields[0].reason != \"autocomplete\" &&\n          [\"address-line2\", \"address-line3\"].includes(fields[0].fieldName)\n        ) {\n          scanner.updateFieldName(scanner.parsingIndex, \"address-line1\");\n        }\n        break;\n      case 2:\n        if (fields[0].reason == \"autocomplete\") {\n          if (\n            fields[0].fieldName == \"street-address\" &&\n            (fields[1].fieldName == \"address-line2\" ||\n              fields[1].reason != \"autocomplete\")\n          ) {\n            scanner.updateFieldName(\n              scanner.parsingIndex,\n              \"address-line1\",\n              true\n            );\n          }\n        } else {\n          scanner.updateFieldName(scanner.parsingIndex, \"address-line1\");\n        }\n\n        scanner.updateFieldName(scanner.parsingIndex + 1, \"address-line2\");\n        break;\n      case 3:\n      default:\n        scanner.updateFieldName(scanner.parsingIndex, \"address-line1\");\n        scanner.updateFieldName(scanner.parsingIndex + 1, \"address-line2\");\n        scanner.updateFieldName(scanner.parsingIndex + 2, \"address-line3\");\n        break;\n    }\n\n    scanner.parsingIndex += fields.length;\n    return true;\n  },\n\n  _parseAddressFields(scanner, fieldDetail) {\n    const INTERESTED_FIELDS = [\"address-level1\", \"address-level2\"];\n\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fields = [];\n    for (let idx = scanner.parsingIndex; !scanner.parsingFinished; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n    }\n\n    if (!fields.length) {\n      return false;\n    }\n\n    // State & City(address-level2)\n    if (fields.length == 1) {\n      if (fields[0].fieldName == \"address-level2\") {\n        const prev = scanner.getFieldDetailByIndex(scanner.parsingIndex - 1);\n        if (\n          prev &&\n          !prev.fieldName &&\n          HTMLSelectElement.isInstance(prev.element)\n        ) {\n          scanner.updateFieldName(scanner.parsingIndex - 1, \"address-level1\");\n          scanner.parsingIndex += 1;\n          return true;\n        }\n        const next = scanner.getFieldDetailByIndex(scanner.parsingIndex + 1);\n        if (\n          next &&\n          !next.fieldName &&\n          HTMLSelectElement.isInstance(next.element)\n        ) {\n          scanner.updateFieldName(scanner.parsingIndex + 1, \"address-level1\");\n          scanner.parsingIndex += 2;\n          return true;\n        }\n      }\n    }\n\n    scanner.parsingIndex += fields.length;\n    return true;\n  },\n\n  /**\n   * Try to look for expiration date fields and revise the field names if needed.\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parseCreditCardExpiryFields(scanner, fieldDetail) {\n    const INTERESTED_FIELDS = [\"cc-exp\", \"cc-exp-month\", \"cc-exp-year\"];\n\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fields = [];\n    for (let idx = scanner.parsingIndex; ; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n    }\n\n    // Don't process the fields if expiration month and expiration year are already\n    // matched by regex in correct order.\n    if (\n      (fields.length == 1 && fields[0].fieldName == \"cc-exp\") ||\n      (fields.length == 2 &&\n        fields[0].fieldName == \"cc-exp-month\" &&\n        fields[1].fieldName == \"cc-exp-year\")\n    ) {\n      scanner.parsingIndex += fields.length;\n      return true;\n    }\n\n    const prevCCFields = new Set();\n    for (let idx = scanner.parsingIndex - 1; ; idx--) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\n        \"creditCard\"\n      ) {\n        break;\n      }\n      prevCCFields.add(detail.fieldName);\n    }\n    // We update the \"cc-exp-*\" fields to correct \"cc-ex-*\" fields order when\n    // the following conditions are met:\n    // 1. The previous elements are identified as credit card fields and\n    //    cc-number is in it\n    // 2. There is no \"cc-exp-*\" fields in the previous credit card elements\n    if (\n      [\"cc-number\", \"cc-name\"].some(f => prevCCFields.has(f)) &&\n      ![\"cc-exp\", \"cc-exp-month\", \"cc-exp-year\"].some(f => prevCCFields.has(f))\n    ) {\n      if (fields.length == 1) {\n        scanner.updateFieldName(scanner.parsingIndex, \"cc-exp\");\n      } else if (fields.length == 2) {\n        scanner.updateFieldName(scanner.parsingIndex, \"cc-exp-month\");\n        scanner.updateFieldName(scanner.parsingIndex + 1, \"cc-exp-year\");\n      }\n      scanner.parsingIndex += fields.length;\n      return true;\n    }\n\n    // Set field name to null as it failed to match any patterns.\n    for (let idx = 0; idx < fields.length; idx++) {\n      scanner.updateFieldName(scanner.parsingIndex + idx, null);\n    }\n    return false;\n  },\n\n  /**\n   * Look for cc-*-name fields when *-name field is present\n   *\n   * @param {FieldScanner} scanner\n   *        The current parsing status for all elements\n   * @returns {boolean}\n   *          Return true if there is any field can be recognized in the parser,\n   *          otherwise false.\n   */\n  _parseCreditCardNameFields(scanner, fieldDetail) {\n    const INTERESTED_FIELDS = [\n      \"name\",\n      \"given-name\",\n      \"additional-name\",\n      \"family-name\",\n    ];\n\n    if (!INTERESTED_FIELDS.includes(fieldDetail.fieldName)) {\n      return false;\n    }\n\n    const fields = [];\n    for (let idx = scanner.parsingIndex; ; idx++) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (!INTERESTED_FIELDS.includes(detail?.fieldName)) {\n        break;\n      }\n      fields.push(detail);\n    }\n\n    const prevCCFields = new Set();\n    for (let idx = scanner.parsingIndex - 1; ; idx--) {\n      const detail = scanner.getFieldDetailByIndex(idx);\n      if (\n        lazy.FormAutofillUtils.getCategoryFromFieldName(detail?.fieldName) !=\n        \"creditCard\"\n      ) {\n        break;\n      }\n      prevCCFields.add(detail.fieldName);\n    }\n\n    // We update the \"name\" fields to \"cc-name\" fields when the following\n    // conditions are met:\n    // 1. The preceding fields are identified as credit card fields and\n    //    contain the \"cc-number\" field.\n    // 2. No \"cc-name-*\" field is found among the preceding credit card fields.\n    // 3. The \"cc-csc\" field is not present among the preceding credit card fields.\n    if (\n      [\"cc-number\"].some(f => prevCCFields.has(f)) &&\n      ![\"cc-name\", \"cc-given-name\", \"cc-family-name\", \"cc-csc\"].some(f =>\n        prevCCFields.has(f)\n      )\n    ) {\n      // If there is only one field, assume the name field a `cc-name` field\n      if (fields.length == 1) {\n        scanner.updateFieldName(scanner.parsingIndex, `cc-name`);\n        scanner.parsingIndex += 1;\n      } else {\n        // update *-name to cc-*-name\n        for (const field of fields) {\n          scanner.updateFieldName(\n            scanner.parsingIndex,\n            `cc-${field.fieldName}`\n          );\n          scanner.parsingIndex += 1;\n        }\n      }\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * This function should provide all field details of a form which are placed\n   * in the belonging section. The details contain the autocomplete info\n   * (e.g. fieldName, section, etc).\n   *\n   * @param {HTMLFormElement} form\n   *        the elements in this form to be predicted the field info.\n   * @returns {Array<FormSection>}\n   *        all sections within its field details in the form.\n   */\n  getFormInfo(form) {\n    const elements = Array.from(form.elements).filter(element =>\n      lazy.FormAutofillUtils.isCreditCardOrAddressFieldType(element)\n    );\n\n    const scanner = new lazy.FieldScanner(elements, element =>\n      this.inferFieldInfo(element, elements)\n    );\n\n    while (!scanner.parsingFinished) {\n      const savedIndex = scanner.parsingIndex;\n\n      // First, we get the inferred field info\n      const fieldDetail = scanner.getFieldDetailByIndex(scanner.parsingIndex);\n\n      if (\n        this._parsePhoneFields(scanner, fieldDetail) ||\n        this._parseStreetAddressFields(scanner, fieldDetail) ||\n        this._parseAddressFields(scanner, fieldDetail) ||\n        this._parseCreditCardExpiryFields(scanner, fieldDetail) ||\n        this._parseCreditCardNameFields(scanner, fieldDetail)\n      ) {\n        continue;\n      }\n\n      // If there is no field parsed, the parsing cursor can be moved\n      // forward to the next one.\n      if (savedIndex == scanner.parsingIndex) {\n        scanner.parsingIndex++;\n      }\n    }\n\n    lazy.LabelUtils.clearLabelMap();\n\n    const fields = scanner.fieldDetails;\n    const sections = [\n      ...this._classifySections(\n        fields.filter(f => lazy.FormAutofillUtils.isAddressField(f.fieldName))\n      ),\n      ...this._classifySections(\n        fields.filter(f =>\n          lazy.FormAutofillUtils.isCreditCardField(f.fieldName)\n        )\n      ),\n    ];\n\n    return sections.sort(\n      (a, b) =>\n        fields.indexOf(a.fieldDetails[0]) - fields.indexOf(b.fieldDetails[0])\n    );\n  },\n\n  /**\n   * The result is an array contains the sections with its belonging field details.\n   *\n   * @param   {Array<FieldDetails>} fieldDetails field detail array to be classified\n   * @returns {Array<FormSection>} The array with the sections.\n   */\n  _classifySections(fieldDetails) {\n    let sections = [];\n    for (let i = 0; i < fieldDetails.length; i++) {\n      const cur = fieldDetails[i];\n      const [currentSection] = sections.slice(-1);\n\n      // The section this field might be placed into.\n      let candidateSection = null;\n\n      // Use name group from autocomplete attribute (ex, section-xxx) to look for the section\n      // we might place this field into.\n      // If the field doesn't have a section name, the candidate section is the previous section.\n      if (!currentSection || !cur.sectionName) {\n        candidateSection = currentSection;\n      } else if (cur.sectionName) {\n        // If the field has a section name, the candidate section is the nearest section that\n        // either shares the same name or lacks a name.\n        for (let idx = sections.length - 1; idx >= 0; idx--) {\n          if (!sections[idx].name || sections[idx].name == cur.sectionName) {\n            candidateSection = sections[idx];\n            break;\n          }\n        }\n      }\n\n      if (candidateSection) {\n        let createNewSection = true;\n\n        // We might create a new section instead of placing the field in the candiate section if\n        // the section already has a field with the same field name.\n        // We also check visibility for both the fields with the same field name because we don't\n        // wanht to create a new section for an invisible field.\n        if (\n          candidateSection.fieldDetails.find(\n            f => f.fieldName == cur.fieldName && f.isVisible && cur.isVisible\n          )\n        ) {\n          // For some field type, it is common to have multiple fields in one section, for example,\n          // email. In that case, we will not create a new section even when the candidate section\n          // already has a field with the same field name.\n          const [lastFieldDetail] = candidateSection.fieldDetails.slice(-1);\n          if (lastFieldDetail.fieldName == cur.fieldName) {\n            if (MULTI_FIELD_NAMES.includes(cur.fieldName)) {\n              createNewSection = false;\n            } else if (cur.fieldName in MULTI_N_FIELD_NAMES) {\n              // This is the heuristic to handle special cases where we can have multiple\n              // fields in one section, but only if the field has appeared N times in a row.\n              // For example, websites can use 4 consecutive 4-digit `cc-number` fields\n              // instead of one 16-digit `cc-number` field.\n\n              const N = MULTI_N_FIELD_NAMES[cur.fieldName];\n              if (lastFieldDetail.part) {\n                // If `part` is set, we have already identified this field can be\n                // merged previously\n                if (lastFieldDetail.part < N) {\n                  createNewSection = false;\n                  fieldDetails[i].part = lastFieldDetail.part + 1;\n                }\n                // If the next N fields are all the same field, we can merge them\n              } else if (\n                N == 2 ||\n                fieldDetails\n                  .slice(i + 1, i + N - 1)\n                  .every(f => f.fieldName == cur.fieldName)\n              ) {\n                lastFieldDetail.part = 1;\n                fieldDetails[i].part = 2;\n                createNewSection = false;\n              }\n            }\n          }\n        } else {\n          // The field doesn't exist in the candidate section, add it.\n          createNewSection = false;\n        }\n\n        if (!createNewSection) {\n          candidateSection.addField(fieldDetails[i]);\n          continue;\n        }\n      }\n\n      // Create a new section\n      sections.push(new FormSection([fieldDetails[i]]));\n    }\n\n    return sections;\n  },\n\n  _getPossibleFieldNames(element) {\n    let fieldNames = [];\n    const isAutoCompleteOff =\n      element.autocomplete == \"off\" || element.form?.autocomplete == \"off\";\n    if (!isAutoCompleteOff || resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.creditCardsAutocompleteOff) {\n      fieldNames.push(...this.CREDIT_CARD_FIELDNAMES);\n    }\n    if (!isAutoCompleteOff || resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.addressesAutocompleteOff) {\n      fieldNames.push(...this.ADDRESS_FIELDNAMES);\n    }\n\n    if (HTMLSelectElement.isInstance(element)) {\n      const FIELDNAMES_FOR_SELECT_ELEMENT = [\n        \"address-level1\",\n        \"address-level2\",\n        \"country\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-exp\",\n        \"cc-type\",\n      ];\n      fieldNames = fieldNames.filter(name =>\n        FIELDNAMES_FOR_SELECT_ELEMENT.includes(name)\n      );\n    }\n\n    return fieldNames;\n  },\n\n  /**\n   * Get inferred information about an input element using autocomplete info, fathom and regex-based heuristics.\n   *\n   * @param {HTMLElement} element - The input element to infer information about.\n   * @param {Array<HTMLElement>} elements - See `getFathomField` for details\n   * @returns {Array} - An array containing:\n   *                    [0]the inferred field name\n   *                    [1]autocomplete information if the element has autocompelte attribute, null otherwise.\n   *                    [2]fathom confidence if fathom considers it a cc field, null otherwise.\n   */\n  inferFieldInfo(element, elements = []) {\n    const autocompleteInfo = element.getAutocompleteInfo();\n\n    // An input[autocomplete=\"on\"] will not be early return here since it stll\n    // needs to find the field name.\n    if (\n      autocompleteInfo?.fieldName &&\n      ![\"on\", \"off\"].includes(autocompleteInfo.fieldName)\n    ) {\n      return [autocompleteInfo.fieldName, autocompleteInfo, null];\n    }\n\n    const fields = this._getPossibleFieldNames(element);\n\n    // \"email\" type of input is accurate for heuristics to determine its Email\n    // field or not. However, \"tel\" type is used for ZIP code for some web site\n    // (e.g. HomeDepot, BestBuy), so \"tel\" type should be not used for \"tel\"\n    // prediction.\n    if (element.type == \"email\" && fields.includes(\"email\")) {\n      return [\"email\", null, null];\n    }\n\n    if (lazy.FormAutofillUtils.isFathomCreditCardsEnabled()) {\n      // We don't care fields that are not supported by fathom\n      const fathomFields = fields.filter(r =>\n        lazy.CreditCardRulesets.types.includes(r)\n      );\n      const [matchedFieldName, confidence] = this.getFathomField(\n        element,\n        fathomFields,\n        elements\n      );\n      // At this point, use fathom's recommendation if it has one\n      if (matchedFieldName) {\n        return [matchedFieldName, null, confidence];\n      }\n\n      // Continue to run regex-based heuristics even when fathom doesn't recognize\n      // the field. Since the regex-based heuristic has good search coverage but\n      // has a worse precision. We use it in conjunction with fathom to maximize\n      // our search coverage. For example, when a <input> is not considered cc-name\n      // by fathom but is considered cc-name by regex-based heuristic, if the form\n      // also contains a cc-number identified by fathom, we will treat the form as a\n      // valid cc form; hence both cc-number & cc-name are identified.\n    }\n\n    // Check every select for options that\n    // match credit card network names in value or label.\n    if (HTMLSelectElement.isInstance(element)) {\n      if (this._isExpirationMonthLikely(element)) {\n        return [\"cc-exp-month\", null, null];\n      } else if (this._isExpirationYearLikely(element)) {\n        return [\"cc-exp-year\", null, null];\n      }\n\n      const options = Array.from(element.querySelectorAll(\"option\"));\n      if (\n        options.find(\n          option =>\n            lazy.CreditCard.getNetworkFromName(option.value) ||\n            lazy.CreditCard.getNetworkFromName(option.text)\n        )\n      ) {\n        return [\"cc-type\", null, null];\n      }\n\n      // At least two options match the country name, otherwise some state name might\n      // also match a country name, ex, Georgia. We check the last two\n      // options rather than the first, as selects often start with a non-country display option.\n      const countryDisplayNames = Array.from(resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries.values());\n      if (\n        options.length >= 2 &&\n        options\n          .slice(-2)\n          .every(\n            option =>\n              countryDisplayNames.includes(option.value) ||\n              countryDisplayNames.includes(option.text)\n          )\n      ) {\n        return [\"country\", null, null];\n      }\n    }\n\n    // Find a matched field name using regexp-based heuristics\n    const matchedFieldName = this._findMatchedFieldName(element, fields);\n    return [matchedFieldName, null, null];\n  },\n\n  /**\n   * Using Fathom, say what kind of CC field an element is most likely to be.\n   * This function deoesn't only run fathom on the passed elements. It also\n   * runs fathom for all elements in the FieldScanner for optimization purpose.\n   *\n   * @param {HTMLElement} element\n   * @param {Array} fields\n   * @param {Array<HTMLElement>} elements - All other eligible elements in the same form. This is mainly used as an\n   *                                        optimization approach to run fathom model on all eligible elements\n   *                                        once instead of one by one\n   * @returns {Array} A tuple of [field name, probability] describing the\n   *   highest-confidence classification\n   */\n  getFathomField(element, fields, elements = []) {\n    if (!fields.length) {\n      return [null, null];\n    }\n\n    if (!this._fathomConfidences?.get(element)) {\n      this._fathomConfidences = new Map();\n\n      // This should not throw unless we run into an OOM situation, at which\n      // point we have worse problems and this failing is not a big deal.\n      elements = elements.includes(element) ? elements : [element];\n      const confidences = this.getFormAutofillConfidences(elements);\n\n      for (let i = 0; i < elements.length; i++) {\n        this._fathomConfidences.set(elements[i], confidences[i]);\n      }\n    }\n\n    const elementConfidences = this._fathomConfidences.get(element);\n    if (!elementConfidences) {\n      return [null, null];\n    }\n\n    let highestField = null;\n    let highestConfidence = lazy.FormAutofillUtils.ccFathomConfidenceThreshold; // Start with a threshold of 0.5\n    for (let [key, value] of Object.entries(elementConfidences)) {\n      if (!fields.includes(key)) {\n        // ignore field that we don't care\n        continue;\n      }\n\n      if (value > highestConfidence) {\n        highestConfidence = value;\n        highestField = key;\n      }\n    }\n\n    if (!highestField) {\n      return [null, null];\n    }\n\n    // Used by test ONLY! This ensure testcases always get the same confidence\n    if (lazy.FormAutofillUtils.ccFathomTestConfidence > 0) {\n      highestConfidence = lazy.FormAutofillUtils.ccFathomTestConfidence;\n    }\n\n    return [highestField, highestConfidence];\n  },\n\n  /**\n   * @param {Array} elements Array of elements that we want to get result from fathom cc rules\n   * @returns {object} Fathom confidence keyed by field-type.\n   */\n  getFormAutofillConfidences(elements) {\n    if (\n      lazy.FormAutofillUtils.ccHeuristicsMode ==\n      lazy.FormAutofillUtils.CC_FATHOM_NATIVE\n    ) {\n      const confidences = ChromeUtils.getFormAutofillConfidences(elements);\n      return confidences.map(c => {\n        let result = {};\n        for (let [fieldName, confidence] of Object.entries(c)) {\n          let type =\n            lazy.FormAutofillUtils.formAutofillConfidencesKeyToCCFieldType(\n              fieldName\n            );\n          result[type] = confidence;\n        }\n        return result;\n      });\n    }\n\n    return elements.map(element => {\n      /**\n       * Return how confident our ML model is that `element` is a field of the\n       * given type.\n       *\n       * @param {string} fieldName The Fathom type to check against. This is\n       *   conveniently the same as the autocomplete attribute value that means\n       *   the same thing.\n       * @returns {number} Confidence in range [0, 1]\n       */\n      function confidence(fieldName) {\n        const ruleset = lazy.CreditCardRulesets[fieldName];\n        const fnodes = ruleset.against(element).get(fieldName);\n\n        // fnodes is either 0 or 1 item long, since we ran the ruleset\n        // against a single element:\n        return fnodes.length ? fnodes[0].scoreFor(fieldName) : 0;\n      }\n\n      // Bang the element against the ruleset for every type of field:\n      const confidences = {};\n      lazy.CreditCardRulesets.types.map(fieldName => {\n        confidences[fieldName] = confidence(fieldName);\n      });\n\n      return confidences;\n    });\n  },\n\n  /**\n   * @typedef ElementStrings\n   * @type {object}\n   * @yields {string} id - element id.\n   * @yields {string} name - element name.\n   * @yields {Array<string>} labels - extracted labels.\n   */\n\n  /**\n   * Extract all the signature strings of an element.\n   *\n   * @param {HTMLElement} element\n   * @returns {Array<string>}\n   */\n  _getElementStrings(element) {\n    return [element.id, element.name, element.placeholder?.trim()];\n  },\n\n  /**\n   * Extract all the label strings associated with an element.\n   *\n   * @param {HTMLElement} element\n   * @returns {ElementStrings}\n   */\n  _getElementLabelStrings(element) {\n    return {\n      *[Symbol.iterator]() {\n        const labels = lazy.LabelUtils.findLabelElements(element);\n        for (let label of labels) {\n          yield* lazy.LabelUtils.extractLabelStrings(label);\n        }\n\n        const ariaLabels = element.getAttribute(\"aria-label\");\n        if (ariaLabels) {\n          yield* [ariaLabels];\n        }\n      },\n    };\n  },\n\n  // In order to support webkit we need to avoid usage of negative lookbehind due to low support\n  // First safari version with support is 16.4 (Release Date: 27th March 2023)\n  // https://caniuse.com/js-regexp-lookbehind\n  // We can mimic the behaviour of negative lookbehinds by using a named capture group\n  // (?<!not)word -> (?<neg>notword)|word\n  // TODO: Bug 1829583\n  testRegex(regex, string) {\n    const matches = string?.matchAll(regex);\n    if (!matches) {\n      return false;\n    }\n\n    const excludeNegativeCaptureGroups = [];\n\n    for (const match of matches) {\n      excludeNegativeCaptureGroups.push(\n        ...match.filter(m => m !== match?.groups?.neg).filter(Boolean)\n      );\n    }\n    return excludeNegativeCaptureGroups?.length > 0;\n  },\n\n  /**\n   * Find the first matching field name from a given list of field names\n   * that matches an HTML element.\n   *\n   * The function first tries to match the element against a set of\n   * pre-defined regular expression rules. If no match is found, it\n   * then checks for label-specific rules, if they exist.\n   *\n   * Note: For label rules, the keyword is often more general\n   * (e.g., \"^\\\\W*address\"), hence they are only searched within labels\n   * to reduce the occurrence of false positives.\n   *\n   * @param {HTMLElement} element The element to match.\n   * @param {Array<string>} fieldNames An array of field names to compare against.\n   * @returns {string|null} The name of the matched field, or null if no match was found.\n   */\n  _findMatchedFieldName(element, fieldNames) {\n    if (!fieldNames.length) {\n      return null;\n    }\n\n    // Attempt to match the element against the default set of rules\n    let matchedFieldName = fieldNames.find(fieldName =>\n      this._matchRegexp(element, this.RULES[fieldName])\n    );\n\n    // If no match is found, and if a label rule exists for the field,\n    // attempt to match against the label rules\n    if (!matchedFieldName) {\n      matchedFieldName = fieldNames.find(fieldName => {\n        const regexp = this.LABEL_RULES[fieldName];\n        return this._matchRegexp(element, regexp, { attribute: false });\n      });\n    }\n    return matchedFieldName;\n  },\n\n  /**\n   * Determine whether the regexp can match any of element strings.\n   *\n   * @param {HTMLElement} element The HTML element to match.\n   * @param {RegExp} regexp       The regular expression to match against.\n   * @param {object} [options]    Optional parameters for matching.\n   * @param {boolean} [options.attribute=true]\n   *                              Whether to match against the element's attributes.\n   * @param {boolean} [options.label=true]\n   *                              Whether to match against the element's labels.\n   * @returns {boolean} True if a match is found, otherwise false.\n   */\n  _matchRegexp(element, regexp, { attribute = true, label = true } = {}) {\n    if (!regexp) {\n      return false;\n    }\n\n    if (attribute) {\n      const elemStrings = this._getElementStrings(element);\n      if (elemStrings.find(s => this.testRegex(regexp, s?.toLowerCase()))) {\n        return true;\n      }\n    }\n\n    if (label) {\n      const elementLabelStrings = this._getElementLabelStrings(element);\n      for (const s of elementLabelStrings) {\n        if (this.testRegex(regexp, s?.toLowerCase())) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Phone field grammars - first matched grammar will be parsed. Grammars are\n   * separated by { REGEX_SEPARATOR, FIELD_NONE, 0 }. Suffix and extension are\n   * parsed separately unless they are necessary parts of the match.\n   * The following notation is used to describe the patterns:\n   * <cc> - country code field.\n   * <ac> - area code field.\n   * <phone> - phone or prefix.\n   * <suffix> - suffix.\n   * <ext> - extension.\n   * :N means field is limited to N characters, otherwise it is unlimited.\n   * (pattern <field>)? means pattern is optional and matched separately.\n   *\n   * This grammar list from Chromium will be enabled partially once we need to\n   * support more cases of Telephone fields.\n   */\n  PHONE_FIELD_GRAMMARS: [\n    // Country code: <cc> Area Code: <ac> Phone: <phone> (- <suffix>\n\n    // (Ext: <ext>)?)?\n    // {REGEX_COUNTRY, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // \\( <ac> \\) <phone>:3 <suffix>:4 (Ext: <ext>)?\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 3},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 3},\n    // {REGEX_PHONE, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc> <ac>:3 - <phone>:3 - <suffix>:4 (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_PHONE, FIELD_AREA_CODE, 3},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 3},\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc>:3 <ac>:3 <phone>:3 <suffix>:4 (Ext: <ext>)?\n    [\"tel\", \"tel-country-code\", 3],\n    [\"tel\", \"tel-area-code\", 3],\n    [\"tel\", \"tel-local-prefix\", 3],\n    [\"tel\", \"tel-local-suffix\", 4],\n    [null, null, 0],\n\n    // Area Code: <ac> Phone: <phone> (- <suffix> (Ext: <ext>)?)?\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> <phone>:3 <suffix>:4 (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 3},\n    // {REGEX_PHONE, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc> \\( <ac> \\) <phone> (- <suffix> (Ext: <ext>)?)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: \\( <ac> \\) <phone> (- <suffix> (Ext: <ext>)?)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_AREA_NOTEXT, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc> - <ac> - <phone> - <suffix> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_SUFFIX, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Area code: <ac>:3 Prefix: <prefix>:3 Suffix: <suffix>:4 (Ext: <ext>)?\n    // {REGEX_AREA, FIELD_AREA_CODE, 3},\n    // {REGEX_PREFIX, FIELD_PHONE, 3},\n    // {REGEX_SUFFIX, FIELD_SUFFIX, 4},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> Prefix: <phone> Suffix: <suffix> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_AREA_CODE, 0},\n    // {REGEX_PREFIX, FIELD_PHONE, 0},\n    // {REGEX_SUFFIX, FIELD_SUFFIX, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> - <phone>:3 - <suffix>:4 (Ext: <ext>)?\n    [\"tel\", \"tel-area-code\", 0],\n    [\"tel\", \"tel-local-prefix\", 3],\n    [\"tel\", \"tel-local-suffix\", 4],\n    [null, null, 0],\n\n    // Phone: <cc> - <ac> - <phone> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 0},\n    // {REGEX_PREFIX_SEPARATOR, FIELD_AREA_CODE, 0},\n    // {REGEX_SUFFIX_SEPARATOR, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <ac> - <phone> (Ext: <ext>)?\n    // {REGEX_AREA, FIELD_AREA_CODE, 0},\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <cc>:3 - <phone>:10 (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_COUNTRY_CODE, 3},\n    // {REGEX_PHONE, FIELD_PHONE, 10},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Ext: <ext>\n    // {REGEX_EXTENSION, FIELD_EXTENSION, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n\n    // Phone: <phone> (Ext: <ext>)?\n    // {REGEX_PHONE, FIELD_PHONE, 0},\n    // {REGEX_SEPARATOR, FIELD_NONE, 0},\n  ],\n};\n\nChromeUtils.defineLazyGetter(\n  FormAutofillHeuristics,\n  \"CREDIT_CARD_FIELDNAMES\",\n  () =>\n    Object.keys(FormAutofillHeuristics.RULES).filter(name =>\n      lazy.FormAutofillUtils.isCreditCardField(name)\n    )\n);\n\nChromeUtils.defineLazyGetter(FormAutofillHeuristics, \"ADDRESS_FIELDNAMES\", () =>\n  Object.keys(FormAutofillHeuristics.RULES).filter(name =>\n    lazy.FormAutofillUtils.isAddressField(name)\n  )\n);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormAutofillHeuristics);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillNameUtils\": () => (/* binding */ FormAutofillNameUtils)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// FormAutofillNameUtils is initially translated from\n// https://cs.chromium.org/chromium/src/components/autofill/core/browser/autofill_data_util.cc?rcl=b861deff77abecff11ae6a9f6946e9cc844b9817\nvar FormAutofillNameUtils = {\n  NAME_PREFIXES: [\n    \"1lt\",\n    \"1st\",\n    \"2lt\",\n    \"2nd\",\n    \"3rd\",\n    \"admiral\",\n    \"capt\",\n    \"captain\",\n    \"col\",\n    \"cpt\",\n    \"dr\",\n    \"gen\",\n    \"general\",\n    \"lcdr\",\n    \"lt\",\n    \"ltc\",\n    \"ltg\",\n    \"ltjg\",\n    \"maj\",\n    \"major\",\n    \"mg\",\n    \"mr\",\n    \"mrs\",\n    \"ms\",\n    \"pastor\",\n    \"prof\",\n    \"rep\",\n    \"reverend\",\n    \"rev\",\n    \"sen\",\n    \"st\",\n  ],\n\n  NAME_SUFFIXES: [\n    \"b.a\",\n    \"ba\",\n    \"d.d.s\",\n    \"dds\",\n    \"i\",\n    \"ii\",\n    \"iii\",\n    \"iv\",\n    \"ix\",\n    \"jr\",\n    \"m.a\",\n    \"m.d\",\n    \"ma\",\n    \"md\",\n    \"ms\",\n    \"ph.d\",\n    \"phd\",\n    \"sr\",\n    \"v\",\n    \"vi\",\n    \"vii\",\n    \"viii\",\n    \"x\",\n  ],\n\n  FAMILY_NAME_PREFIXES: [\n    \"d'\",\n    \"de\",\n    \"del\",\n    \"der\",\n    \"di\",\n    \"la\",\n    \"le\",\n    \"mc\",\n    \"san\",\n    \"st\",\n    \"ter\",\n    \"van\",\n    \"von\",\n  ],\n\n  // The common and non-ambiguous CJK surnames (last names) that have more than\n  // one character.\n  COMMON_CJK_MULTI_CHAR_SURNAMES: [\n    // Korean, taken from the list of surnames:\n    // https://ko.wikipedia.org/wiki/%ED%95%9C%EA%B5%AD%EC%9D%98_%EC%84%B1%EC%94%A8_%EB%AA%A9%EB%A1%9D\n    \"남궁\",\n    \"사공\",\n    \"서문\",\n    \"선우\",\n    \"제갈\",\n    \"황보\",\n    \"독고\",\n    \"망절\",\n\n    // Chinese, taken from the top 10 Chinese 2-character surnames:\n    // https://zh.wikipedia.org/wiki/%E8%A4%87%E5%A7%93#.E5.B8.B8.E8.A6.8B.E7.9A.84.E8.A4.87.E5.A7.93\n    // Simplified Chinese (mostly mainland China)\n    \"欧阳\",\n    \"令狐\",\n    \"皇甫\",\n    \"上官\",\n    \"司徒\",\n    \"诸葛\",\n    \"司马\",\n    \"宇文\",\n    \"呼延\",\n    \"端木\",\n    // Traditional Chinese (mostly Taiwan)\n    \"張簡\",\n    \"歐陽\",\n    \"諸葛\",\n    \"申屠\",\n    \"尉遲\",\n    \"司馬\",\n    \"軒轅\",\n    \"夏侯\",\n  ],\n\n  // All Korean surnames that have more than one character, even the\n  // rare/ambiguous ones.\n  KOREAN_MULTI_CHAR_SURNAMES: [\n    \"강전\",\n    \"남궁\",\n    \"독고\",\n    \"동방\",\n    \"망절\",\n    \"사공\",\n    \"서문\",\n    \"선우\",\n    \"소봉\",\n    \"어금\",\n    \"장곡\",\n    \"제갈\",\n    \"황목\",\n    \"황보\",\n  ],\n\n  // The whitespace definition based on\n  // https://cs.chromium.org/chromium/src/base/strings/string_util_constants.cc?l=9&rcl=b861deff77abecff11ae6a9f6946e9cc844b9817\n  WHITESPACE: [\n    \"\\u0009\", // CHARACTER TABULATION\n    \"\\u000A\", // LINE FEED (LF)\n    \"\\u000B\", // LINE TABULATION\n    \"\\u000C\", // FORM FEED (FF)\n    \"\\u000D\", // CARRIAGE RETURN (CR)\n    \"\\u0020\", // SPACE\n    \"\\u0085\", // NEXT LINE (NEL)\n    \"\\u00A0\", // NO-BREAK SPACE\n    \"\\u1680\", // OGHAM SPACE MARK\n    \"\\u2000\", // EN QUAD\n    \"\\u2001\", // EM QUAD\n    \"\\u2002\", // EN SPACE\n    \"\\u2003\", // EM SPACE\n    \"\\u2004\", // THREE-PER-EM SPACE\n    \"\\u2005\", // FOUR-PER-EM SPACE\n    \"\\u2006\", // SIX-PER-EM SPACE\n    \"\\u2007\", // FIGURE SPACE\n    \"\\u2008\", // PUNCTUATION SPACE\n    \"\\u2009\", // THIN SPACE\n    \"\\u200A\", // HAIR SPACE\n    \"\\u2028\", // LINE SEPARATOR\n    \"\\u2029\", // PARAGRAPH SEPARATOR\n    \"\\u202F\", // NARROW NO-BREAK SPACE\n    \"\\u205F\", // MEDIUM MATHEMATICAL SPACE\n    \"\\u3000\", // IDEOGRAPHIC SPACE\n  ],\n\n  // The middle dot is used as a separator for foreign names in Japanese.\n  MIDDLE_DOT: [\n    \"\\u30FB\", // KATAKANA MIDDLE DOT\n    \"\\u00B7\", // A (common?) typo for \"KATAKANA MIDDLE DOT\"\n  ],\n\n  // The Unicode range is based on Wiki:\n  // https://en.wikipedia.org/wiki/CJK_Unified_Ideographs\n  // https://en.wikipedia.org/wiki/Hangul\n  // https://en.wikipedia.org/wiki/Japanese_writing_system\n  CJK_RANGE: [\n    \"\\u1100-\\u11FF\", // Hangul Jamo\n    \"\\u3040-\\u309F\", // Hiragana\n    \"\\u30A0-\\u30FF\", // Katakana\n    \"\\u3105-\\u312C\", // Bopomofo\n    \"\\u3130-\\u318F\", // Hangul Compatibility Jamo\n    \"\\u31F0-\\u31FF\", // Katakana Phonetic Extensions\n    \"\\u3200-\\u32FF\", // Enclosed CJK Letters and Months\n    \"\\u3400-\\u4DBF\", // CJK unified ideographs Extension A\n    \"\\u4E00-\\u9FFF\", // CJK Unified Ideographs\n    \"\\uA960-\\uA97F\", // Hangul Jamo Extended-A\n    \"\\uAC00-\\uD7AF\", // Hangul Syllables\n    \"\\uD7B0-\\uD7FF\", // Hangul Jamo Extended-B\n    \"\\uFF00-\\uFFEF\", // Halfwidth and Fullwidth Forms\n  ],\n\n  HANGUL_RANGE: [\n    \"\\u1100-\\u11FF\", // Hangul Jamo\n    \"\\u3130-\\u318F\", // Hangul Compatibility Jamo\n    \"\\uA960-\\uA97F\", // Hangul Jamo Extended-A\n    \"\\uAC00-\\uD7AF\", // Hangul Syllables\n    \"\\uD7B0-\\uD7FF\", // Hangul Jamo Extended-B\n  ],\n\n  _dataLoaded: false,\n\n  // Returns true if |set| contains |token|, modulo a final period.\n  _containsString(set, token) {\n    let target = token.replace(/\\.$/, \"\").toLowerCase();\n    return set.includes(target);\n  },\n\n  // Removes common name prefixes from |name_tokens|.\n  _stripPrefixes(nameTokens) {\n    for (let i in nameTokens) {\n      if (!this._containsString(this.NAME_PREFIXES, nameTokens[i])) {\n        return nameTokens.slice(i);\n      }\n    }\n    return [];\n  },\n\n  // Removes common name suffixes from |name_tokens|.\n  _stripSuffixes(nameTokens) {\n    for (let i = nameTokens.length - 1; i >= 0; i--) {\n      if (!this._containsString(this.NAME_SUFFIXES, nameTokens[i])) {\n        return nameTokens.slice(0, i + 1);\n      }\n    }\n    return [];\n  },\n\n  _isCJKName(name) {\n    // The name is considered to be a CJK name if it is only CJK characters,\n    // spaces, and \"middle dot\" separators, with at least one CJK character, and\n    // no more than 2 words.\n    //\n    // Chinese and Japanese names are usually spelled out using the Han\n    // characters (logographs), which constitute the \"CJK Unified Ideographs\"\n    // block in Unicode, also referred to as Unihan. Korean names are usually\n    // spelled out in the Korean alphabet (Hangul), although they do have a Han\n    // equivalent as well.\n\n    if (!name) {\n      return false;\n    }\n\n    let previousWasCJK = false;\n    let wordCount = 0;\n\n    for (let c of name) {\n      let isMiddleDot = this.MIDDLE_DOT.includes(c);\n      let isCJK = !isMiddleDot && this.reCJK.test(c);\n      if (!isCJK && !isMiddleDot && !this.WHITESPACE.includes(c)) {\n        return false;\n      }\n      if (isCJK && !previousWasCJK) {\n        wordCount++;\n      }\n      previousWasCJK = isCJK;\n    }\n\n    return wordCount > 0 && wordCount < 3;\n  },\n\n  // Tries to split a Chinese, Japanese, or Korean name into its given name &\n  // surname parts. If splitting did not work for whatever reason, returns null.\n  _splitCJKName(nameTokens) {\n    // The convention for CJK languages is to put the surname (last name) first,\n    // and the given name (first name) second. In a continuous text, there is\n    // normally no space between the two parts of the name. When entering their\n    // name into a field, though, some people add a space to disambiguate. CJK\n    // names (almost) never have a middle name.\n\n    let reHangulName = new RegExp(\n      \"^[\" + this.HANGUL_RANGE.join(\"\") + this.WHITESPACE.join(\"\") + \"]+$\",\n      \"u\"\n    );\n    let nameParts = {\n      given: \"\",\n      middle: \"\",\n      family: \"\",\n    };\n\n    if (nameTokens.length == 1) {\n      // There is no space between the surname and given name. Try to infer\n      // where to separate between the two. Most Chinese and Korean surnames\n      // have only one character, but there are a few that have 2. If the name\n      // does not start with a surname from a known list, default to one\n      // character.\n      let name = nameTokens[0];\n      let isKorean = reHangulName.test(name);\n      let surnameLength = 0;\n\n      // 4-character Korean names are more likely to be 2/2 than 1/3, so use\n      // the full list of Korean 2-char surnames. (instead of only the common\n      // ones)\n      let multiCharSurnames =\n        isKorean && name.length > 3\n          ? this.KOREAN_MULTI_CHAR_SURNAMES\n          : this.COMMON_CJK_MULTI_CHAR_SURNAMES;\n\n      // Default to 1 character if the surname is not in the list.\n      surnameLength = multiCharSurnames.some(surname =>\n        name.startsWith(surname)\n      )\n        ? 2\n        : 1;\n\n      nameParts.family = name.substr(0, surnameLength);\n      nameParts.given = name.substr(surnameLength);\n    } else if (nameTokens.length == 2) {\n      // The user entered a space between the two name parts. This makes our job\n      // easier. Family name first, given name second.\n      nameParts.family = nameTokens[0];\n      nameParts.given = nameTokens[1];\n    } else {\n      return null;\n    }\n\n    return nameParts;\n  },\n\n  init() {\n    if (this._dataLoaded) {\n      return;\n    }\n    this._dataLoaded = true;\n\n    this.reCJK = new RegExp(\"[\" + this.CJK_RANGE.join(\"\") + \"]\", \"u\");\n  },\n\n  splitName(name) {\n    let nameParts = {\n      given: \"\",\n      middle: \"\",\n      family: \"\",\n    };\n\n    if (!name) {\n      return nameParts;\n    }\n\n    let nameTokens = name.trim().split(/[ ,\\u3000\\u30FB\\u00B7]+/);\n    nameTokens = this._stripPrefixes(nameTokens);\n\n    if (this._isCJKName(name)) {\n      let parts = this._splitCJKName(nameTokens);\n      if (parts) {\n        return parts;\n      }\n    }\n\n    // Don't assume \"Ma\" is a suffix in John Ma.\n    if (nameTokens.length > 2) {\n      nameTokens = this._stripSuffixes(nameTokens);\n    }\n\n    if (!nameTokens.length) {\n      // Bad things have happened; just assume the whole thing is a given name.\n      nameParts.given = name;\n      return nameParts;\n    }\n\n    // Only one token, assume given name.\n    if (nameTokens.length == 1) {\n      nameParts.given = nameTokens[0];\n      return nameParts;\n    }\n\n    // 2 or more tokens. Grab the family, which is the last word plus any\n    // recognizable family prefixes.\n    let familyTokens = [nameTokens.pop()];\n    while (nameTokens.length) {\n      let lastToken = nameTokens[nameTokens.length - 1];\n      if (!this._containsString(this.FAMILY_NAME_PREFIXES, lastToken)) {\n        break;\n      }\n      familyTokens.unshift(lastToken);\n      nameTokens.pop();\n    }\n    nameParts.family = familyTokens.join(\" \");\n\n    // Take the last remaining token as the middle name (if there are at least 2\n    // tokens).\n    if (nameTokens.length >= 2) {\n      nameParts.middle = nameTokens.pop();\n    }\n\n    // Remainder is given name.\n    nameParts.given = nameTokens.join(\" \");\n\n    return nameParts;\n  },\n\n  joinNameParts({ given, middle, family }) {\n    if (this._isCJKName(given) && this._isCJKName(family) && !middle) {\n      return family + given;\n    }\n    return [given, middle, family]\n      .filter(part => part && part.length)\n      .join(\" \");\n  },\n};\n\nFormAutofillNameUtils.init();\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs":
/*!*****************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillAddressSection\": () => (/* reexport safe */ resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillAddressSection),\n/* harmony export */   \"FormAutofillCreditCardSection\": () => (/* reexport safe */ resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillCreditCardSection),\n/* harmony export */   \"FormAutofillSection\": () => (/* reexport safe */ resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillSection)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofillSection.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// Since we are listening on focus events to ping swift,\n// focusing inputs before filling will cause an infinite loop\nresource_autofill_FormAutofillSection_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillSection.SHOULD_FOCUS_ON_AUTOFILL = false;\n\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillAddressSection\": () => (/* binding */ FormAutofillAddressSection),\n/* harmony export */   \"FormAutofillCreditCardSection\": () => (/* binding */ FormAutofillCreditCardSection),\n/* harmony export */   \"FormAutofillSection\": () => (/* binding */ FormAutofillSection)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/FormAutofillUtils.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\");\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  AutofillTelemetry: \"resource://gre/modules/shared/AutofillTelemetry.sys.mjs\",\n  CreditCard: \"resource://gre/modules/CreditCard.sys.mjs\",\n  FormAutofillNameUtils:\n    \"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\",\n  LabelUtils: \"resource://gre/modules/shared/LabelUtils.sys.mjs\",\n});\n\nconst { FIELD_STATES } = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils;\n\nclass FormAutofillSection {\n  static SHOULD_FOCUS_ON_AUTOFILL = true;\n  #focusedInput = null;\n\n  #fieldDetails = [];\n\n  constructor(fieldDetails, handler) {\n    this.#fieldDetails = fieldDetails;\n\n    if (!this.isValidSection()) {\n      return;\n    }\n\n    this.handler = handler;\n    this.filledRecordGUID = null;\n\n    ChromeUtils.defineLazyGetter(this, \"log\", () =>\n      resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofill.defineLogGetter(this, \"FormAutofillHandler\")\n    );\n\n    this._cacheValue = {\n      allFieldNames: null,\n      matchingSelectOption: null,\n    };\n\n    // Identifier used to correlate events relating to the same form\n    this.flowId = Services.uuid.generateUUID().toString();\n    this.log.debug(\n      \"Creating new credit card section with flowId =\",\n      this.flowId\n    );\n  }\n\n  get fieldDetails() {\n    return this.#fieldDetails;\n  }\n\n  /*\n   * Examine the section is a valid section or not based on its fieldDetails or\n   * other information. This method must be overrided.\n   *\n   * @returns {boolean} True for a valid section, otherwise false\n   *\n   */\n  isValidSection() {\n    throw new TypeError(\"isValidSection method must be overrided\");\n  }\n\n  /*\n   * Examine the section is an enabled section type or not based on its\n   * preferences. This method must be overrided.\n   *\n   * @returns {boolean} True for an enabled section type, otherwise false\n   *\n   */\n  isEnabled() {\n    throw new TypeError(\"isEnabled method must be overrided\");\n  }\n\n  /*\n   * Examine the section is createable for storing the profile. This method\n   * must be overrided.\n   *\n   * @param {Object} _record The record for examining createable\n   * @returns {boolean} True for the record is createable, otherwise false\n   *\n   */\n  isRecordCreatable(_record) {\n    throw new TypeError(\"isRecordCreatable method must be overridden\");\n  }\n\n  /**\n   * Override this method if the profile is needed to apply some transformers.\n   *\n   * @param {object} _profile\n   *        A profile should be converted based on the specific requirement.\n   */\n  applyTransformers(_profile) {}\n\n  /**\n   * Override this method if the profile is needed to be customized for\n   * previewing values.\n   *\n   * @param {object} _profile\n   *        A profile for pre-processing before previewing values.\n   */\n  preparePreviewProfile(_profile) {}\n\n  /**\n   * Override this method if the profile is needed to be customized for filling\n   * values.\n   *\n   * @param {object} _profile\n   *        A profile for pre-processing before filling values.\n   * @returns {boolean} Whether the profile should be filled.\n   */\n  async prepareFillingProfile(_profile) {\n    return true;\n  }\n\n  /**\n   * Override this method if the profile is needed to be customized for filling\n   * values.\n   *\n   * @param {object} fieldDetail A fieldDetail of the related element.\n   * @param {object} profile The profile to fill.\n   * @returns {string} The value to fill for the given field.\n   */\n  getFilledValueFromProfile(fieldDetail, profile) {\n    return (\n      profile[`${fieldDetail.fieldName}-formatted`] ||\n      profile[fieldDetail.fieldName]\n    );\n  }\n\n  /*\n   * Override this method if there is any field value needs to compute for a\n   * specific case. Return the original value in the default case.\n   * @param {String} value\n   *        The original field value.\n   * @param {Object} _fieldName\n   *        A fieldDetail of the related element.\n   * @param {HTMLElement} _element\n   *        A element for checking converting value.\n   *\n   * @returns {String}\n   *          A string of the converted value.\n   */\n  computeFillingValue(value, _fieldName, _element) {\n    return value;\n  }\n\n  set focusedInput(element) {\n    this.#focusedInput = element;\n  }\n\n  getFieldDetailByElement(element) {\n    return this.fieldDetails.find(detail => detail.element == element);\n  }\n\n  getFieldDetailByName(fieldName) {\n    return this.fieldDetails.find(detail => detail.fieldName == fieldName);\n  }\n\n  get allFieldNames() {\n    if (!this._cacheValue.allFieldNames) {\n      this._cacheValue.allFieldNames = this.fieldDetails.map(\n        record => record.fieldName\n      );\n    }\n    return this._cacheValue.allFieldNames;\n  }\n\n  matchSelectOptions(profile) {\n    if (!this._cacheValue.matchingSelectOption) {\n      this._cacheValue.matchingSelectOption = new WeakMap();\n    }\n\n    for (const fieldName in profile) {\n      const fieldDetail = this.getFieldDetailByName(fieldName);\n      const element = fieldDetail?.element;\n\n      if (!HTMLSelectElement.isInstance(element)) {\n        continue;\n      }\n\n      const cache = this._cacheValue.matchingSelectOption.get(element) || {};\n      const value = profile[fieldName];\n      if (cache[value] && cache[value].deref()) {\n        continue;\n      }\n\n      const option = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.findSelectOption(\n        element,\n        profile,\n        fieldName\n      );\n\n      if (option) {\n        cache[value] = new WeakRef(option);\n        this._cacheValue.matchingSelectOption.set(element, cache);\n      } else {\n        if (cache[value]) {\n          delete cache[value];\n          this._cacheValue.matchingSelectOption.set(element, cache);\n        }\n        // Skip removing cc-type since this is needed for displaying the icon for credit card network\n        // TODO(Bug 1874339): Cleanup transformation and normalization of data to not remove any\n        // fields and be more consistent\n        if (![\"cc-type\"].includes(fieldName)) {\n          // Delete the field so the phishing hint won't treat it as a \"also fill\"\n          // field.\n          delete profile[fieldName];\n        }\n      }\n    }\n  }\n\n  adaptFieldMaxLength(profile) {\n    for (let key in profile) {\n      let detail = this.getFieldDetailByName(key);\n      if (!detail) {\n        continue;\n      }\n\n      let element = detail.element;\n      if (!element) {\n        continue;\n      }\n\n      let maxLength = element.maxLength;\n      if (\n        maxLength === undefined ||\n        maxLength < 0 ||\n        profile[key].toString().length <= maxLength\n      ) {\n        continue;\n      }\n\n      if (maxLength) {\n        switch (typeof profile[key]) {\n          case \"string\":\n            // If this is an expiration field and our previous\n            // adaptations haven't resulted in a string that is\n            // short enough to satisfy the field length, and the\n            // field is constrained to a length of 4 or 5, then we\n            // assume it is intended to hold an expiration of the\n            // form \"MMYY\" or \"MM/YY\".\n            if (key == \"cc-exp\" && (maxLength == 4 || maxLength == 5)) {\n              const month2Digits = (\n                \"0\" + profile[\"cc-exp-month\"].toString()\n              ).slice(-2);\n              const year2Digits = profile[\"cc-exp-year\"].toString().slice(-2);\n              const separator = maxLength == 5 ? \"/\" : \"\";\n              profile[key] = `${month2Digits}${separator}${year2Digits}`;\n            } else if (key == \"cc-number\") {\n              // We want to show the last four digits of credit card so that\n              // the masked credit card previews correctly and appears correctly\n              // in the autocomplete menu\n              profile[key] = profile[key].substr(\n                profile[key].length - maxLength\n              );\n            } else {\n              profile[key] = profile[key].substr(0, maxLength);\n            }\n            break;\n          case \"number\":\n            // There's no way to truncate a number smaller than a\n            // single digit.\n            if (maxLength < 1) {\n              maxLength = 1;\n            }\n            // The only numbers we store are expiration month/year,\n            // and if they truncate, we want the final digits, not\n            // the initial ones.\n            profile[key] = profile[key] % Math.pow(10, maxLength);\n            break;\n          default:\n        }\n      } else {\n        delete profile[key];\n        delete profile[`${key}-formatted`];\n      }\n    }\n  }\n\n  fillFieldValue(element, value) {\n    if (resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.focusOnAutofill) {\n      element.focus({ preventScroll: true });\n    }\n    if (HTMLInputElement.isInstance(element)) {\n      element.setUserInput(value);\n    } else if (HTMLSelectElement.isInstance(element)) {\n      // Set the value of the select element so that web event handlers can react accordingly\n      element.value = value;\n      element.dispatchEvent(\n        new element.ownerGlobal.Event(\"input\", { bubbles: true })\n      );\n      element.dispatchEvent(\n        new element.ownerGlobal.Event(\"change\", { bubbles: true })\n      );\n    }\n  }\n\n  getAdaptedProfiles(originalProfiles) {\n    for (let profile of originalProfiles) {\n      this.applyTransformers(profile);\n    }\n    return originalProfiles;\n  }\n\n  /**\n   * Processes form fields that can be autofilled, and populates them with the\n   * profile provided by backend.\n   *\n   * @param {object} profile\n   *        A profile to be filled in.\n   * @returns {boolean}\n   *          True if successful, false if failed\n   */\n  async autofillFields(profile) {\n    if (!this.#focusedInput) {\n      throw new Error(\"No focused input.\");\n    }\n\n    const focusedDetail = this.getFieldDetailByElement(this.#focusedInput);\n    if (!focusedDetail) {\n      throw new Error(\"No fieldDetail for the focused input.\");\n    }\n\n    this.getAdaptedProfiles([profile]);\n    if (!(await this.prepareFillingProfile(profile))) {\n      this.log.debug(\"profile cannot be filled\");\n      return false;\n    }\n\n    this.filledRecordGUID = profile.guid;\n    for (const fieldDetail of this.fieldDetails) {\n      // Avoid filling field value in the following cases:\n      // 1. a non-empty input field for an unfocused input\n      // 2. the invalid value set\n      // 3. value already chosen in select element\n\n      const element = fieldDetail.element;\n      // Skip the field if it is null or readonly or disabled\n      if (!resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isFieldAutofillable(element)) {\n        continue;\n      }\n\n      element.previewValue = \"\";\n      // Bug 1687679: Since profile appears to be presentation ready data, we need to utilize the \"x-formatted\" field\n      // that is generated when presentation ready data doesn't fit into the autofilling element.\n      // For example, autofilling expiration month into an input element will not work as expected if\n      // the month is less than 10, since the input is expected a zero-padded string.\n      // See Bug 1722941 for follow up.\n      const value = this.getFilledValueFromProfile(fieldDetail, profile);\n      if (HTMLInputElement.isInstance(element) && value) {\n        // For the focused input element, it will be filled with a valid value\n        // anyway.\n        // For the others, the fields should be only filled when their values are empty\n        // or their values are equal to the site prefill value\n        // or are the result of an earlier auto-fill.\n        if (\n          element == this.#focusedInput ||\n          (element != this.#focusedInput &&\n            (!element.value || element.value == element.defaultValue)) ||\n          this.handler.getFilledStateByElement(element) ==\n            FIELD_STATES.AUTO_FILLED\n        ) {\n          this.fillFieldValue(element, value);\n          this.handler.changeFieldState(fieldDetail, FIELD_STATES.AUTO_FILLED);\n        }\n      } else if (HTMLSelectElement.isInstance(element)) {\n        let cache = this._cacheValue.matchingSelectOption.get(element) || {};\n        let option = cache[value] && cache[value].deref();\n        if (!option) {\n          continue;\n        }\n        // Do not change value or dispatch events if the option is already selected.\n        // Use case for multiple select is not considered here.\n        if (!option.selected) {\n          option.selected = true;\n          this.fillFieldValue(element, option.value);\n        }\n        // Autofill highlight appears regardless if value is changed or not\n        this.handler.changeFieldState(fieldDetail, FIELD_STATES.AUTO_FILLED);\n      }\n    }\n    this.#focusedInput.focus({ preventScroll: true });\n\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\"filled\", this, {\n      profile,\n    });\n\n    return true;\n  }\n\n  /**\n   * Populates result to the preview layers with given profile.\n   *\n   * @param {object} profile\n   *        A profile to be previewed with\n   */\n  previewFormFields(profile) {\n    this.preparePreviewProfile(profile);\n\n    for (const fieldDetail of this.fieldDetails) {\n      let element = fieldDetail.element;\n      // Skip the field if it is null or readonly or disabled\n      if (!resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isFieldAutofillable(element)) {\n        continue;\n      }\n\n      let value =\n        profile[`${fieldDetail.fieldName}-formatted`] ||\n        profile[fieldDetail.fieldName] ||\n        \"\";\n\n      if (HTMLSelectElement.isInstance(element)) {\n        // Unlike text input, select element is always previewed even if\n        // the option is already selected.\n        if (value) {\n          const cache =\n            this._cacheValue.matchingSelectOption.get(element) ?? {};\n          const option = cache[value]?.deref();\n          value = option?.text ?? \"\";\n        }\n      } else if (element.value && element.value != element.defaultValue) {\n        // Skip the field if the user has already entered text and that text is not the site prefilled value.\n        continue;\n      }\n      element.previewValue = value?.toString().replaceAll(\"*\", \"•\");\n      this.handler.changeFieldState(\n        fieldDetail,\n        value ? FIELD_STATES.PREVIEW : FIELD_STATES.NORMAL\n      );\n    }\n  }\n\n  /**\n   * Clear a previously autofilled field in this section\n   */\n  clearFilled(fieldDetail) {\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\"filled_modified\", this, {\n      fieldName: fieldDetail.fieldName,\n    });\n\n    let isAutofilled = false;\n    const dimFieldDetails = [];\n    for (const fieldDetail of this.fieldDetails) {\n      const element = fieldDetail.element;\n\n      if (HTMLSelectElement.isInstance(element)) {\n        // Dim fields are those we don't attempt to revert their value\n        // when clear the target set, such as <select>.\n        dimFieldDetails.push(fieldDetail);\n      } else {\n        isAutofilled |=\n          this.handler.getFilledStateByElement(element) ==\n          FIELD_STATES.AUTO_FILLED;\n      }\n    }\n    if (!isAutofilled) {\n      // Restore the dim fields to initial state as well once we knew\n      // that user had intention to clear the filled form manually.\n      for (const fieldDetail of dimFieldDetails) {\n        // If we can't find a selected option, then we should just reset to the first option's value\n        let element = fieldDetail.element;\n        this._resetSelectElementValue(element);\n        this.handler.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\n      }\n      this.filledRecordGUID = null;\n    }\n  }\n\n  /**\n   * Clear preview text and background highlight of all fields.\n   */\n  clearPreviewedFormFields() {\n    this.log.debug(\"clear previewed fields\");\n\n    for (const fieldDetail of this.fieldDetails) {\n      let element = fieldDetail.element;\n      if (!element) {\n        this.log.warn(fieldDetail.fieldName, \"is unreachable\");\n        continue;\n      }\n\n      element.previewValue = \"\";\n\n      // We keep the state if this field has\n      // already been auto-filled.\n      if (\n        this.handler.getFilledStateByElement(element) ==\n        FIELD_STATES.AUTO_FILLED\n      ) {\n        continue;\n      }\n\n      this.handler.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\n    }\n  }\n\n  /**\n   * Clear value and highlight style of all filled fields.\n   */\n  clearPopulatedForm() {\n    for (let fieldDetail of this.fieldDetails) {\n      let element = fieldDetail.element;\n      if (!element) {\n        this.log.warn(fieldDetail.fieldName, \"is unreachable\");\n        continue;\n      }\n\n      if (\n        this.handler.getFilledStateByElement(element) ==\n        FIELD_STATES.AUTO_FILLED\n      ) {\n        if (HTMLInputElement.isInstance(element)) {\n          element.setUserInput(\"\");\n        } else if (HTMLSelectElement.isInstance(element)) {\n          // If we can't find a selected option, then we should just reset to the first option's value\n          this._resetSelectElementValue(element);\n        }\n      }\n    }\n  }\n\n  resetFieldStates() {\n    for (const fieldDetail of this.fieldDetails) {\n      const element = fieldDetail.element;\n      element.removeEventListener(\"input\", this, { mozSystemGroup: true });\n      this.handler.changeFieldState(fieldDetail, FIELD_STATES.NORMAL);\n    }\n    this.filledRecordGUID = null;\n  }\n\n  isFilled() {\n    return !!this.filledRecordGUID;\n  }\n\n  /**\n   *  Condenses multiple credit card number fields into one fieldDetail\n   *  in order to submit the credit card record correctly.\n   *\n   * @param {Array.<object>} condensedDetails\n   *  An array of fieldDetails\n   * @memberof FormAutofillSection\n   */\n  _condenseMultipleCCNumberFields(condensedDetails) {\n    let countOfCCNumbers = 0;\n    // We ignore the cases where there are more than or less than four credit card number\n    // fields in a form as this is not a valid case for filling the credit card number.\n    for (let i = condensedDetails.length - 1; i >= 0; i--) {\n      if (condensedDetails[i].fieldName == \"cc-number\") {\n        countOfCCNumbers++;\n        if (countOfCCNumbers == 4) {\n          countOfCCNumbers = 0;\n          condensedDetails[i].fieldValue =\n            condensedDetails[i].element?.value +\n            condensedDetails[i + 1].element?.value +\n            condensedDetails[i + 2].element?.value +\n            condensedDetails[i + 3].element?.value;\n          condensedDetails.splice(i + 1, 3);\n        }\n      } else {\n        countOfCCNumbers = 0;\n      }\n    }\n  }\n  /**\n   * Return the record that is converted from `fieldDetails` and only valid\n   * form record is included.\n   *\n   * @returns {object | null}\n   *          A record object consists of three properties:\n   *            - guid: The id of the previously-filled profile or null if omitted.\n   *            - record: A valid record converted from details with trimmed result.\n   *            - untouchedFields: Fields that aren't touched after autofilling.\n   *          Return `null` for any uncreatable or invalid record.\n   */\n  createRecord() {\n    let details = this.fieldDetails;\n    if (!this.isEnabled() || !details || !details.length) {\n      return null;\n    }\n\n    let data = {\n      guid: this.filledRecordGUID,\n      record: {},\n      untouchedFields: [],\n      section: this,\n    };\n    if (this.flowId) {\n      data.flowId = this.flowId;\n    }\n    let condensedDetails = this.fieldDetails;\n\n    // TODO: This is credit card specific code...\n    this._condenseMultipleCCNumberFields(condensedDetails);\n\n    condensedDetails.forEach(detail => {\n      const element = detail.element;\n      // Remove the unnecessary spaces\n      let value = detail.fieldValue ?? (element && element.value.trim());\n      value = this.computeFillingValue(value, detail, element);\n\n      if (!value || value.length > resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.MAX_FIELD_VALUE_LENGTH) {\n        // Keep the property and preserve more information for updating\n        data.record[detail.fieldName] = \"\";\n        return;\n      }\n\n      data.record[detail.fieldName] = value;\n\n      if (\n        this.handler.getFilledStateByElement(element) ==\n        FIELD_STATES.AUTO_FILLED\n      ) {\n        data.untouchedFields.push(detail.fieldName);\n      }\n    });\n\n    const telFields = this.fieldDetails.filter(\n      f => resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.getCategoryFromFieldName(f.fieldName) == \"tel\"\n    );\n    if (\n      telFields.length &&\n      telFields.every(f => data.untouchedFields.includes(f.fieldName))\n    ) {\n      // No need to verify it if none of related fields are modified after autofilling.\n      if (!data.untouchedFields.includes(\"tel\")) {\n        data.untouchedFields.push(\"tel\");\n      }\n    }\n\n    if (!this.isRecordCreatable(data.record)) {\n      return null;\n    }\n\n    return data;\n  }\n\n  /**\n   * Resets a <select> element to its selected option or the first option if there is none selected.\n   *\n   * @param {HTMLElement} element\n   * @memberof FormAutofillSection\n   */\n  _resetSelectElementValue(element) {\n    if (!element.options.length) {\n      return;\n    }\n    let selected = [...element.options].find(option =>\n      option.hasAttribute(\"selected\")\n    );\n    element.value = selected ? selected.value : element.options[0].value;\n    element.dispatchEvent(\n      new element.ownerGlobal.Event(\"input\", { bubbles: true })\n    );\n    element.dispatchEvent(\n      new element.ownerGlobal.Event(\"change\", { bubbles: true })\n    );\n  }\n}\n\nclass FormAutofillAddressSection extends FormAutofillSection {\n  constructor(fieldDetails, handler) {\n    super(fieldDetails, handler);\n\n    if (!this.isValidSection()) {\n      return;\n    }\n\n    this._cacheValue.oneLineStreetAddress = null;\n\n    lazy.AutofillTelemetry.recordDetectedSectionCount(this);\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\"detected\", this);\n  }\n\n  isValidSection() {\n    const fields = new Set(this.fieldDetails.map(f => f.fieldName));\n    return fields.size >= resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.AUTOFILL_FIELDS_THRESHOLD;\n  }\n\n  isEnabled() {\n    return resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofill.isAutofillAddressesEnabled;\n  }\n\n  isRecordCreatable(record) {\n    const country = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.identifyCountryCode(\n      record.country || record[\"country-name\"]\n    );\n    if (\n      country &&\n      !resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofill.isAutofillAddressesAvailableInCountry(country)\n    ) {\n      // We don't want to save data in the wrong fields due to not having proper\n      // heuristic regexes in countries we don't yet support.\n      this.log.warn(\n        \"isRecordCreatable: Country not supported:\",\n        record.country\n      );\n      return false;\n    }\n\n    // Multiple name or tel fields are treat as 1 field while countng whether\n    // the number of fields exceed the valid address secton threshold\n    const categories = Object.entries(record)\n      .filter(e => !!e[1])\n      .map(e => resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.getCategoryFromFieldName(e[0]));\n\n    return (\n      categories.reduce(\n        (acc, category) =>\n          [\"name\", \"tel\"].includes(category) && acc.includes(category)\n            ? acc\n            : [...acc, category],\n        []\n      ).length >= resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.AUTOFILL_FIELDS_THRESHOLD\n    );\n  }\n\n  _getOneLineStreetAddress(address) {\n    if (!this._cacheValue.oneLineStreetAddress) {\n      this._cacheValue.oneLineStreetAddress = {};\n    }\n    if (!this._cacheValue.oneLineStreetAddress[address]) {\n      this._cacheValue.oneLineStreetAddress[address] =\n        resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.toOneLineAddress(address);\n    }\n    return this._cacheValue.oneLineStreetAddress[address];\n  }\n\n  addressTransformer(profile) {\n    if (profile[\"street-address\"]) {\n      // \"-moz-street-address-one-line\" is used by the labels in\n      // ProfileAutoCompleteResult.\n      profile[\"-moz-street-address-one-line\"] = this._getOneLineStreetAddress(\n        profile[\"street-address\"]\n      );\n      let streetAddressDetail = this.getFieldDetailByName(\"street-address\");\n      if (\n        streetAddressDetail &&\n        HTMLInputElement.isInstance(streetAddressDetail.element)\n      ) {\n        profile[\"street-address\"] = profile[\"-moz-street-address-one-line\"];\n      }\n\n      let waitForConcat = [];\n      for (let f of [\"address-line3\", \"address-line2\", \"address-line1\"]) {\n        waitForConcat.unshift(profile[f]);\n        if (this.getFieldDetailByName(f)) {\n          if (waitForConcat.length > 1) {\n            profile[f] = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.toOneLineAddress(waitForConcat);\n          }\n          waitForConcat = [];\n        }\n      }\n    }\n  }\n\n  /**\n   * Replace tel with tel-national if tel violates the input element's\n   * restriction.\n   *\n   * @param {object} profile\n   *        A profile to be converted.\n   */\n  telTransformer(profile) {\n    if (!profile.tel || !profile[\"tel-national\"]) {\n      return;\n    }\n\n    let detail = this.getFieldDetailByName(\"tel\");\n    if (!detail) {\n      return;\n    }\n\n    let element = detail.element;\n    let _pattern;\n    let testPattern = str => {\n      if (!_pattern) {\n        // The pattern has to match the entire value.\n        _pattern = new RegExp(\"^(?:\" + element.pattern + \")$\", \"u\");\n      }\n      return _pattern.test(str);\n    };\n    if (element.pattern) {\n      if (testPattern(profile.tel)) {\n        return;\n      }\n    } else if (element.maxLength) {\n      if (\n        detail.reason == \"autocomplete\" &&\n        profile.tel.length <= element.maxLength\n      ) {\n        return;\n      }\n    }\n\n    if (detail.reason != \"autocomplete\") {\n      // Since we only target people living in US and using en-US websites in\n      // MVP, it makes more sense to fill `tel-national` instead of `tel`\n      // if the field is identified by heuristics and no other clues to\n      // determine which one is better.\n      // TODO: [Bug 1407545] This should be improved once more countries are\n      // supported.\n      profile.tel = profile[\"tel-national\"];\n    } else if (element.pattern) {\n      if (testPattern(profile[\"tel-national\"])) {\n        profile.tel = profile[\"tel-national\"];\n      }\n    } else if (element.maxLength) {\n      if (profile[\"tel-national\"].length <= element.maxLength) {\n        profile.tel = profile[\"tel-national\"];\n      }\n    }\n  }\n\n  /*\n   * Apply all address related transformers.\n   *\n   * @param {Object} profile\n   *        A profile for adjusting address related value.\n   * @override\n   */\n  applyTransformers(profile) {\n    this.addressTransformer(profile);\n    this.telTransformer(profile);\n    this.matchSelectOptions(profile);\n    this.adaptFieldMaxLength(profile);\n  }\n\n  computeFillingValue(value, fieldDetail, element) {\n    // Try to abbreviate the value of select element.\n    if (\n      fieldDetail.fieldName == \"address-level1\" &&\n      HTMLSelectElement.isInstance(element)\n    ) {\n      // Don't save the record when the option value is empty *OR* there\n      // are multiple options being selected. The empty option is usually\n      // assumed to be default along with a meaningless text to users.\n      if (!value || element.selectedOptions.length != 1) {\n        // Keep the property and preserve more information for address updating\n        value = \"\";\n      } else {\n        let text = element.selectedOptions[0].text.trim();\n        value =\n          resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.getAbbreviatedSubregionName([value, text]) || text;\n      }\n    } else if (fieldDetail.fieldName == \"country\") {\n      // This is a temporary fix. Ideally we should have either case-insensitive comparaison of country codes\n      // or handle this elsewhere see Bug 1889234 for more context.\n      value = value.toUpperCase();\n    }\n    return value;\n  }\n}\n\nclass FormAutofillCreditCardSection extends FormAutofillSection {\n  /**\n   * Credit Card Section Constructor\n   *\n   * @param {Array<FieldDetails>} fieldDetails\n   *        The fieldDetail objects for the fields in this section\n   * @param {Object<FormAutofillHandler>} handler\n   *        The handler responsible for this section\n   */\n  constructor(fieldDetails, handler) {\n    super(fieldDetails, handler);\n\n    if (!this.isValidSection()) {\n      return;\n    }\n\n    lazy.AutofillTelemetry.recordDetectedSectionCount(this);\n    lazy.AutofillTelemetry.recordFormInteractionEvent(\"detected\", this);\n\n    // Check whether the section is in an <iframe>; and, if so,\n    // watch for the <iframe> to pagehide.\n    if (handler.window.location != handler.window.parent?.location) {\n      this.log.debug(\n        \"Credit card form is in an iframe -- watching for pagehide\",\n        fieldDetails\n      );\n      handler.window.addEventListener(\n        \"pagehide\",\n        this._handlePageHide.bind(this)\n      );\n    }\n  }\n\n  _handlePageHide(_event) {\n    this.handler.window.removeEventListener(\n      \"pagehide\",\n      this._handlePageHide.bind(this)\n    );\n    this.log.debug(\"Credit card subframe is pagehideing\", this.handler.form);\n\n    const formSubmissionReason =\n      resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.FORM_SUBMISSION_REASON.IFRAME_PAGEHIDE;\n    this.handler.onFormSubmitted(formSubmissionReason);\n  }\n\n  /**\n   * Determine whether a set of cc fields identified by our heuristics form a\n   * valid credit card section.\n   * There are 4 different cases when a field is considered a credit card field\n   * 1. Identified by autocomplete attribute. ex <input autocomplete=\"cc-number\">\n   * 2. Identified by fathom and fathom is pretty confident (when confidence\n   *    value is higher than `highConfidenceThreshold`)\n   * 3. Identified by fathom. Confidence value is between `fathom.confidenceThreshold`\n   *    and `fathom.highConfidenceThreshold`\n   * 4. Identified by regex-based heurstic. There is no confidence value in thise case.\n   *\n   * A form is considered a valid credit card form when one of the following condition\n   * is met:\n   * A. One of the cc field is identified by autocomplete (case 1)\n   * B. One of the cc field is identified by fathom (case 2 or 3), and there is also\n   *    another cc field found by any of our heuristic (case 2, 3, or 4)\n   * C. Only one cc field is found in the section, but fathom is very confident (Case 2).\n   *    Currently we add an extra restriction to this rule to decrease the false-positive\n   *    rate. See comments below for details.\n   *\n   * @returns {boolean} True for a valid section, otherwise false\n   */\n  isValidSection() {\n    let ccNumberDetail = null;\n    let ccNameDetail = null;\n    let ccExpiryDetail = null;\n\n    for (let detail of this.fieldDetails) {\n      switch (detail.fieldName) {\n        case \"cc-number\":\n          ccNumberDetail = detail;\n          break;\n        case \"cc-name\":\n        case \"cc-given-name\":\n        case \"cc-additional-name\":\n        case \"cc-family-name\":\n          ccNameDetail = detail;\n          break;\n        case \"cc-exp\":\n        case \"cc-exp-month\":\n        case \"cc-exp-year\":\n          ccExpiryDetail = detail;\n          break;\n      }\n    }\n\n    // Condition A. Always trust autocomplete attribute. A section is considered a valid\n    // cc section as long as a field has autocomplete=cc-number, cc-name or cc-exp*\n    if (\n      ccNumberDetail?.reason == \"autocomplete\" ||\n      ccNameDetail?.reason == \"autocomplete\" ||\n      ccExpiryDetail?.reason == \"autocomplete\"\n    ) {\n      return true;\n    }\n\n    // Condition B. One of the field is identified by fathom, if this section also\n    // contains another cc field found by our heuristic (Case 2, 3, or 4), we consider\n    // this section a valid credit card seciton\n    if (ccNumberDetail?.reason == \"fathom\") {\n      if (ccNameDetail || ccExpiryDetail) {\n        return true;\n      }\n    } else if (ccNameDetail?.reason == \"fathom\") {\n      if (ccNumberDetail || ccExpiryDetail) {\n        return true;\n      }\n    }\n\n    // Condition C.\n    let highConfidenceThreshold =\n      resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.ccFathomHighConfidenceThreshold;\n    let highConfidenceField;\n    if (ccNumberDetail?.confidence > highConfidenceThreshold) {\n      highConfidenceField = ccNumberDetail;\n    } else if (ccNameDetail?.confidence > highConfidenceThreshold) {\n      highConfidenceField = ccNameDetail;\n    }\n    if (highConfidenceField) {\n      // Temporarily add an addtional \"the field is the only visible input\" constraint\n      // when determining whether a form has only a high-confidence cc-* field a valid\n      // credit card section. We can remove this restriction once we are confident\n      // about only using fathom.\n      const element = highConfidenceField.element;\n      const root = element.form || element.ownerDocument;\n      const inputs = root.querySelectorAll(\"input:not([type=hidden])\");\n      if (inputs.length == 1 && inputs[0] == element) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isEnabled() {\n    return resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.FormAutofill.isAutofillCreditCardsEnabled;\n  }\n\n  isRecordCreatable(record) {\n    return (\n      record[\"cc-number\"] && resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.isCCNumber(record[\"cc-number\"])\n    );\n  }\n\n  /**\n   * Handles credit card expiry date transformation when\n   * the expiry date exists in a cc-exp field.\n   *\n   * @param {object} profile\n   * @memberof FormAutofillCreditCardSection\n   */\n  creditCardExpiryDateTransformer(profile) {\n    if (!profile[\"cc-exp\"]) {\n      return;\n    }\n\n    const element = this.getFieldDetailByName(\"cc-exp\")?.element;\n    if (!element) {\n      return;\n    }\n\n    function updateExpiry(_string, _month, _year) {\n      // Bug 1687681: This is a short term fix to other locales having\n      // different characters to represent year.\n      // - FR locales may use \"A\" to represent year.\n      // - DE locales may use \"J\" to represent year.\n      // - PL locales may use \"R\" to represent year.\n      // This approach will not scale well and should be investigated in a follow up bug.\n      const monthChars = \"m\";\n      const yearChars = \"yy|aa|jj|rr\";\n      const expiryDateFormatRegex = (firstChars, secondChars) =>\n        new RegExp(\n          \"(?:\\\\b|^)((?:[\" +\n            firstChars +\n            \"]{2}){1,2})\\\\s*([\\\\-/])\\\\s*((?:[\" +\n            secondChars +\n            \"]{2}){1,2})(?:\\\\b|$)\",\n          \"i\"\n        );\n\n      // If the month first check finds a result, where placeholder is \"mm - yyyy\",\n      // the result will be structured as such: [\"mm - yyyy\", \"mm\", \"-\", \"yyyy\"]\n      let result = expiryDateFormatRegex(monthChars, yearChars).exec(_string);\n      if (result) {\n        return (\n          _month.padStart(result[1].length, \"0\") +\n          result[2] +\n          _year.substr(-1 * result[3].length)\n        );\n      }\n\n      // If the year first check finds a result, where placeholder is \"yyyy mm\",\n      // the result will be structured as such: [\"yyyy mm\", \"yyyy\", \" \", \"mm\"]\n      result = expiryDateFormatRegex(yearChars, monthChars).exec(_string);\n      if (result) {\n        return (\n          _year.substr(-1 * result[1].length) +\n          result[2] +\n          _month.padStart(result[3].length, \"0\")\n        );\n      }\n      return null;\n    }\n\n    let newExpiryString = null;\n    const month = profile[\"cc-exp-month\"].toString();\n    const year = profile[\"cc-exp-year\"].toString();\n    if (element.tagName == \"INPUT\") {\n      // Use the placeholder or label to determine the expiry string format.\n      const possibleExpiryStrings = [];\n      if (element.placeholder) {\n        possibleExpiryStrings.push(element.placeholder);\n      }\n      const labels = lazy.LabelUtils.findLabelElements(element);\n      if (labels) {\n        // Not consider multiple lable for now.\n        possibleExpiryStrings.push(element.labels[0]?.textContent);\n      }\n      if (element.previousElementSibling?.tagName == \"LABEL\") {\n        possibleExpiryStrings.push(element.previousElementSibling.textContent);\n      }\n\n      possibleExpiryStrings.some(string => {\n        newExpiryString = updateExpiry(string, month, year);\n        return !!newExpiryString;\n      });\n    }\n\n    // Bug 1688576: Change YYYY-MM to MM/YYYY since MM/YYYY is the\n    // preferred presentation format for credit card expiry dates.\n    profile[\"cc-exp\"] = newExpiryString ?? `${month.padStart(2, \"0\")}/${year}`;\n  }\n\n  /**\n   * Handles credit card expiry date transformation when the expiry date exists in\n   * the separate cc-exp-month and cc-exp-year fields\n   *\n   * @param {object} profile\n   * @memberof FormAutofillCreditCardSection\n   */\n  creditCardExpMonthAndYearTransformer(profile) {\n    const getInputElementByField = (field, self) => {\n      if (!field) {\n        return null;\n      }\n      let detail = self.getFieldDetailByName(field);\n      if (!detail) {\n        return null;\n      }\n      let element = detail.element;\n      return element.tagName === \"INPUT\" ? element : null;\n    };\n    let month = getInputElementByField(\"cc-exp-month\", this);\n    if (month) {\n      // Transform the expiry month to MM since this is a common format needed for filling.\n      profile[\"cc-exp-month-formatted\"] = profile[\"cc-exp-month\"]\n        ?.toString()\n        .padStart(2, \"0\");\n    }\n    let year = getInputElementByField(\"cc-exp-year\", this);\n    // If the expiration year element is an input,\n    // then we examine any placeholder to see if we should format the expiration year\n    // as a zero padded string in order to autofill correctly.\n    if (year) {\n      let placeholder = year.placeholder;\n\n      // Checks for 'YY'|'AA'|'JJ'|'RR' placeholder and converts the year to a two digit string using the last two digits.\n      let result = /\\b(yy|aa|jj|rr)\\b/i.test(placeholder);\n      if (result) {\n        profile[\"cc-exp-year-formatted\"] = profile[\"cc-exp-year\"]\n          .toString()\n          .substring(2);\n      }\n    }\n  }\n\n  /**\n   * Handles credit card name transformation when the name exists in\n   * the separate cc-given-name, cc-middle-name, and cc-family name fields\n   *\n   * @param {object} profile\n   * @memberof FormAutofillCreditCardSection\n   */\n  creditCardNameTransformer(profile) {\n    const name = profile[\"cc-name\"];\n    if (!name) {\n      return;\n    }\n\n    const given = this.getFieldDetailByName(\"cc-given-name\");\n    const middle = this.getFieldDetailByName(\"cc-middle-name\");\n    const family = this.getFieldDetailByName(\"cc-family-name\");\n    if (given || middle || family) {\n      const nameParts = lazy.FormAutofillNameUtils.splitName(name);\n      if (given && nameParts.given) {\n        profile[\"cc-given-name\"] = nameParts.given;\n      }\n      if (middle && nameParts.middle) {\n        profile[\"cc-middle-name\"] = nameParts.middle;\n      }\n      if (family && nameParts.family) {\n        profile[\"cc-family-name\"] = nameParts.family;\n      }\n    }\n  }\n\n  async _decrypt(cipherText, reauth) {\n    // Get the window for the form field.\n    let window;\n    for (let fieldDetail of this.fieldDetails) {\n      let element = fieldDetail.element;\n      if (element) {\n        window = element.ownerGlobal;\n        break;\n      }\n    }\n    if (!window) {\n      return null;\n    }\n\n    let actor = window.windowGlobalChild.getActor(\"FormAutofill\");\n    return actor.sendQuery(\"FormAutofill:GetDecryptedString\", {\n      cipherText,\n      reauth,\n    });\n  }\n\n  /*\n   * Apply all credit card related transformers.\n   *\n   * @param {Object} profile\n   *        A profile for adjusting credit card related value.\n   * @override\n   */\n  applyTransformers(profile) {\n    // The matchSelectOptions transformer must be placed after the expiry transformers.\n    // This ensures that the expiry value that is cached in the matchSelectOptions\n    // matches the expiry value that is stored in the profile ensuring that autofill works\n    // correctly when dealing with option elements.\n    this.creditCardExpiryDateTransformer(profile);\n    this.creditCardExpMonthAndYearTransformer(profile);\n    this.creditCardNameTransformer(profile);\n    this.matchSelectOptions(profile);\n    this.adaptFieldMaxLength(profile);\n  }\n\n  getFilledValueFromProfile(fieldDetail, profile) {\n    const value = super.getFilledValueFromProfile(fieldDetail, profile);\n    if (fieldDetail.fieldName == \"cc-number\" && fieldDetail.part != null) {\n      const part = fieldDetail.part;\n      return value.slice((part - 1) * 4, part * 4);\n    }\n    return value;\n  }\n\n  computeFillingValue(value, fieldDetail, element) {\n    if (\n      fieldDetail.fieldName != \"cc-type\" ||\n      !HTMLSelectElement.isInstance(element)\n    ) {\n      return value;\n    }\n\n    if (lazy.CreditCard.isValidNetwork(value)) {\n      return value;\n    }\n\n    // Don't save the record when the option value is empty *OR* there\n    // are multiple options being selected. The empty option is usually\n    // assumed to be default along with a meaningless text to users.\n    if (value && element.selectedOptions.length == 1) {\n      let selectedOption = element.selectedOptions[0];\n      let networkType =\n        lazy.CreditCard.getNetworkFromName(selectedOption.text) ??\n        lazy.CreditCard.getNetworkFromName(selectedOption.value);\n      if (networkType) {\n        return networkType;\n      }\n    }\n    // If we couldn't match the value to any network, we'll\n    // strip this field when submitting.\n    return value;\n  }\n\n  /**\n   * Customize for previewing profile\n   *\n   * @param {object} profile\n   *        A profile for pre-processing before previewing values.\n   * @override\n   */\n  preparePreviewProfile(profile) {\n    // Always show the decrypted credit card number when Master Password is\n    // disabled.\n    if (profile[\"cc-number-decrypted\"]) {\n      profile[\"cc-number\"] = profile[\"cc-number-decrypted\"];\n    } else if (!profile[\"cc-number\"].startsWith(\"****\")) {\n      // Show the previewed credit card as \"**** 4444\" which is\n      // needed when a credit card number field has a maxlength of four.\n      profile[\"cc-number\"] = \"****\" + profile[\"cc-number\"];\n    }\n  }\n\n  /**\n   * Customize for filling profile\n   *\n   * @param {object} profile\n   *        A profile for pre-processing before filling values.\n   * @returns {boolean} Whether the profile should be filled.\n   * @override\n   */\n  async prepareFillingProfile(profile) {\n    // Prompt the OS login dialog to get the decrypted credit card number.\n    if (profile[\"cc-number-encrypted\"]) {\n      const promptMessage = resource_gre_modules_shared_FormAutofillUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofillUtils.reauthOSPromptMessage(\n        \"autofill-use-payment-method-os-prompt-macos\",\n        \"autofill-use-payment-method-os-prompt-windows\",\n        \"autofill-use-payment-method-os-prompt-other\"\n      );\n      let decrypted = await this._decrypt(\n        profile[\"cc-number-encrypted\"],\n        promptMessage\n      );\n\n      if (!decrypted) {\n        // Early return if the decrypted is empty or undefined\n        return false;\n      }\n\n      profile[\"cc-number\"] = decrypted;\n    }\n    return true;\n  }\n}\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs":
/*!***********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormAutofillUtils\": () => (/* binding */ FormAutofillUtils)\n/* harmony export */ });\n/* harmony import */ var resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://autofill/FormAutofill.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\");\n/* harmony import */ var resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/AppConstants.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  CreditCard: \"resource://gre/modules/CreditCard.sys.mjs\",\n  FormAutofillNameUtils:\n    \"resource://gre/modules/shared/FormAutofillNameUtils.sys.mjs\",\n  OSKeyStore: \"resource://gre/modules/OSKeyStore.sys.mjs\",\n  AddressMetaDataLoader:\n    \"resource://gre/modules/shared/AddressMetaDataLoader.sys.mjs\",\n});\n\nChromeUtils.defineLazyGetter(\n  lazy,\n  \"l10n\",\n  () =>\n    new Localization(\n      [\"toolkit/formautofill/formAutofill.ftl\", \"branding/brand.ftl\"],\n      true\n    )\n);\n\nlet FormAutofillUtils;\n\nconst ADDRESSES_COLLECTION_NAME = \"addresses\";\nconst CREDITCARDS_COLLECTION_NAME = \"creditCards\";\nconst MANAGE_ADDRESSES_L10N_IDS = [\n  \"autofill-add-address-title\",\n  \"autofill-manage-addresses-title\",\n];\nconst EDIT_ADDRESS_L10N_IDS = [\n  \"autofill-address-given-name\",\n  \"autofill-address-additional-name\",\n  \"autofill-address-family-name\",\n  \"autofill-address-name\",\n  \"autofill-address-organization\",\n  \"autofill-address-street\",\n  \"autofill-address-state\",\n  \"autofill-address-province\",\n  \"autofill-address-city\",\n  \"autofill-address-country\",\n  \"autofill-address-zip\",\n  \"autofill-address-postal-code\",\n  \"autofill-address-email\",\n  \"autofill-address-tel\",\n  \"autofill-edit-address-title\",\n  \"autofill-address-neighborhood\",\n  \"autofill-address-village-township\",\n  \"autofill-address-island\",\n  \"autofill-address-townland\",\n  \"autofill-address-district\",\n  \"autofill-address-county\",\n  \"autofill-address-post-town\",\n  \"autofill-address-suburb\",\n  \"autofill-address-parish\",\n  \"autofill-address-prefecture\",\n  \"autofill-address-area\",\n  \"autofill-address-do-si\",\n  \"autofill-address-department\",\n  \"autofill-address-emirate\",\n  \"autofill-address-oblast\",\n  \"autofill-address-pin\",\n  \"autofill-address-eircode\",\n  \"autofill-address-country-only\",\n  \"autofill-cancel-button\",\n  \"autofill-save-button\",\n];\nconst MANAGE_CREDITCARDS_L10N_IDS = [\n  \"autofill-add-card-title\",\n  \"autofill-manage-payment-methods-title\",\n];\nconst EDIT_CREDITCARD_L10N_IDS = [\n  \"autofill-card-number\",\n  \"autofill-card-name-on-card\",\n  \"autofill-card-expires-month\",\n  \"autofill-card-expires-year\",\n  \"autofill-card-network\",\n];\nconst FIELD_STATES = {\n  NORMAL: \"NORMAL\",\n  AUTO_FILLED: \"AUTO_FILLED\",\n  PREVIEW: \"PREVIEW\",\n};\nconst FORM_SUBMISSION_REASON = {\n  FORM_SUBMIT_EVENT: \"form-submit-event\",\n  FORM_REMOVAL_AFTER_FETCH: \"form-removal-after-fetch\",\n  IFRAME_PAGEHIDE: \"iframe-pagehide\",\n  PAGE_NAVIGATION: \"page-navigation\",\n};\n\nconst ELIGIBLE_INPUT_TYPES = [\"text\", \"email\", \"tel\", \"number\", \"month\"];\n\n// The maximum length of data to be saved in a single field for preventing DoS\n// attacks that fill the user's hard drive(s).\nconst MAX_FIELD_VALUE_LENGTH = 200;\n\nFormAutofillUtils = {\n  get AUTOFILL_FIELDS_THRESHOLD() {\n    return 3;\n  },\n\n  ADDRESSES_COLLECTION_NAME,\n  CREDITCARDS_COLLECTION_NAME,\n  MANAGE_ADDRESSES_L10N_IDS,\n  EDIT_ADDRESS_L10N_IDS,\n  MANAGE_CREDITCARDS_L10N_IDS,\n  EDIT_CREDITCARD_L10N_IDS,\n  MAX_FIELD_VALUE_LENGTH,\n  FIELD_STATES,\n  FORM_SUBMISSION_REASON,\n\n  _fieldNameInfo: {\n    name: \"name\",\n    \"given-name\": \"name\",\n    \"additional-name\": \"name\",\n    \"family-name\": \"name\",\n    organization: \"organization\",\n    \"street-address\": \"address\",\n    \"address-line1\": \"address\",\n    \"address-line2\": \"address\",\n    \"address-line3\": \"address\",\n    \"address-level1\": \"address\",\n    \"address-level2\": \"address\",\n    \"postal-code\": \"address\",\n    country: \"address\",\n    \"country-name\": \"address\",\n    tel: \"tel\",\n    \"tel-country-code\": \"tel\",\n    \"tel-national\": \"tel\",\n    \"tel-area-code\": \"tel\",\n    \"tel-local\": \"tel\",\n    \"tel-local-prefix\": \"tel\",\n    \"tel-local-suffix\": \"tel\",\n    \"tel-extension\": \"tel\",\n    email: \"email\",\n    \"cc-name\": \"creditCard\",\n    \"cc-given-name\": \"creditCard\",\n    \"cc-additional-name\": \"creditCard\",\n    \"cc-family-name\": \"creditCard\",\n    \"cc-number\": \"creditCard\",\n    \"cc-exp-month\": \"creditCard\",\n    \"cc-exp-year\": \"creditCard\",\n    \"cc-exp\": \"creditCard\",\n    \"cc-type\": \"creditCard\",\n    \"cc-csc\": \"creditCard\",\n  },\n\n  _collators: {},\n  _reAlternativeCountryNames: {},\n\n  isAddressField(fieldName) {\n    return (\n      !!this._fieldNameInfo[fieldName] && !this.isCreditCardField(fieldName)\n    );\n  },\n\n  isCreditCardField(fieldName) {\n    return this._fieldNameInfo?.[fieldName] == \"creditCard\";\n  },\n\n  isCCNumber(ccNumber) {\n    return ccNumber && lazy.CreditCard.isValidNumber(ccNumber);\n  },\n\n  ensureLoggedIn(promptMessage) {\n    return lazy.OSKeyStore.ensureLoggedIn(\n      this._reauthEnabledByUser && promptMessage ? promptMessage : false\n    );\n  },\n\n  /**\n   * Get the array of credit card network ids (\"types\") we expect and offer as valid choices\n   *\n   * @returns {Array}\n   */\n  getCreditCardNetworks() {\n    return lazy.CreditCard.getSupportedNetworks();\n  },\n\n  getCategoryFromFieldName(fieldName) {\n    return this._fieldNameInfo[fieldName];\n  },\n\n  getCategoriesFromFieldNames(fieldNames) {\n    let categories = new Set();\n    for (let fieldName of fieldNames) {\n      let info = this.getCategoryFromFieldName(fieldName);\n      if (info) {\n        categories.add(info);\n      }\n    }\n    return Array.from(categories);\n  },\n\n  getCollectionNameFromFieldName(fieldName) {\n    return this.isCreditCardField(fieldName)\n      ? CREDITCARDS_COLLECTION_NAME\n      : ADDRESSES_COLLECTION_NAME;\n  },\n\n  getAddressSeparator() {\n    // The separator should be based on the L10N address format, and using a\n    // white space is a temporary solution.\n    return \" \";\n  },\n\n  /**\n   * Get address display label. It should display information separated\n   * by a comma.\n   *\n   * @param  {object} address\n   * @returns {string}\n   */\n  getAddressLabel(address) {\n    // TODO: Implement a smarter way for deciding what to display\n    //       as option text. Possibly improve the algorithm in\n    //       ProfileAutoCompleteResult.sys.mjs and reuse it here.\n    let fieldOrder = [\n      \"name\",\n      \"-moz-street-address-one-line\", // Street address\n      \"address-level3\", // Townland / Neighborhood / Village\n      \"address-level2\", // City/Town\n      \"organization\", // Company or organization name\n      \"address-level1\", // Province/State (Standardized code if possible)\n      \"country\", // Country name\n      \"postal-code\", // Postal code\n      \"tel\", // Phone number\n      \"email\", // Email address\n    ];\n\n    address = { ...address };\n    let parts = [];\n    if (address[\"street-address\"]) {\n      address[\"-moz-street-address-one-line\"] = this.toOneLineAddress(\n        address[\"street-address\"]\n      );\n    }\n\n    if (!(\"name\" in address)) {\n      address.name = lazy.FormAutofillNameUtils.joinNameParts({\n        given: address[\"given-name\"],\n        middle: address[\"additional-name\"],\n        family: address[\"family-name\"],\n      });\n    }\n\n    for (const fieldName of fieldOrder) {\n      let string = address[fieldName];\n      if (string) {\n        parts.push(string);\n      }\n    }\n    return parts.join(\", \");\n  },\n\n  /**\n   * Internal method to split an address to multiple parts per the provided delimiter,\n   * removing blank parts.\n   *\n   * @param {string} address The address the split\n   * @param {string} [delimiter] The separator that is used between lines in the address\n   * @returns {string[]}\n   */\n  _toStreetAddressParts(address, delimiter = \"\\n\") {\n    let array = typeof address == \"string\" ? address.split(delimiter) : address;\n\n    if (!Array.isArray(array)) {\n      return [];\n    }\n    return array.map(s => (s ? s.trim() : \"\")).filter(s => s);\n  },\n\n  /**\n   * Converts a street address to a single line, removing linebreaks marked by the delimiter\n   *\n   * @param {string} address The address the convert\n   * @param {string} [delimiter] The separator that is used between lines in the address\n   * @returns {string}\n   */\n  toOneLineAddress(address, delimiter = \"\\n\") {\n    let addressParts = this._toStreetAddressParts(address, delimiter);\n    return addressParts.join(this.getAddressSeparator());\n  },\n\n  /**\n   * In-place concatenate tel-related components into a single \"tel\" field and\n   * delete unnecessary fields.\n   *\n   * @param {object} address An address record.\n   */\n  compressTel(address) {\n    let telCountryCode = address[\"tel-country-code\"] || \"\";\n    let telAreaCode = address[\"tel-area-code\"] || \"\";\n\n    if (!address.tel) {\n      if (address[\"tel-national\"]) {\n        address.tel = telCountryCode + address[\"tel-national\"];\n      } else if (address[\"tel-local\"]) {\n        address.tel = telCountryCode + telAreaCode + address[\"tel-local\"];\n      } else if (address[\"tel-local-prefix\"] && address[\"tel-local-suffix\"]) {\n        address.tel =\n          telCountryCode +\n          telAreaCode +\n          address[\"tel-local-prefix\"] +\n          address[\"tel-local-suffix\"];\n      }\n    }\n\n    for (let field in address) {\n      if (field != \"tel\" && this.getCategoryFromFieldName(field) == \"tel\") {\n        delete address[field];\n      }\n    }\n  },\n\n  /**\n   * Determines if an element can be autofilled or not.\n   *\n   * @param {HTMLElement} element\n   * @returns {boolean} true if the element can be autofilled\n   */\n  isFieldAutofillable(element) {\n    return element && !element.readOnly && !element.disabled;\n  },\n\n  /**\n   * Determines if an element is visually hidden or not.\n   *\n   * @param {HTMLElement} element\n   * @param {boolean} visibilityCheck true to run visiblity check against\n   *                  element.checkVisibility API. Otherwise, test by only checking\n   *                  `hidden` and `display` attributes\n   * @returns {boolean} true if the element is visible\n   */\n  isFieldVisible(element, visibilityCheck = true) {\n    if (\n      visibilityCheck &&\n      element.checkVisibility &&\n      !FormAutofillUtils.ignoreVisibilityCheck\n    ) {\n      return element.checkVisibility({\n        checkOpacity: true,\n        checkVisibilityCSS: true,\n      });\n    }\n\n    return !element.hidden && element.style.display != \"none\";\n  },\n\n  /**\n   * Determines if an element is eligible to be used by credit card or address autofill.\n   *\n   * @param {HTMLElement} element\n   * @returns {boolean} true if element can be used by credit card or address autofill\n   */\n  isCreditCardOrAddressFieldType(element) {\n    if (!element) {\n      return false;\n    }\n\n    if (HTMLInputElement.isInstance(element)) {\n      // `element.type` can be recognized as `text`, if it's missing or invalid.\n      return ELIGIBLE_INPUT_TYPES.includes(element.type);\n    }\n\n    return HTMLSelectElement.isInstance(element);\n  },\n\n  loadDataFromScript(url, sandbox = {}) {\n    Services.scriptloader.loadSubScript(url, sandbox);\n    return sandbox;\n  },\n\n  /**\n   * Get country address data and fallback to US if not found.\n   * See AddressMetaDataLoader.#loadData for more details of addressData structure.\n   *\n   * @param {string} [country=FormAutofill.DEFAULT_REGION]\n   *        The country code for requesting specific country's metadata. It'll be\n   *        default region if parameter is not set.\n   * @param {string} [level1=null]\n   *        Return address level 1/level 2 metadata if parameter is set.\n   * @returns {object|null}\n   *          Return metadata of specific region with default locale and other supported\n   *          locales. We need to return a default country metadata for layout format\n   *          and collator, but for sub-region metadata we'll just return null if not found.\n   */\n  getCountryAddressRawData(\n    country = resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.DEFAULT_REGION,\n    level1 = null\n  ) {\n    let metadata = lazy.AddressMetaDataLoader.getData(country, level1);\n    if (!metadata) {\n      if (level1) {\n        return null;\n      }\n      // Fallback to default region if we couldn't get data from given country.\n      if (country != resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.DEFAULT_REGION) {\n        metadata = lazy.AddressMetaDataLoader.getData(\n          resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.DEFAULT_REGION\n        );\n      }\n    }\n\n    // TODO: Now we fallback to US if we couldn't get data from default region,\n    //       but it could be removed in bug 1423464 if it's not necessary.\n    if (!metadata) {\n      metadata = lazy.AddressMetaDataLoader.getData(\"US\");\n    }\n    return metadata;\n  },\n\n  /**\n   * Get country address data with default locale.\n   *\n   * @param {string} country\n   * @param {string} level1\n   * @returns {object|null} Return metadata of specific region with default locale.\n   *          NOTE: The returned data may be for a default region if the\n   *          specified one cannot be found. Callers who only want the specific\n   *          region should check the returned country code.\n   */\n  getCountryAddressData(country, level1) {\n    let metadata = this.getCountryAddressRawData(country, level1);\n    return metadata && metadata.defaultLocale;\n  },\n\n  /**\n   * Get country address data with all locales.\n   *\n   * @param {string} country\n   * @param {string} level1\n   * @returns {Array<object> | null}\n   *          Return metadata of specific region with all the locales.\n   *          NOTE: The returned data may be for a default region if the\n   *          specified one cannot be found. Callers who only want the specific\n   *          region should check the returned country code.\n   */\n  getCountryAddressDataWithLocales(country, level1) {\n    let metadata = this.getCountryAddressRawData(country, level1);\n    return metadata && [metadata.defaultLocale, ...metadata.locales];\n  },\n\n  /**\n   * Get the collators based on the specified country.\n   *\n   * @param {string}  country The specified country.\n   * @param {object}  [options = {}] a list of options for this method\n   * @param {boolean} [options.ignorePunctuation = true] Whether punctuation should be ignored.\n   * @param {string}  [options.sensitivity = 'base'] Which differences in the strings should lead to non-zero result values\n   * @param {string}  [options.usage = 'search'] Whether the comparison is for sorting or for searching for matching strings\n   * @returns {Array} An array containing several collator objects.\n   */\n  getSearchCollators(\n    country,\n    { ignorePunctuation = true, sensitivity = \"base\", usage = \"search\" } = {}\n  ) {\n    // TODO: Only one language should be used at a time per country. The locale\n    //       of the page should be taken into account to do this properly.\n    //       We are going to support more countries in bug 1370193 and this\n    //       should be addressed when we start to implement that bug.\n\n    if (!this._collators[country]) {\n      let dataset = this.getCountryAddressData(country);\n      let languages = dataset.languages || [dataset.lang];\n      let options = {\n        ignorePunctuation,\n        sensitivity,\n        usage,\n      };\n      this._collators[country] = languages.map(\n        lang => new Intl.Collator(lang, options)\n      );\n    }\n    return this._collators[country];\n  },\n\n  // Based on the list of fields abbreviations in\n  // https://github.com/googlei18n/libaddressinput/wiki/AddressValidationMetadata\n  FIELDS_LOOKUP: {\n    N: \"name\",\n    O: \"organization\",\n    A: \"street-address\",\n    S: \"address-level1\",\n    C: \"address-level2\",\n    D: \"address-level3\",\n    Z: \"postal-code\",\n    n: \"newLine\",\n  },\n\n  /**\n   * Parse a country address format string and outputs an array of fields.\n   * Spaces, commas, and other literals are ignored in this implementation.\n   * For example, format string \"%A%n%C, %S\" should return:\n   * [\n   *   {fieldId: \"street-address\", newLine: true},\n   *   {fieldId: \"address-level2\"},\n   *   {fieldId: \"address-level1\"},\n   * ]\n   *\n   * @param   {string} fmt Country address format string\n   * @returns {Array<object>} List of fields\n   */\n  parseAddressFormat(fmt) {\n    if (!fmt) {\n      throw new Error(\"fmt string is missing.\");\n    }\n\n    return fmt.match(/%[^%]/g).reduce((parsed, part) => {\n      // Take the first letter of each segment and try to identify it\n      let fieldId = this.FIELDS_LOOKUP[part[1]];\n      // Early return if cannot identify part.\n      if (!fieldId) {\n        return parsed;\n      }\n      // If a new line is detected, add an attribute to the previous field.\n      if (fieldId == \"newLine\") {\n        let size = parsed.length;\n        if (size) {\n          parsed[size - 1].newLine = true;\n        }\n        return parsed;\n      }\n      return parsed.concat({ fieldId });\n    }, []);\n  },\n\n  /**\n   * Used to populate dropdowns in the UI (e.g. FormAutofill preferences).\n   * Use findAddressSelectOption for matching a value to a region.\n   *\n   * @param {string[]} subKeys An array of regionCode strings\n   * @param {string[]} subIsoids An array of ISO ID strings, if provided will be preferred over the key\n   * @param {string[]} subNames An array of regionName strings\n   * @param {string[]} subLnames An array of latinised regionName strings\n   * @returns {Map?} Returns null if subKeys or subNames are not truthy.\n   *                   Otherwise, a Map will be returned mapping keys -> names.\n   */\n  buildRegionMapIfAvailable(subKeys, subIsoids, subNames, subLnames) {\n    // Not all regions have sub_keys. e.g. DE\n    if (\n      !subKeys ||\n      !subKeys.length ||\n      (!subNames && !subLnames) ||\n      (subNames && subKeys.length != subNames.length) ||\n      (subLnames && subKeys.length != subLnames.length)\n    ) {\n      return null;\n    }\n\n    // Overwrite subKeys with subIsoids, when available\n    if (subIsoids && subIsoids.length && subIsoids.length == subKeys.length) {\n      for (let i = 0; i < subIsoids.length; i++) {\n        if (subIsoids[i]) {\n          subKeys[i] = subIsoids[i];\n        }\n      }\n    }\n\n    // Apply sub_lnames if sub_names does not exist\n    let names = subNames || subLnames;\n    return new Map(subKeys.map((key, index) => [key, names[index]]));\n  },\n\n  /**\n   * Parse a require string and outputs an array of fields.\n   * Spaces, commas, and other literals are ignored in this implementation.\n   * For example, a require string \"ACS\" should return:\n   * [\"street-address\", \"address-level2\", \"address-level1\"]\n   *\n   * @param   {string} requireString Country address require string\n   * @returns {Array<string>} List of fields\n   */\n  parseRequireString(requireString) {\n    if (!requireString) {\n      throw new Error(\"requireString string is missing.\");\n    }\n\n    return requireString.split(\"\").map(fieldId => this.FIELDS_LOOKUP[fieldId]);\n  },\n\n  /**\n   * Use address data and alternative country name list to identify a country code from a\n   * specified country name.\n   *\n   * @param   {string} countryName A country name to be identified\n   * @param   {string} [countrySpecified] A country code indicating that we only\n   *                                      search its alternative names if specified.\n   * @returns {string} The matching country code.\n   */\n  identifyCountryCode(countryName, countrySpecified) {\n    if (!countryName) {\n      return null;\n    }\n\n    if (lazy.AddressMetaDataLoader.getData(countryName)) {\n      return countryName;\n    }\n\n    const countries = countrySpecified\n      ? [countrySpecified]\n      : [...resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries.keys()];\n\n    for (const country of countries) {\n      let collators = this.getSearchCollators(country);\n      let metadata = this.getCountryAddressData(country);\n      if (country != metadata.key) {\n        // We hit the fallback logic in getCountryAddressRawData so ignore it as\n        // it's not related to `country` and use the name from l10n instead.\n        metadata = {\n          id: `data/${country}`,\n          key: country,\n          name: resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries.get(country),\n        };\n      }\n      let alternativeCountryNames = metadata.alternative_names || [\n        metadata.name,\n      ];\n      let reAlternativeCountryNames = this._reAlternativeCountryNames[country];\n      if (!reAlternativeCountryNames) {\n        reAlternativeCountryNames = this._reAlternativeCountryNames[country] =\n          [];\n      }\n\n      if (countryName.length == 3) {\n        if (this.strCompare(metadata.alpha_3_code, countryName, collators)) {\n          return country;\n        }\n      }\n\n      for (let i = 0; i < alternativeCountryNames.length; i++) {\n        let name = alternativeCountryNames[i];\n        let reName = reAlternativeCountryNames[i];\n        if (!reName) {\n          reName = reAlternativeCountryNames[i] = new RegExp(\n            \"\\\\b\" + this.escapeRegExp(name) + \"\\\\b\",\n            \"i\"\n          );\n        }\n\n        if (\n          this.strCompare(name, countryName, collators) ||\n          reName.test(countryName)\n        ) {\n          return country;\n        }\n      }\n    }\n\n    return null;\n  },\n\n  findSelectOption(selectEl, record, fieldName) {\n    if (this.isAddressField(fieldName)) {\n      return this.findAddressSelectOption(selectEl.options, record, fieldName);\n    }\n    if (this.isCreditCardField(fieldName)) {\n      return this.findCreditCardSelectOption(selectEl, record, fieldName);\n    }\n    return null;\n  },\n\n  /**\n   * Try to find the abbreviation of the given sub-region name\n   *\n   * @param   {string[]} subregionValues A list of inferable sub-region values.\n   * @param   {string} [country] A country name to be identified.\n   * @returns {string} The matching sub-region abbreviation.\n   */\n  getAbbreviatedSubregionName(subregionValues, country) {\n    let values = Array.isArray(subregionValues)\n      ? subregionValues\n      : [subregionValues];\n\n    let collators = this.getSearchCollators(country);\n    for (let metadata of this.getCountryAddressDataWithLocales(country)) {\n      let {\n        sub_keys: subKeys,\n        sub_names: subNames,\n        sub_lnames: subLnames,\n      } = metadata;\n      if (!subKeys) {\n        // Not all regions have sub_keys. e.g. DE\n        continue;\n      }\n      // Apply sub_lnames if sub_names does not exist\n      subNames = subNames || subLnames;\n\n      let speculatedSubIndexes = [];\n      for (const val of values) {\n        let identifiedValue = this.identifyValue(\n          subKeys,\n          subNames,\n          val,\n          collators\n        );\n        if (identifiedValue) {\n          return identifiedValue;\n        }\n\n        // Predict the possible state by partial-matching if no exact match.\n        [subKeys, subNames].forEach(sub => {\n          speculatedSubIndexes.push(\n            sub.findIndex(token => {\n              let pattern = new RegExp(\n                \"\\\\b\" + this.escapeRegExp(token) + \"\\\\b\"\n              );\n\n              return pattern.test(val);\n            })\n          );\n        });\n      }\n      let subKey = subKeys[speculatedSubIndexes.find(i => !!~i)];\n      if (subKey) {\n        return subKey;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Find the option element from select element.\n   * 1. Try to find the locale using the country from address.\n   * 2. First pass try to find exact match.\n   * 3. Second pass try to identify values from address value and options,\n   *    and look for a match.\n   *\n   * @param   {Array<{text: string, value: string}>} options\n   * @param   {object} address\n   * @param   {string} fieldName\n   * @returns {DOMElement}\n   */\n  findAddressSelectOption(options, address, fieldName) {\n    if (options.length > 512) {\n      // Allow enough space for all countries (roughly 300 distinct values) and all\n      // timezones (roughly 400 distinct values), plus some extra wiggle room.\n      return null;\n    }\n    let value = address[fieldName];\n    if (!value) {\n      return null;\n    }\n\n    let collators = this.getSearchCollators(address.country);\n\n    for (const option of options) {\n      if (\n        this.strCompare(value, option.value, collators) ||\n        this.strCompare(value, option.text, collators)\n      ) {\n        return option;\n      }\n    }\n\n    switch (fieldName) {\n      case \"address-level1\": {\n        let { country } = address;\n        let identifiedValue = this.getAbbreviatedSubregionName(\n          [value],\n          country\n        );\n        // No point going any further if we cannot identify value from address level 1\n        if (!identifiedValue) {\n          return null;\n        }\n        for (let dataset of this.getCountryAddressDataWithLocales(country)) {\n          let keys = dataset.sub_keys;\n          if (!keys) {\n            // Not all regions have sub_keys. e.g. DE\n            continue;\n          }\n          // Apply sub_lnames if sub_names does not exist\n          let names = dataset.sub_names || dataset.sub_lnames;\n\n          // Go through options one by one to find a match.\n          // Also check if any option contain the address-level1 key.\n          let pattern = new RegExp(\n            \"\\\\b\" + this.escapeRegExp(identifiedValue) + \"\\\\b\",\n            \"i\"\n          );\n          for (const option of options) {\n            let optionValue = this.identifyValue(\n              keys,\n              names,\n              option.value,\n              collators\n            );\n            let optionText = this.identifyValue(\n              keys,\n              names,\n              option.text,\n              collators\n            );\n            if (\n              identifiedValue === optionValue ||\n              identifiedValue === optionText ||\n              pattern.test(option.value)\n            ) {\n              return option;\n            }\n          }\n        }\n        break;\n      }\n      case \"country\": {\n        if (this.getCountryAddressData(value)) {\n          for (const option of options) {\n            if (\n              this.identifyCountryCode(option.text, value) ||\n              this.identifyCountryCode(option.value, value)\n            ) {\n              return option;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Find the option element from xul menu popups, as used in address capture\n   * doorhanger.\n   *\n   * This is a proxy to `findAddressSelectOption`, which expects HTML select\n   * DOM nodes and operates on options instead of xul menuitems.\n   *\n   * NOTE: This is a temporary solution until Bug 1886949 is landed. This\n   * method will then be removed `findAddressSelectOption` will be used\n   * directly.\n   *\n   * @param   {XULPopupElement} menupopup\n   * @param   {object} address\n   * @param   {string} fieldName\n   * @returns {XULElement}\n   */\n  findAddressSelectOptionWithMenuPopup(menupopup, address, fieldName) {\n    const options = Array.from(menupopup.childNodes).map(menuitem => ({\n      text: menuitem.label,\n      value: menuitem.value,\n      menuitem,\n    }));\n\n    return this.findAddressSelectOption(options, address, fieldName)?.menuitem;\n  },\n\n  findCreditCardSelectOption(selectEl, creditCard, fieldName) {\n    let oneDigitMonth = creditCard[\"cc-exp-month\"]\n      ? creditCard[\"cc-exp-month\"].toString()\n      : null;\n    let twoDigitsMonth = oneDigitMonth ? oneDigitMonth.padStart(2, \"0\") : null;\n    let fourDigitsYear = creditCard[\"cc-exp-year\"]\n      ? creditCard[\"cc-exp-year\"].toString()\n      : null;\n    let twoDigitsYear = fourDigitsYear ? fourDigitsYear.substr(2, 2) : null;\n    let options = Array.from(selectEl.options);\n\n    switch (fieldName) {\n      case \"cc-exp-month\": {\n        if (!oneDigitMonth) {\n          return null;\n        }\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(s => {\n              let result = /[1-9]\\d*/.exec(s);\n              return result && result[0] == oneDigitMonth;\n            })\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n      case \"cc-exp-year\": {\n        if (!fourDigitsYear) {\n          return null;\n        }\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(\n              s => s == twoDigitsYear || s == fourDigitsYear\n            )\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n      case \"cc-exp\": {\n        if (!oneDigitMonth || !fourDigitsYear) {\n          return null;\n        }\n        let patterns = [\n          oneDigitMonth + \"/\" + twoDigitsYear, // 8/22\n          oneDigitMonth + \"/\" + fourDigitsYear, // 8/2022\n          twoDigitsMonth + \"/\" + twoDigitsYear, // 08/22\n          twoDigitsMonth + \"/\" + fourDigitsYear, // 08/2022\n          oneDigitMonth + \"-\" + twoDigitsYear, // 8-22\n          oneDigitMonth + \"-\" + fourDigitsYear, // 8-2022\n          twoDigitsMonth + \"-\" + twoDigitsYear, // 08-22\n          twoDigitsMonth + \"-\" + fourDigitsYear, // 08-2022\n          twoDigitsYear + \"-\" + twoDigitsMonth, // 22-08\n          fourDigitsYear + \"-\" + twoDigitsMonth, // 2022-08\n          fourDigitsYear + \"/\" + oneDigitMonth, // 2022/8\n          twoDigitsMonth + twoDigitsYear, // 0822\n          twoDigitsYear + twoDigitsMonth, // 2208\n        ];\n\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(str =>\n              patterns.some(pattern => str.includes(pattern))\n            )\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n      case \"cc-type\": {\n        let network = creditCard[\"cc-type\"] || \"\";\n        for (let option of options) {\n          if (\n            [option.text, option.label, option.value].some(\n              s => lazy.CreditCard.getNetworkFromName(s) == network\n            )\n          ) {\n            return option;\n          }\n        }\n        break;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Try to match value with keys and names, but always return the key.\n   *\n   * @param   {Array<string>} keys\n   * @param   {Array<string>} names\n   * @param   {string} value\n   * @param   {Array} collators\n   * @returns {string}\n   */\n  identifyValue(keys, names, value, collators) {\n    let resultKey = keys.find(key => this.strCompare(value, key, collators));\n    if (resultKey) {\n      return resultKey;\n    }\n\n    let index = names.findIndex(name =>\n      this.strCompare(value, name, collators)\n    );\n    if (index !== -1) {\n      return keys[index];\n    }\n\n    return null;\n  },\n\n  /**\n   * Compare if two strings are the same.\n   *\n   * @param   {string} a\n   * @param   {string} b\n   * @param   {Array} collators\n   * @returns {boolean}\n   */\n  strCompare(a = \"\", b = \"\", collators) {\n    return collators.some(collator => !collator.compare(a, b));\n  },\n\n  /**\n   * Determine whether one string(b) may be found within another string(a)\n   *\n   * @param   {string} a\n   * @param   {string} b\n   * @param   {Array} collators\n   * @returns {boolean} True if the string is found\n   */\n  strInclude(a = \"\", b = \"\", collators) {\n    const len = a.length - b.length;\n    for (let i = 0; i <= len; i++) {\n      if (this.strCompare(a.substring(i, i + b.length), b, collators)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Escaping user input to be treated as a literal string within a regular\n   * expression.\n   *\n   * @param   {string} string\n   * @returns {string}\n   */\n  escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  },\n\n  /**\n   * Get formatting information of a given country\n   *\n   * @param   {string} country\n   * @returns {object}\n   *         {\n   *           {string} addressLevel3L10nId\n   *           {string} addressLevel2L10nId\n   *           {string} addressLevel1L10nId\n   *           {string} postalCodeL10nId\n   *           {object} fieldsOrder\n   *           {string} postalCodePattern\n   *         }\n   */\n  getFormFormat(country) {\n    let dataset = this.getCountryAddressData(country);\n    // We hit a country fallback in `getCountryAddressRawData` but it's not relevant here.\n    if (country != dataset.key) {\n      // Use a sparse object so the below default values take effect.\n      dataset = {\n        /**\n         * Even though data/ZZ only has address-level2, include the other levels\n         * in case they are needed for unknown countries. Users can leave the\n         * unnecessary fields blank which is better than forcing users to enter\n         * the data in incorrect fields.\n         */\n        fmt: \"%N%n%O%n%A%n%C %S %Z\",\n      };\n    }\n    return {\n      // When particular values are missing for a country, the\n      // data/ZZ value should be used instead:\n      // https://chromium-i18n.appspot.com/ssl-aggregate-address/data/ZZ\n      addressLevel3L10nId: this.getAddressFieldL10nId(\n        dataset.sublocality_name_type || \"suburb\"\n      ),\n      addressLevel2L10nId: this.getAddressFieldL10nId(\n        dataset.locality_name_type || \"city\"\n      ),\n      addressLevel1L10nId: this.getAddressFieldL10nId(\n        dataset.state_name_type || \"province\"\n      ),\n      addressLevel1Options: this.buildRegionMapIfAvailable(\n        dataset.sub_keys,\n        dataset.sub_isoids,\n        dataset.sub_names,\n        dataset.sub_lnames\n      ),\n      countryRequiredFields: this.parseRequireString(dataset.require || \"AC\"),\n      fieldsOrder: this.parseAddressFormat(dataset.fmt || \"%N%n%O%n%A%n%C\"),\n      postalCodeL10nId: this.getAddressFieldL10nId(\n        dataset.zip_name_type || \"postal-code\"\n      ),\n      postalCodePattern: dataset.zip,\n    };\n  },\n  /**\n   * Converts a Map to an array of objects with `value` and `text` properties ( option like).\n   *\n   * @param {Map} optionsMap\n   * @returns {Array<{ value: string, text: string }>|null}\n   */\n  optionsMapToArray(optionsMap) {\n    return optionsMap?.size\n      ? [...optionsMap].map(([value, text]) => ({ value, text }))\n      : null;\n  },\n\n  /**\n   * Get flattened form layout information of a given country\n   * TODO(Bug 1891730): Remove getFormFormat and use this instead.\n   *\n   * @param {object} record - An object containing at least the 'country' property.\n   * @returns {Array} Flattened array with the address fiels in order.\n   */\n  getFormLayout(record) {\n    const formFormat = this.getFormFormat(record.country);\n    let fieldsInOrder = formFormat.fieldsOrder;\n\n    // Add missing fields that are always present but not in the .fmt of addresses\n    // TODO: extend libaddress later to support this if possible\n    fieldsInOrder = [\n      ...fieldsInOrder,\n      {\n        fieldId: \"country\",\n        options: this.optionsMapToArray(resource_autofill_FormAutofill_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.FormAutofill.countries),\n        required: true,\n      },\n      { fieldId: \"tel\", type: \"tel\" },\n      { fieldId: \"email\", type: \"email\" },\n    ];\n\n    const addressLevel1Options = this.optionsMapToArray(\n      formFormat.addressLevel1Options\n    );\n\n    const addressLevel1SelectedValue = addressLevel1Options\n      ? this.findAddressSelectOption(\n          addressLevel1Options,\n          record,\n          \"address-level1\"\n        )?.value\n      : record[\"address-level1\"];\n\n    for (const field of fieldsInOrder) {\n      const flattenedObject = {\n        fieldId: field.fieldId,\n        newLine: field.newLine,\n        l10nId: this.getAddressFieldL10nId(field.fieldId),\n        required: formFormat.countryRequiredFields.includes(field.fieldId),\n        value: record[field.fieldId] ?? \"\",\n        ...(field.fieldId === \"street-address\" && {\n          l10nId: \"autofill-address-street\",\n          multiline: true,\n        }),\n        ...(field.fieldId === \"address-level1\" && {\n          l10nId: formFormat.addressLevel1L10nId,\n          options: addressLevel1Options,\n          value: addressLevel1SelectedValue,\n        }),\n        ...(field.fieldId === \"address-level2\" && {\n          l10nId: formFormat.addressLevel2L10nId,\n        }),\n        ...(field.fieldId === \"address-level3\" && {\n          l10nId: formFormat.addressLevel3L10nId,\n        }),\n        ...(field.fieldId === \"postal-code\" && {\n          pattern: formFormat.postalCodePattern,\n          l10nId: formFormat.postalCodeL10nId,\n        }),\n      };\n      Object.assign(field, flattenedObject);\n    }\n\n    return fieldsInOrder;\n  },\n\n  getAddressFieldL10nId(type) {\n    return \"autofill-address-\" + type.replace(/_/g, \"-\");\n  },\n\n  CC_FATHOM_NONE: 0,\n  CC_FATHOM_JS: 1,\n  CC_FATHOM_NATIVE: 2,\n  isFathomCreditCardsEnabled() {\n    return this.ccHeuristicsMode != this.CC_FATHOM_NONE;\n  },\n\n  /**\n   * Transform the key in FormAutofillConfidences (defined in ChromeUtils.webidl)\n   * to fathom recognized field type.\n   *\n   * @param {string} key key from FormAutofillConfidences dictionary\n   * @returns {string} fathom field type\n   */\n  formAutofillConfidencesKeyToCCFieldType(key) {\n    const MAP = {\n      ccNumber: \"cc-number\",\n      ccName: \"cc-name\",\n      ccType: \"cc-type\",\n      ccExp: \"cc-exp\",\n      ccExpMonth: \"cc-exp-month\",\n      ccExpYear: \"cc-exp-year\",\n    };\n    return MAP[key];\n  },\n  /**\n   * Generates the localized os dialog message that\n   * prompts the user to reauthenticate\n   *\n   * @param {string} msgMac fluent message id for macos clients\n   * @param {string} msgWin fluent message id for windows clients\n   * @param {string} msgOther fluent message id for other clients\n   * @param {string} msgLin (optional) fluent message id for linux clients\n   * @returns {string} localized os prompt message\n   */\n  reauthOSPromptMessage(msgMac, msgWin, msgOther, msgLin = null) {\n    const platform = resource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.AppConstants.platform;\n    let messageID;\n\n    switch (platform) {\n      case \"win\":\n        messageID = msgWin;\n        break;\n      case \"macosx\":\n        messageID = msgMac;\n        break;\n      case \"linux\":\n        messageID = msgLin ?? msgOther;\n        break;\n      default:\n        messageID = msgOther;\n    }\n    return lazy.l10n.formatValueSync(messageID);\n  },\n};\n\nChromeUtils.defineLazyGetter(FormAutofillUtils, \"stringBundle\", function () {\n  return Services.strings.createBundle(\n    \"chrome://formautofill/locale/formautofill.properties\"\n  );\n});\n\nChromeUtils.defineLazyGetter(FormAutofillUtils, \"brandBundle\", function () {\n  return Services.strings.createBundle(\n    \"chrome://branding/locale/brand.properties\"\n  );\n});\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"_reauthEnabledByUser\",\n  \"extensions.formautofill.reauth.enabled\",\n  false\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccHeuristicsMode\",\n  \"extensions.formautofill.creditCards.heuristics.mode\",\n  0\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccFathomConfidenceThreshold\",\n  \"extensions.formautofill.creditCards.heuristics.fathom.confidenceThreshold\",\n  null,\n  null,\n  pref => parseFloat(pref)\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccFathomHighConfidenceThreshold\",\n  \"extensions.formautofill.creditCards.heuristics.fathom.highConfidenceThreshold\",\n  null,\n  null,\n  pref => parseFloat(pref)\n);\n\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ccFathomTestConfidence\",\n  \"extensions.formautofill.creditCards.heuristics.fathom.testConfidence\",\n  null,\n  null,\n  pref => parseFloat(pref)\n);\n\n// This is only used in iOS\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"focusOnAutofill\",\n  \"extensions.formautofill.focusOnAutofill\",\n  true\n);\n\n// This is only used for testing\nresource_gre_modules_XPCOMUtils_sys_mjs__WEBPACK_IMPORTED_MODULE_1__.XPCOMUtils.defineLazyPreferenceGetter(\n  FormAutofillUtils,\n  \"ignoreVisibilityCheck\",\n  \"extensions.formautofill.test.ignoreVisibilityCheck\",\n  false\n);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs":
/*!*********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormLikeFactory\": () => (/* binding */ FormLikeFactory)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * A factory to generate FormLike objects that represent a set of related fields\n * which aren't necessarily marked up with a <form> element. FormLike's emulate\n * the properties of an HTMLFormElement which are relevant to form tasks.\n */\nlet FormLikeFactory = {\n  _propsFromForm: [\"action\", \"autocomplete\", \"ownerDocument\"],\n\n  /**\n   * Create a FormLike object from a <form>.\n   *\n   * @param {HTMLFormElement} aForm\n   * @return {FormLike}\n   * @throws Error if aForm isn't an HTMLFormElement\n   */\n  createFromForm(aForm) {\n    if (!HTMLFormElement.isInstance(aForm)) {\n      throw new Error(\"createFromForm: aForm must be a HTMLFormElement\");\n    }\n\n    let formLike = {\n      elements: [...aForm.elements],\n      rootElement: aForm,\n    };\n\n    for (let prop of this._propsFromForm) {\n      formLike[prop] = aForm[prop];\n    }\n\n    this._addToJSONProperty(formLike);\n\n    return formLike;\n  },\n\n  /**\n   * Create a FormLike object from an <input>/<select> in a document.\n   *\n   * If the field is in a <form>, construct the FormLike from the form.\n   * Otherwise, create a FormLike with a rootElement (wrapper) according to\n   * heuristics. Currently all <input>/<select> not in a <form> are one FormLike\n   * but this shouldn't be relied upon as the heuristics may change to detect\n   * multiple \"forms\" (e.g. registration and login) on one page with a <form>.\n   *\n   * Note that two FormLikes created from the same field won't return the same FormLike object.\n   * Use the `rootElement` property on the FormLike as a key instead.\n   *\n   * @param {HTMLInputElement|HTMLSelectElement} aField - an <input> or <select> field in a document\n   * @return {FormLike}\n   * @throws Error if aField isn't a password or username field in a document\n   */\n  createFromField(aField) {\n    if (\n      (!HTMLInputElement.isInstance(aField) &&\n        !HTMLSelectElement.isInstance(aField)) ||\n      !aField.ownerDocument\n    ) {\n      throw new Error(\"createFromField requires a field in a document\");\n    }\n\n    let rootElement = this.findRootForField(aField);\n    if (HTMLFormElement.isInstance(rootElement)) {\n      return this.createFromForm(rootElement);\n    }\n\n    let doc = aField.ownerDocument;\n\n    let formLike = {\n      action: doc.baseURI,\n      autocomplete: \"on\",\n      ownerDocument: doc,\n      rootElement,\n    };\n\n    // FormLikes can be created when fields are inserted into the DOM. When\n    // many, many fields are inserted one after the other, we create many\n    // FormLikes, and computing the elements list becomes more and more\n    // expensive. Making the elements list lazy means that it'll only\n    // be computed when it's eventually needed (if ever).\n    ChromeUtils.defineLazyGetter(formLike, \"elements\", function () {\n      let elements = [];\n      for (let el of this.rootElement.querySelectorAll(\"input, select\")) {\n        // Exclude elements inside the rootElement that are already in a <form> as\n        // they will be handled by their own FormLike.\n        if (!el.form) {\n          elements.push(el);\n        }\n      }\n\n      return elements;\n    });\n\n    this._addToJSONProperty(formLike);\n    return formLike;\n  },\n\n  /**\n   * Find the closest <form> if any when aField is inside a ShadowRoot.\n   *\n   * @param {HTMLInputElement} aField - a password or username field in a document\n   * @return {HTMLFormElement|null}\n   */\n  closestFormIgnoringShadowRoots(aField) {\n    let form = aField.closest(\"form\");\n    let current = aField;\n    while (!form) {\n      let shadowRoot = current.getRootNode();\n      if (!ShadowRoot.isInstance(shadowRoot)) {\n        break;\n      }\n      let host = shadowRoot.host;\n      form = host.closest(\"form\");\n      current = host;\n    }\n    return form;\n  },\n\n  /**\n   * Determine the Element that encapsulates the related fields. For example, if\n   * a page contains a login form and a checkout form which are \"submitted\"\n   * separately, and the username field is passed in, ideally this would return\n   * an ancestor Element of the username and password fields which doesn't\n   * include any of the checkout fields.\n   *\n   * @param {HTMLInputElement|HTMLSelectElement} aField - a field in a document\n   * @return {HTMLElement} - the root element surrounding related fields\n   */\n  findRootForField(aField) {\n    let form = aField.form || this.closestFormIgnoringShadowRoots(aField);\n    if (form) {\n      return form;\n    }\n\n    return aField.ownerDocument.documentElement;\n  },\n\n  /**\n   * Add a `toJSON` property to a FormLike so logging which ends up going\n   * through dump doesn't include usless garbage from DOM objects.\n   */\n  _addToJSONProperty(aFormLike) {\n    function prettyElementOutput(aElement) {\n      let idText = aElement.id ? \"#\" + aElement.id : \"\";\n      let classText = \"\";\n      for (let className of aElement.classList) {\n        classText += \".\" + className;\n      }\n      return `<${aElement.nodeName + idText + classText}>`;\n    }\n\n    Object.defineProperty(aFormLike, \"toJSON\", {\n      value: () => {\n        let cleansed = {};\n        for (let key of Object.keys(aFormLike)) {\n          let value = aFormLike[key];\n          let cleansedValue = value;\n\n          switch (key) {\n            case \"elements\": {\n              cleansedValue = [];\n              for (let element of value) {\n                cleansedValue.push(prettyElementOutput(element));\n              }\n              break;\n            }\n\n            case \"ownerDocument\": {\n              cleansedValue = {\n                location: {\n                  href: value.location.href,\n                },\n              };\n              break;\n            }\n\n            case \"rootElement\": {\n              cleansedValue = prettyElementOutput(value);\n              break;\n            }\n          }\n\n          cleansed[key] = cleansedValue;\n        }\n        return cleansed;\n      },\n    });\n  },\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormStateManager\": () => (/* binding */ FormStateManager),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  FormLikeFactory: \"resource://gre/modules/FormLikeFactory.sys.mjs\",\n  FormAutofillHandler:\n    \"resource://gre/modules/shared/FormAutofillHandler.sys.mjs\",\n});\n\nclass FormStateManager {\n  constructor(onSubmit, onAutofillCallback) {\n    /**\n     * @type {WeakMap} mapping FormLike root HTML elements to FormAutofillHandler objects.\n     */\n    this._formsDetails = new WeakMap();\n    /**\n     * @type {object} The object where to store the active items, e.g. element,\n     * handler, section, and field detail.\n     */\n    this._activeItems = {};\n\n    this.onSubmit = onSubmit;\n\n    this.onAutofillCallback = onAutofillCallback;\n  }\n\n  /**\n   * Get the active input's information from cache which is created after page\n   * identified.\n   *\n   * @returns {object | null}\n   *          Return the active input's information that cloned from content cache\n   *          (or return null if the information is not found in the cache).\n   */\n  get activeFieldDetail() {\n    if (!this._activeItems.fieldDetail) {\n      let formDetails = this.activeFormDetails;\n      if (!formDetails) {\n        return null;\n      }\n      for (let detail of formDetails) {\n        let detailElement = detail.element;\n        if (detailElement && this.activeInput == detailElement) {\n          this._activeItems.fieldDetail = detail;\n          break;\n        }\n      }\n    }\n    return this._activeItems.fieldDetail;\n  }\n\n  /**\n   * Get the active form's information from cache which is created after page\n   * identified.\n   *\n   * @returns {Array<object> | null}\n   *          Return target form's information from content cache\n   *          (or return null if the information is not found in the cache).\n   *\n   */\n  get activeFormDetails() {\n    let formHandler = this.activeHandler;\n    return formHandler ? formHandler.fieldDetails : null;\n  }\n\n  get activeInput() {\n    return this._activeItems.elementWeakRef?.deref();\n  }\n\n  get activeHandler() {\n    const activeInput = this.activeInput;\n    if (!activeInput) {\n      return null;\n    }\n\n    // XXX: We are recomputing the activeHandler every time to avoid keeping a\n    // reference on the active element. This might be called quite frequently\n    // so if _getFormHandler/findRootForField become more costly, we should\n    // look into caching this result (eg by adding a weakmap).\n    let handler = this._getFormHandler(activeInput);\n    if (handler) {\n      handler.focusedInput = activeInput;\n    }\n    return handler;\n  }\n\n  get activeSection() {\n    let formHandler = this.activeHandler;\n    return formHandler ? formHandler.activeSection : null;\n  }\n\n  /**\n   * Get the form's handler from cache which is created after page identified.\n   *\n   * @param {HTMLInputElement} element Focused input which triggered profile searching\n   * @returns {Array<object> | null}\n   *          Return target form's handler from content cache\n   *          (or return null if the information is not found in the cache).\n   *\n   */\n  _getFormHandler(element) {\n    if (!element) {\n      return null;\n    }\n    let rootElement = lazy.FormLikeFactory.findRootForField(element);\n    return this._formsDetails.get(rootElement);\n  }\n\n  identifyAutofillFields(element) {\n    let formHandler = this._getFormHandler(element);\n    if (!formHandler) {\n      let formLike = lazy.FormLikeFactory.createFromField(element);\n      formHandler = new lazy.FormAutofillHandler(\n        formLike,\n        this.onSubmit,\n        this.onAutofillCallback\n      );\n    } else if (!formHandler.updateFormIfNeeded(element)) {\n      return formHandler.fieldDetails;\n    }\n    this._formsDetails.set(formHandler.form.rootElement, formHandler);\n    return formHandler.collectFormFields();\n  }\n\n  updateActiveInput(element) {\n    if (!element) {\n      this._activeItems = {};\n      return;\n    }\n    this._activeItems = {\n      elementWeakRef: new WeakRef(element),\n      fieldDetail: null,\n    };\n  }\n\n  getRecords(formElement, handler) {\n    handler = handler || this._formsDetails.get(formElement);\n    const records = handler?.createRecords();\n\n    if (\n      !handler ||\n      !records ||\n      !Object.values(records).some(typeRecords => typeRecords.length)\n    ) {\n      return null;\n    }\n    return records;\n  }\n\n  didDestroy() {\n    this._activeItems = {};\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FormStateManager);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs":
/*!*************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppConstants\": () => (/* reexport safe */ resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__.IOSAppConstants),\n/* harmony export */   \"ChromeUtils\": () => (/* binding */ ChromeUtils),\n/* harmony export */   \"OSKeyStore\": () => (/* binding */ OSKeyStore),\n/* harmony export */   \"Region\": () => (/* binding */ Region),\n/* harmony export */   \"Services\": () => (/* binding */ Services),\n/* harmony export */   \"XPCOMUtils\": () => (/* binding */ XPCOMUtils),\n/* harmony export */   \"windowUtils\": () => (/* binding */ windowUtils)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/Constants.ios.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs\");\n/* harmony import */ var resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/Overrides.ios.js */ \"./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js\");\n/* harmony import */ var resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1__);\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n\nconsole.log(\"WWWWWWWWWW ........ hereeeee ????\");\n\n/* eslint mozilla/use-isInstance: 0 */\nHTMLSelectElement.isInstance = element => element instanceof HTMLSelectElement;\nHTMLInputElement.isInstance = element => element instanceof HTMLInputElement;\nHTMLFormElement.isInstance = element => element instanceof HTMLFormElement;\nShadowRoot.isInstance = element => element instanceof ShadowRoot;\n\nHTMLElement.prototype.ownerGlobal = window;\n\nHTMLInputElement.prototype.setUserInput = function (value) {\n  this.value = value;\n\n  // In React apps, setting .value may not always work reliably.\n  // We dispatch change, input as a workaround.\n  // There are other more \"robust\" solutions:\n  // - Dispatching keyboard events and comparing the value after setting it\n  //   (https://github.com/fmeum/browserpass-extension/blob/5efb1f9de6078b509904a83847d370c8e92fc097/src/inject.js#L412-L440)\n  // - Using the native setter\n  //   (https://github.com/facebook/react/issues/10135#issuecomment-401496776)\n  // These are a bit more bloated. We can consider using these later if we encounter any further issues.\n  [\"input\", \"change\"].forEach(eventName => {\n    this.dispatchEvent(new Event(eventName, { bubbles: true }));\n  });\n\n  this.dispatchEvent(new Event(\"blur\", { bubbles: true }));\n};\n\n// Mimic the behavior of .getAutocompleteInfo()\n// It should return an object with a fieldName property matching the autocomplete attribute\n// only if it's a valid value from this list https://searchfox.org/mozilla-central/source/dom/base/AutocompleteFieldList.h#89-149\n// Also found here: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete\nHTMLElement.prototype.getAutocompleteInfo = function () {\n  const autocomplete = this.getAttribute(\"autocomplete\");\n\n  return {\n    fieldName: resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__.IOSAppConstants.validAutocompleteFields.includes(autocomplete)\n      ? autocomplete\n      : \"\",\n  };\n};\n\n// This function  helps us debug better when an error occurs because a certain mock is missing\nconst withNotImplementedError = obj =>\n  new Proxy(obj, {\n    get(target, prop) {\n      if (!Object.keys(target).includes(prop)) {\n        throw new Error(\n          `Not implemented: ${prop} doesn't exist in mocked object `\n        );\n      }\n      return Reflect.get(...arguments);\n    },\n  });\n\n// This function will create a proxy for each undefined property\n// This is useful when the accessed property name is unkonwn beforehand\nconst undefinedProxy = () =>\n  new Proxy(() => {}, {\n    get() {\n      return undefinedProxy();\n    },\n  });\n\n// Webpack needs to be able to statically analyze require statements in order to build the dependency graph\n// In order to require modules dynamically at runtime, we use require.context() to create a dynamic require\n// that is still able to be parsed by Webpack at compile time. The \"./\" and \".mjs\" tells webpack that files\n// in the current directory ending with .mjs might be needed and should be added to the dependency graph.\n// NOTE: This can't handle circular dependencies. A static import can be used in this case.\n// https://webpack.js.org/guides/dependency-management/\nconst internalModuleResolvers = {\n  resolveModule(moduleURI) {\n    // eslint-disable-next-line no-undef\n    const moduleResolver = __webpack_require__(\"./firefox-ios/Client/Assets/CC_Script sync .mjs$\");\n    // Desktop code uses uris for importing modules of the form resource://gre/modules/<module_path>\n    // We only need the filename here\n    const moduleName = moduleURI.split(\"/\").pop();\n    const modulePath =\n      \"./\" + ((resource_gre_modules_Overrides_ios_js__WEBPACK_IMPORTED_MODULE_1___default().ModuleOverrides)[moduleName] ?? moduleName);\n    return moduleResolver(modulePath);\n  },\n\n  resolveModules(obj, modules) {\n    for (const [exportName, moduleURI] of Object.entries(modules)) {\n      const resolvedModule = this.resolveModule(moduleURI);\n      obj[exportName] = resolvedModule?.[exportName];\n    }\n  },\n};\n\n// Define mock for XPCOMUtils\nconst XPCOMUtils = withNotImplementedError({\n  defineLazyPreferenceGetter: (\n    obj,\n    prop,\n    pref,\n    defaultValue = null,\n    onUpdate,\n    transform = val => val\n  ) => {\n    if (!Object.keys(resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__.IOSAppConstants.prefs).includes(pref)) {\n      throw Error(`Pref ${pref} is not defined.`);\n    }\n    obj[prop] = transform(resource_gre_modules_shared_Constants_ios_mjs__WEBPACK_IMPORTED_MODULE_0__.IOSAppConstants.prefs[pref] ?? defaultValue);\n  },\n  defineLazyModuleGetters(obj, modules) {\n    internalModuleResolvers.resolveModules(obj, modules);\n  },\n});\n\n// eslint-disable-next-line no-shadow\nconst ChromeUtils = withNotImplementedError({\n  defineLazyGetter: (obj, prop, getFn) => {\n    obj[prop] = getFn?.call(obj);\n  },\n  defineESModuleGetters(obj, modules) {\n    internalModuleResolvers.resolveModules(obj, modules);\n  },\n  importESModule(moduleURI) {\n    return internalModuleResolvers.resolveModule(moduleURI);\n  },\n});\nwindow.ChromeUtils = ChromeUtils;\n\n// Define mock for Region.sys.mjs\nconst Region = withNotImplementedError({\n  home: \"US\",\n});\n\n// Define mock for OSKeyStore.sys.mjs\nconst OSKeyStore = withNotImplementedError({\n  ensureLoggedIn: () => true,\n});\n\n// Define mock for Services\n// NOTE: Services is a global so we need to attach it to the window\n// eslint-disable-next-line no-shadow\nconst Services = withNotImplementedError({\n  locale: withNotImplementedError({ isAppLocaleRTL: false }),\n  prefs: withNotImplementedError({ prefIsLocked: () => false }),\n  strings: withNotImplementedError({\n    createBundle: () =>\n      withNotImplementedError({\n        GetStringFromName: () => \"\",\n        formatStringFromName: () => \"\",\n      }),\n  }),\n  telemetry: withNotImplementedError({\n    scalarAdd: (scalarName, scalarValue) => {\n      // For now, we only care about the address form telemetry\n      // TODO(FXCM-935): move address telemetry to Glean so we can remove this\n      // Data format of the sent message is:\n      // {\n      //   type: \"scalar\",\n      //   name: \"formautofill.addresses.detected_sections_count\",\n      //   value: Number,\n      // }\n      if (scalarName !== \"formautofill.addresses.detected_sections_count\") {\n        return;\n      }\n\n      // eslint-disable-next-line no-undef\n      webkit.messageHandlers.addressFormTelemetryMessageHandler.postMessage(\n        JSON.stringify({\n          type: \"scalar\",\n          object: scalarName,\n          value: scalarValue,\n        })\n      );\n    },\n    recordEvent: (category, method, object, value, extra) => {\n      // For now, we only care about the address form telemetry\n      // TODO(FXCM-935): move address telemetry to Glean so we can remove this\n      // Data format of the sent message is:\n      // {\n      //   type: \"event\",\n      //   category: \"address\",\n      //   method: \"detected\" | \"filled\" | \"filled_modified\",\n      //   object: \"address_form\" | \"address_form_ext\",\n      //   value: String,\n      //   extra: Any,\n      // }\n      if (category !== \"address\") {\n        return;\n      }\n\n      // eslint-disable-next-line no-undef\n      webkit.messageHandlers.addressFormTelemetryMessageHandler.postMessage(\n        JSON.stringify({\n          type: \"event\",\n          category,\n          method,\n          object,\n          value,\n          extra,\n        })\n      );\n    },\n  }),\n  // TODO(FXCM-936): we should use crypto.randomUUID() instead of Services.uuid.generateUUID() in our codebase\n  // Underneath crypto.randomUUID() uses the same implementation as generateUUID()\n  // https://searchfox.org/mozilla-central/rev/d405168c4d3c0fb900a7354ae17bb34e939af996/dom/base/Crypto.cpp#96\n  // The only limitation is that it's not available in insecure contexts, which should be fine for both iOS and Desktop\n  // since we only autofill in secure contexts\n  uuid: withNotImplementedError({ generateUUID: () => crypto.randomUUID() }),\n});\nwindow.Services = Services;\n\n// Define mock for Localization\nwindow.Localization = function () {\n  return { formatValueSync: () => \"\" };\n};\n\n// For now, we ignore all calls to glean.\n// TODO(FXCM-935): move address telemetry to Glean so we can create a universal mock for glean that\n// dispatches telemetry messages to the iOS.\nwindow.Glean = {\n  formautofillCreditcards: undefinedProxy(),\n  formautofill: undefinedProxy(),\n};\n\nconst windowUtils = withNotImplementedError({\n  removeManuallyManagedState: () => {},\n  addManuallyManagedState: () => {},\n});\nwindow.windowUtils = windowUtils;\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HeuristicsRegExp\": () => (/* binding */ HeuristicsRegExp),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable no-useless-concat */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// prettier-ignore\nconst HeuristicsRegExp = {\n  RULES: {\n    email: undefined,\n    tel: undefined,\n    organization: undefined,\n    \"street-address\": undefined,\n    \"address-line1\": undefined,\n    \"address-line2\": undefined,\n    \"address-line3\": undefined,\n    \"address-level2\": undefined,\n    \"address-level1\": undefined,\n    \"postal-code\": undefined,\n    country: undefined,\n    // Note: We place the `cc-name` field for Credit Card first, because\n    // it is more specific than the `name` field below and we want to check\n    // for it before we catch the more generic one.\n    \"cc-name\": undefined,\n    name: undefined,\n    \"given-name\": undefined,\n    \"additional-name\": undefined,\n    \"family-name\": undefined,\n    \"cc-csc\": undefined,\n    \"cc-number\": undefined,\n    \"cc-exp-month\": undefined,\n    \"cc-exp-year\": undefined,\n    \"cc-exp\": undefined,\n    \"cc-type\": undefined,\n  },\n\n  // regular expressions that only apply to label\n  LABEL_RULES: {\n    \"address-line1\": undefined,\n    \"address-line2\": undefined,\n  },\n\n  RULE_SETS: [\n    //=========================================================================\n    // Firefox-specific rules\n    {\n      \"address-line1\": \"addrline1|address_1|addl1\",\n      \"address-line2\": \"addrline2|address_2|addl2\",\n      \"address-line3\": \"addrline3|address_3|addl3\",\n      \"address-level1\": \"land\", // de-DE\n      \"additional-name\": \"apellido.?materno|lastlastname\",\n      \"cc-name\":\n        \"accountholdername\" +\n        \"|titulaire\", // fr-FR\n      \"cc-number\":\n        \"(cc|kk)nr\",    // de-DE\n      \"cc-exp\":\n        \"ważna.*do\" +        // pl-PL\n        \"|data.*ważności\" +  // pl-PL\n        \"|mm\\\\s*[\\\\-\\\\/]\\\\s*yy\" +  // en-US\n        \"|mm\\\\s*[\\\\-\\\\/]\\\\s*aa\" +  // es-ES\n        \"|mm\\\\s*[\\\\-\\\\/]\\\\s*jj\" +  // de-AT\n        \"|vervaldatum\",            // nl-NL\n      \"cc-exp-month\":\n        \"month\" +\n        \"|(cc|kk)month\" +    // de-DE\n        \"|miesiąc\" +         // pl-PL\n        \"|mes\" +             // es-ES\n        \"|maand\",            // nl-NL\n      \"cc-exp-year\":\n        \"year\" +\n        \"|(cc|kk)year\" +     // de-DE\n        \"|rok\" +             // pl-PL\n        \"|(anno|año)\" +      // es-ES\n        \"|jaar\",             // nl-NL\n      \"cc-type\":\n        \"type\" +\n        \"|kartenmarke\" +     // de-DE\n        \"|typ.*karty\",       // pl-PL\n      \"cc-csc\":\n        \"(\\\\bcvn\\\\b|\\\\bcvv\\\\b|\\\\bcvc\\\\b|\\\\bcsc\\\\b|\\\\bcvd\\\\b|\\\\bcid\\\\b|\\\\bccv\\\\b)\",\n    },\n\n    //=========================================================================\n    // These are the rules used by Bitwarden [0], converted into RegExp form.\n    // [0] https://github.com/bitwarden/browser/blob/c2b8802201fac5e292d55d5caf3f1f78088d823c/src/services/autofill.service.ts#L436\n    {\n      email: \"(^e-?mail$)|(^email-?address$)\",\n\n      tel:\n        \"(^phone$)\" +\n        \"|(^mobile$)\" +\n        \"|(^mobile-?phone$)\" +\n        \"|(^tel$)\" +\n        \"|(^telephone$)\" +\n        \"|(^phone-?number$)\",\n\n      organization:\n        \"(^company$)\" +\n        \"|(^company-?name$)\" +\n        \"|(^organization$)\" +\n        \"|(^organization-?name$)\",\n\n      \"street-address\":\n        \"(^address$)\" +\n        \"|(^street-?address$)\" +\n        \"|(^addr$)\" +\n        \"|(^street$)\" +\n        \"|(^mailing-?addr(ess)?$)\" + // Modified to not grab lines, below\n        \"|(^billing-?addr(ess)?$)\" + // Modified to not grab lines, below\n        \"|(^mail-?addr(ess)?$)\" + // Modified to not grab lines, below\n        \"|(^bill-?addr(ess)?$)\", // Modified to not grab lines, below\n\n      \"address-line1\":\n        \"(^address-?1$)\" +\n        \"|(^address-?line-?1$)\" +\n        \"|(^addr-?1$)\" +\n        \"|(^street-?1$)\",\n\n      \"address-line2\":\n        \"(^address-?2$)\" +\n        \"|(^address-?line-?2$)\" +\n        \"|(^addr-?2$)\" +\n        \"|(^street-?2$)\",\n\n      \"address-line3\":\n        \"(^address-?3$)\" +\n        \"|(^address-?line-?3$)\" +\n        \"|(^addr-?3$)\" +\n        \"|(^street-?3$)\",\n\n      \"address-level2\":\n        \"(^city$)\" +\n        \"|(^town$)\" +\n        \"|(^address-?level-?2$)\" +\n        \"|(^address-?city$)\" +\n        \"|(^address-?town$)\",\n\n      \"address-level1\":\n        \"(^state$)\" +\n        \"|(^province$)\" +\n        \"|(^provence$)\" +\n        \"|(^address-?level-?1$)\" +\n        \"|(^address-?state$)\" +\n        \"|(^address-?province$)\",\n\n      \"postal-code\":\n        \"(^postal$)\" +\n        \"|(^zip$)\" +\n        \"|(^zip2$)\" +\n        \"|(^zip-?code$)\" +\n        \"|(^postal-?code$)\" +\n        \"|(^post-?code$)\" +\n        \"|(^address-?zip$)\" +\n        \"|(^address-?postal$)\" +\n        \"|(^address-?code$)\" +\n        \"|(^address-?postal-?code$)\" +\n        \"|(^address-?zip-?code$)\",\n\n      country:\n        \"(^country$)\" +\n        \"|(^country-?code$)\" +\n        \"|(^country-?name$)\" +\n        \"|(^address-?country$)\" +\n        \"|(^address-?country-?name$)\" +\n        \"|(^address-?country-?code$)\",\n\n      name: \"(^name$)|full-?name|your-?name\",\n\n      \"given-name\":\n        \"(^f-?name$)\" +\n        \"|(^first-?name$)\" +\n        \"|(^given-?name$)\" +\n        \"|(^first-?n$)\",\n\n      \"additional-name\":\n        \"(^m-?name$)\" +\n        \"|(^middle-?name$)\" +\n        \"|(^additional-?name$)\" +\n        \"|(^middle-?initial$)\" +\n        \"|(^middle-?n$)\" +\n        \"|(^middle-?i$)\",\n\n      \"family-name\":\n        \"(^l-?name$)\" +\n        \"|(^last-?name$)\" +\n        \"|(^s-?name$)\" +\n        \"|(^surname$)\" +\n        \"|(^family-?name$)\" +\n        \"|(^family-?n$)\" +\n        \"|(^last-?n$)\",\n\n      \"cc-name\":\n        \"cc-?name\" +\n        \"|card-?name\" +\n        \"|cardholder-?name\" +\n        \"|cardholder\" +\n        // \"|(^name$)\" + // Removed to avoid overwriting \"name\", above.\n        \"|(^nom$)\",\n\n      \"cc-number\":\n        \"cc-?number\" +\n        \"|cc-?num\" +\n        \"|card-?number\" +\n        \"|card-?num\" +\n        \"|(^number$)\" +\n        \"|(^cc$)\" +\n        \"|cc-?no\" +\n        \"|card-?no\" +\n        \"|(^credit-?card$)\" +\n        \"|numero-?carte\" +\n        \"|(^carte$)\" +\n        \"|(^carte-?credit$)\" +\n        \"|num-?carte\" +\n        \"|cb-?num\",\n\n      \"cc-exp\":\n        \"(^cc-?exp$)\" +\n        \"|(^card-?exp$)\" +\n        \"|(^cc-?expiration$)\" +\n        \"|(^card-?expiration$)\" +\n        \"|(^cc-?ex$)\" +\n        \"|(^card-?ex$)\" +\n        \"|(^card-?expire$)\" +\n        \"|(^card-?expiry$)\" +\n        \"|(^validite$)\" +\n        \"|(^expiration$)\" +\n        \"|(^expiry$)\" +\n        \"|mm-?yy\" +\n        \"|mm-?yyyy\" +\n        \"|yy-?mm\" +\n        \"|yyyy-?mm\" +\n        \"|expiration-?date\" +\n        \"|payment-?card-?expiration\" +\n        \"|(^payment-?cc-?date$)\",\n\n      \"cc-exp-month\":\n        \"(^exp-?month$)\" +\n        \"|(^cc-?exp-?month$)\" +\n        \"|(^cc-?month$)\" +\n        \"|(^card-?month$)\" +\n        \"|(^cc-?mo$)\" +\n        \"|(^card-?mo$)\" +\n        \"|(^exp-?mo$)\" +\n        \"|(^card-?exp-?mo$)\" +\n        \"|(^cc-?exp-?mo$)\" +\n        \"|(^card-?expiration-?month$)\" +\n        \"|(^expiration-?month$)\" +\n        \"|(^cc-?mm$)\" +\n        \"|(^cc-?m$)\" +\n        \"|(^card-?mm$)\" +\n        \"|(^card-?m$)\" +\n        \"|(^card-?exp-?mm$)\" +\n        \"|(^cc-?exp-?mm$)\" +\n        \"|(^exp-?mm$)\" +\n        \"|(^exp-?m$)\" +\n        \"|(^expire-?month$)\" +\n        \"|(^expire-?mo$)\" +\n        \"|(^expiry-?month$)\" +\n        \"|(^expiry-?mo$)\" +\n        \"|(^card-?expire-?month$)\" +\n        \"|(^card-?expire-?mo$)\" +\n        \"|(^card-?expiry-?month$)\" +\n        \"|(^card-?expiry-?mo$)\" +\n        \"|(^mois-?validite$)\" +\n        \"|(^mois-?expiration$)\" +\n        \"|(^m-?validite$)\" +\n        \"|(^m-?expiration$)\" +\n        \"|(^expiry-?date-?field-?month$)\" +\n        \"|(^expiration-?date-?month$)\" +\n        \"|(^expiration-?date-?mm$)\" +\n        \"|(^exp-?mon$)\" +\n        \"|(^validity-?mo$)\" +\n        \"|(^exp-?date-?mo$)\" +\n        \"|(^cb-?date-?mois$)\" +\n        \"|(^date-?m$)\",\n\n      \"cc-exp-year\":\n        \"(^exp-?year$)\" +\n        \"|(^cc-?exp-?year$)\" +\n        \"|(^cc-?year$)\" +\n        \"|(^card-?year$)\" +\n        \"|(^cc-?yr$)\" +\n        \"|(^card-?yr$)\" +\n        \"|(^exp-?yr$)\" +\n        \"|(^card-?exp-?yr$)\" +\n        \"|(^cc-?exp-?yr$)\" +\n        \"|(^card-?expiration-?year$)\" +\n        \"|(^expiration-?year$)\" +\n        \"|(^cc-?yy$)\" +\n        \"|(^cc-?y$)\" +\n        \"|(^card-?yy$)\" +\n        \"|(^card-?y$)\" +\n        \"|(^card-?exp-?yy$)\" +\n        \"|(^cc-?exp-?yy$)\" +\n        \"|(^exp-?yy$)\" +\n        \"|(^exp-?y$)\" +\n        \"|(^cc-?yyyy$)\" +\n        \"|(^card-?yyyy$)\" +\n        \"|(^card-?exp-?yyyy$)\" +\n        \"|(^cc-?exp-?yyyy$)\" +\n        \"|(^expire-?year$)\" +\n        \"|(^expire-?yr$)\" +\n        \"|(^expiry-?year$)\" +\n        \"|(^expiry-?yr$)\" +\n        \"|(^card-?expire-?year$)\" +\n        \"|(^card-?expire-?yr$)\" +\n        \"|(^card-?expiry-?year$)\" +\n        \"|(^card-?expiry-?yr$)\" +\n        \"|(^an-?validite$)\" +\n        \"|(^an-?expiration$)\" +\n        \"|(^annee-?validite$)\" +\n        \"|(^annee-?expiration$)\" +\n        \"|(^expiry-?date-?field-?year$)\" +\n        \"|(^expiration-?date-?year$)\" +\n        \"|(^cb-?date-?ann$)\" +\n        \"|(^expiration-?date-?yy$)\" +\n        \"|(^expiration-?date-?yyyy$)\" +\n        \"|(^validity-?year$)\" +\n        \"|(^exp-?date-?year$)\" +\n        \"|(^date-?y$)\",\n\n      \"cc-type\":\n        \"(^cc-?type$)\" +\n        \"|(^card-?type$)\" +\n        \"|(^card-?brand$)\" +\n        \"|(^cc-?brand$)\" +\n        \"|(^cb-?type$)\",\n    },\n\n    //=========================================================================\n    // These rules are from Chromium source codes [1]. Most of them\n    // converted to JS format have the same meaning with the original ones except\n    // the first line of \"address-level1\".\n    // [1] https://source.chromium.org/chromium/chromium/src/+/master:components/autofill/core/common/autofill_regex_constants.cc\n    {\n      // ==== Email ====\n      email:\n        \"e.?mail\" +\n        \"|courriel\" + // fr\n        \"|correo.*electr(o|ó)nico\" + // es-ES\n        \"|メールアドレス\" + // ja-JP\n        \"|Электронной.?Почты\" + // ru\n        \"|邮件|邮箱\" + // zh-CN\n        \"|電郵地址\" + // zh-TW\n        \"|ഇ-മെയില്‍|ഇലക്ട്രോണിക്.?\" +\n        \"മെയിൽ\" + // ml\n        \"|ایمیل|پست.*الکترونیک\" + // fa\n        \"|ईमेल|इलॅक्ट्रॉनिक.?मेल\" + // hi\n        \"|(\\\\b|_)eposta(\\\\b|_)\" + // tr\n        \"|(?:이메일|전자.?우편|[Ee]-?mail)(.?주소)?\", // ko-KR\n\n      // ==== Telephone ====\n      tel:\n        \"phone|mobile|contact.?number\" +\n        \"|telefonnummer\" + // de-DE\n        \"|telefono|teléfono\" + // es\n        \"|telfixe\" + // fr-FR\n        \"|電話\" + // ja-JP\n        \"|telefone|telemovel\" + // pt-BR, pt-PT\n        \"|телефон\" + // ru\n        \"|मोबाइल\" + // hi for mobile\n        \"|(\\\\b|_|\\\\*)telefon(\\\\b|_|\\\\*)\" + // tr\n        \"|电话\" + // zh-CN\n        \"|മൊബൈല്‍\" + // ml for mobile\n        \"|(?:전화|핸드폰|휴대폰|휴대전화)(?:.?번호)?\", // ko-KR\n\n      // ==== Address Fields ====\n      organization:\n        \"company|business|organization|organisation\" +\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>confirma)\" +\n        \"|firma|firmenname\" + // de-DE\n        \"|empresa\" + // es\n        \"|societe|société\" + // fr-FR\n        \"|ragione.?sociale\" + // it-IT\n        \"|会社\" + // ja-JP\n        \"|название.?компании\" + // ru\n        \"|单位|公司\" + // zh-CN\n        \"|شرکت\" + // fa\n        \"|회사|직장\", // ko-KR\n\n      \"street-address\": \"streetaddress|street-address\",\n      \"address-line1\":\n        \"^address$|address[_-]?line(one)?|address1|addr1|street\" +\n        \"|(?:shipping|billing)address$\" +\n        \"|strasse|straße|hausnummer|housenumber\" + // de-DE\n        \"|house.?name\" + // en-GB\n        \"|direccion|dirección\" + // es\n        \"|adresse\" + // fr-FR\n        \"|indirizzo\" + // it-IT\n        \"|^住所$|住所1\" + // ja-JP\n        \"|morada\" + // pt-BR, pt-PT\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>identificação do endereço)\" +\n        \"|(endereço)\" + // pt-BR, pt-PT\n        \"|Адрес\" + // ru\n        \"|地址\" + // zh-CN\n        \"|(\\\\b|_)adres(?! (başlığı(nız)?|tarifi))(\\\\b|_)\" + // tr\n        \"|^주소.?$|주소.?1\", // ko-KR\n\n      \"address-line2\":\n        \"address[_-]?line(2|two)|address2|addr2|street|suite|unit(?!e)\" + // Firefox adds `(?!e)` to unit to skip `United State`\n        \"|adresszusatz|ergänzende.?angaben\" + // de-DE\n        \"|direccion2|colonia|adicional\" + // es\n        \"|addresssuppl|complementnom|appartement\" + // fr-FR\n        \"|indirizzo2\" + // it-IT\n        \"|住所2\" + // ja-JP\n        \"|complemento|addrcomplement\" + // pt-BR, pt-PT\n        \"|Улица\" + // ru\n        \"|地址2\" + // zh-CN\n        \"|주소.?2\", // ko-KR\n\n      \"address-line3\":\n        \"address[_-]?line(3|three)|address3|addr3|street|suite|unit(?!e)\" + // Firefox adds `(?!e)` to unit to skip `United State`\n        \"|adresszusatz|ergänzende.?angaben\" + // de-DE\n        \"|direccion3|colonia|adicional\" + // es\n        \"|addresssuppl|complementnom|appartement\" + // fr-FR\n        \"|indirizzo3\" + // it-IT\n        \"|住所3\" + // ja-JP\n        \"|complemento|addrcomplement\" + // pt-BR, pt-PT\n        \"|Улица\" + // ru\n        \"|地址3\" + // zh-CN\n        \"|주소.?3\", // ko-KR\n\n      \"address-level2\":\n        \"city|town\" +\n        \"|\\\\bort\\\\b|stadt\" + // de-DE\n        \"|suburb\" + // en-AU\n        \"|ciudad|provincia|localidad|poblacion\" + // es\n        \"|ville|commune\" + // fr-FR\n        \"|localita\" + // it-IT\n        \"|市区町村\" + // ja-JP\n        \"|cidade\" + // pt-BR, pt-PT\n        \"|Город\" + // ru\n        \"|市\" + // zh-CN\n        \"|分區\" + // zh-TW\n        \"|شهر\" + // fa\n        \"|शहर\" + // hi for city\n        \"|ग्राम|गाँव\" + // hi for village\n        \"|നഗരം|ഗ്രാമം\" + // ml for town|village\n        \"|((\\\\b|_|\\\\*)([İii̇]l[cç]e(miz|niz)?)(\\\\b|_|\\\\*))\" + // tr\n        \"|^시[^도·・]|시[·・]?군[·・]?구\", // ko-KR\n\n      \"address-level1\":\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"(?<neg>united?.state|hist?.state|history?.state)\" +\n        \"|state|county|region|province\" +\n        \"|principality\" + // en-UK\n        \"|都道府県\" + // ja-JP\n        \"|estado|provincia\" + // pt-BR, pt-PT\n        \"|область\" + // ru\n        \"|省\" + // zh-CN\n        \"|地區\" + // zh-TW\n        \"|സംസ്ഥാനം\" + // ml\n        \"|استان\" + // fa\n        \"|राज्य\" + // hi\n        \"|((\\\\b|_|\\\\*)(eyalet|[şs]ehir|[İii̇]l(imiz)?|kent)(\\\\b|_|\\\\*))\" + // tr\n        \"|^시[·・]?도\", // ko-KR\n\n      \"postal-code\":\n        \"zip|postal|post.*code|pcode\" +\n        \"|pin.?code\" + // en-IN\n        \"|postleitzahl\" + // de-DE\n        \"|\\\\bcp\\\\b\" + // es\n        \"|\\\\bcdp\\\\b\" + // fr-FR\n        \"|\\\\bcap\\\\b\" + // it-IT\n        \"|郵便番号\" + // ja-JP\n        \"|codigo|codpos|\\\\bcep\\\\b\" + // pt-BR, pt-PT\n        \"|Почтовый.?Индекс\" + // ru\n        \"|पिन.?कोड\" + // hi\n        \"|പിന്‍കോഡ്\" + // ml\n        \"|邮政编码|邮编\" + // zh-CN\n        \"|郵遞區號\" + // zh-TW\n        \"|(\\\\b|_)posta kodu(\\\\b|_)\" + // tr\n        \"|우편.?번호\", // ko-KR\n\n      country:\n        \"country|countries\" +\n        \"|país|pais\" + // es\n        \"|(\\\\b|_)land(\\\\b|_)(?!.*(mark.*))\" + // de-DE landmark is a type in india.\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>入国|出国)\" +\n        \"|国\" + // ja-JP\n        \"|国家\" + // zh-CN\n        \"|국가|나라\" + // ko-KR\n        \"|(\\\\b|_)(ülke|ulce|ulke)(\\\\b|_)\" + // tr\n        \"|کشور\", // fa\n\n      // ==== Name Fields ====\n      \"cc-name\":\n        \"card.?(?:holder|owner)|name.*(\\\\b)?on(\\\\b)?.*card\" +\n        \"|^(credit[-\\\\s]?card|card).*name|cc.?full.?name\" +\n        \"|karteninhaber\" + // de-DE\n        \"|nombre.*tarjeta\" + // es\n        \"|nom.*carte\" + // fr-FR\n        \"|nome.*cart\" + // it-IT\n        \"|名前\" + // ja-JP\n        \"|Имя.*карты\" + // ru\n        \"|信用卡开户名|开户名|持卡人姓名\" + // zh-CN\n        \"|持卡人姓名\", // zh-TW\n\n      name:\n        \"^name|full.?name|your.?name|customer.?name|bill.?name|ship.?name\" +\n        \"|name.*first.*last|firstandlastname\" +\n        \"|nombre.*y.*apellidos\" + // es\n        \"|^nom(?!bre)\" + // fr-FR\n        \"|お名前|氏名\" + // ja-JP\n        \"|^nome\" + // pt-BR, pt-PT\n        \"|نام.*نام.*خانوادگی\" + // fa\n        \"|姓名\" + // zh-CN\n        \"|(\\\\b|_|\\\\*)ad[ı]? soyad[ı]?(\\\\b|_|\\\\*)\" + // tr\n        \"|성명\", // ko-KR\n\n      \"given-name\":\n        \"first.*name|initials|fname|first$|given.*name\" +\n        \"|vorname\" + // de-DE\n        \"|nombre\" + // es\n        \"|forename|prénom|prenom\" + // fr-FR\n        \"|名\" + // ja-JP\n        \"|nome\" + // pt-BR, pt-PT\n        \"|Имя\" + // ru\n        \"|نام\" + // fa\n        \"|이름\" + // ko-KR\n        \"|പേര്\" + // ml\n        \"|(\\\\b|_|\\\\*)(isim|ad|ad(i|ı|iniz|ınız)?)(\\\\b|_|\\\\*)\" + // tr\n        \"|नाम\", // hi\n\n      \"additional-name\":\n        \"middle.*name|mname|middle$|middle.*initial|m\\\\.i\\\\.|mi$|\\\\bmi\\\\b\",\n\n      \"family-name\":\n        \"last.*name|lname|surname|last$|secondname|family.*name\" +\n        \"|nachname\" + // de-DE\n        \"|apellidos?\" + // es\n        \"|famille|^nom(?!bre)\" + // fr-FR\n        \"|cognome\" + // it-IT\n        \"|姓\" + // ja-JP\n        \"|apelidos|surename|sobrenome\" + // pt-BR, pt-PT\n        \"|Фамилия\" + // ru\n        \"|نام.*خانوادگی\" + // fa\n        \"|उपनाम\" + // hi\n        \"|മറുപേര്\" + // ml\n        \"|(\\\\b|_|\\\\*)(soyisim|soyad(i|ı|iniz|ınız)?)(\\\\b|_|\\\\*)\" + // tr\n        \"|\\\\b성(?:[^명]|\\\\b)\", // ko-KR\n\n      // ==== Credit Card Fields ====\n      // Note: `cc-name` expression has been moved up, above `name`, in\n      // order to handle specialization through ordering.\n      \"cc-number\":\n        \"(add)?(?:card|cc|acct).?(?:number|#|no|num|field)\" +\n        // In order to support webkit we convert all negative lookbehinds to a capture group\n        // (?<!not)word -> (?<neg>notword)|word\n        // TODO: Bug 1829583\n        \"|(?<neg>telefonnummer|hausnummer|personnummer|fødselsnummer)\" + // de-DE, sv-SE, no\n        \"|nummer\" +\n        \"|カード番号\" + // ja-JP\n        \"|Номер.*карты\" + // ru\n        \"|信用卡号|信用卡号码\" + // zh-CN\n        \"|信用卡卡號\" + // zh-TW\n        \"|카드\" + // ko-KR\n        // es/pt/fr\n        \"|(numero|número|numéro)(?!.*(document|fono|phone|réservation))\",\n\n      \"cc-exp-month\":\n        \"expir|exp.*mo|exp.*date|ccmonth|cardmonth|addmonth\" +\n        \"|gueltig|gültig|monat\" + // de-DE\n        \"|fecha\" + // es\n        \"|date.*exp\" + // fr-FR\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\" + // ru\n        \"|月\", // zh-CN\n\n      \"cc-exp-year\":\n        \"exp|^/|(add)?year\" +\n        \"|ablaufdatum|gueltig|gültig|jahr\" + // de-DE\n        \"|fecha\" + // es\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\" + // ru\n        \"|年|有效期\", // zh-CN\n\n      \"cc-exp\":\n        \"expir|exp.*date|^expfield$\" +\n        \"|gueltig|gültig\" + // de-DE\n        \"|fecha\" + // es\n        \"|date.*exp\" + // fr-FR\n        \"|scadenza\" + // it-IT\n        \"|有効期限\" + // ja-JP\n        \"|validade\" + // pt-BR, pt-PT\n        \"|Срок действия карты\", // ru\n\n      \"cc-csc\":\n        \"verification|card.?identification|security.?code|card.?code\" +\n        \"|security.?value\" +\n        \"|security.?number|card.?pin|c-v-v\" +\n        // We omit this regexp in favor of being less generic.\n        // See \"Firefox-specific\" rules for cc-csc\n        // \"|(cvn|cvv|cvc|csc|cvd|cid|ccv)(field)?\" +\n        \"|\\\\bcid\\\\b\",\n    },\n  ],\n\n  LABEL_RULE_SETS: [\n    {\n      \"address-line1\":\n        \"(^\\\\W*address)\" +\n        \"|(address\\\\W*$)\" +\n        \"|(?:shipping|billing|mailing|pick.?up|drop.?off|delivery|sender|postal|\" +\n        \"recipient|home|work|office|school|business|mail)[\\\\s\\\\-]+address\" +\n        \"|address\\\\s+(of|for|to|from)\" +\n        \"|adresse\" +                         // fr-FR\n        \"|indirizzo\" +                       // it-IT\n        \"|住所\" +                            // ja-JP\n        \"|地址\" +                            // zh-CN\n        \"|(\\\\b|_)adres(?! tarifi)(\\\\b|_)\" +  // tr\n        \"|주소\" +                            // ko-KR\n        \"|^alamat\" +                         // id\n        // Should contain street and any other address component, in any order\n        \"|street.*(house|building|apartment|floor)\" +  // en\n        \"|(house|building|apartment|floor).*street\" +\n        \"|(sokak|cadde).*(apartman|bina|daire|mahalle)\" +  // tr\n        \"|(apartman|bina|daire|mahalle).*(sokak|cadde)\" +\n        \"|улиц.*(дом|корпус|квартир|этаж)|(дом|корпус|квартир|этаж).*улиц\",  // ru\n    },\n    {\n      \"address-line2\":\n        \"address|line\" +\n        \"|adresse\" +      // fr-FR\n        \"|indirizzo\" +    // it-IT\n        \"|地址\" +         // zh-CN\n        \"|주소\",          // ko-KR\n    },\n  ],\n\n  _getRules(rules, rulesets) {\n    function computeRule(name) {\n      let regexps = [];\n      rulesets.forEach(set => {\n        if (set[name]) {\n          // Add the rule.\n          // We make the regex lower case so that we can match it against the\n          // lower-cased field name and get a rough equivalent of a case-insensitive\n          // match. This avoids a performance cliff with the \"iu\" flag on regular\n          // expressions.\n          regexps.push(`(${set[name].toLowerCase()})`.normalize(\"NFKC\"));\n        }\n      });\n\n      const value = new RegExp(regexps.join(\"|\"), \"gu\");\n\n      Object.defineProperty(rules, name, { get: undefined });\n      Object.defineProperty(rules, name, { value });\n      return value;\n    }\n\n    Object.keys(rules).forEach(field =>\n      Object.defineProperty(rules, field, {\n        get() {\n          return computeRule(field);\n        },\n      })\n    );\n\n    return rules;\n  },\n\n  getLabelRules() {\n    return this._getRules(this.LABEL_RULES, this.LABEL_RULE_SETS);\n  },\n\n  getRules() {\n    return this._getRules(this.RULES, this.RULE_SETS);\n  },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeuristicsRegExp);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs":
/*!****************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LabelUtils\": () => (/* binding */ LabelUtils),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * This is a utility object to work with HTML labels in web pages,\n * including finding label elements and label text extraction.\n */\nconst LabelUtils = {\n  // The tag name list is from Chromium except for \"STYLE\":\n  // eslint-disable-next-line max-len\n  // https://cs.chromium.org/chromium/src/components/autofill/content/renderer/form_autofill_util.cc?l=216&rcl=d33a171b7c308a64dc3372fac3da2179c63b419e\n  EXCLUDED_TAGS: [\"SCRIPT\", \"NOSCRIPT\", \"OPTION\", \"STYLE\"],\n\n  // A map object, whose keys are the id's of form fields and each value is an\n  // array consisting of label elements correponding to the id.\n  // @type {Map<string, array>}\n  _mappedLabels: null,\n\n  // An array consisting of label elements whose correponding form field doesn't\n  // have an id attribute.\n  // @type {Array<[HTMLLabelElement, HTMLElement]>}\n  _unmappedLabelControls: null,\n\n  // A weak map consisting of label element and extracted strings pairs.\n  // @type {WeakMap<HTMLLabelElement, array>}\n  _labelStrings: null,\n\n  /**\n   * Extract all strings of an element's children to an array.\n   * \"element.textContent\" is a string which is merged of all children nodes,\n   * and this function provides an array of the strings contains in an element.\n   *\n   * @param  {object} element\n   *         A DOM element to be extracted.\n   * @returns {Array}\n   *          All strings in an element.\n   */\n  extractLabelStrings(element) {\n    if (this._labelStrings.has(element)) {\n      return this._labelStrings.get(element);\n    }\n    let strings = [];\n    let _extractLabelStrings = el => {\n      if (this.EXCLUDED_TAGS.includes(el.tagName)) {\n        return;\n      }\n\n      if (el.nodeType == el.TEXT_NODE || !el.childNodes.length) {\n        let trimmedText = el.textContent.trim();\n        if (trimmedText) {\n          strings.push(trimmedText);\n        }\n        return;\n      }\n\n      for (let node of el.childNodes) {\n        let nodeType = node.nodeType;\n        if (nodeType != node.ELEMENT_NODE && nodeType != node.TEXT_NODE) {\n          continue;\n        }\n        _extractLabelStrings(node);\n      }\n    };\n    _extractLabelStrings(element);\n    this._labelStrings.set(element, strings);\n    return strings;\n  },\n\n  generateLabelMap(doc) {\n    this._mappedLabels = new Map();\n    this._unmappedLabelControls = [];\n    this._labelStrings = new WeakMap();\n\n    for (let label of doc.querySelectorAll(\"label\")) {\n      let id = label.htmlFor;\n      let control;\n      if (!id) {\n        control = label.control;\n        if (!control) {\n          continue;\n        }\n        id = control.id;\n      }\n      if (id) {\n        let labels = this._mappedLabels.get(id);\n        if (labels) {\n          labels.push(label);\n        } else {\n          this._mappedLabels.set(id, [label]);\n        }\n      } else {\n        // control must be non-empty here\n        this._unmappedLabelControls.push({ label, control });\n      }\n    }\n  },\n\n  clearLabelMap() {\n    this._mappedLabels = null;\n    this._unmappedLabelControls = null;\n    this._labelStrings = null;\n  },\n\n  findLabelElements(element) {\n    if (!this._mappedLabels) {\n      this.generateLabelMap(element.ownerDocument);\n    }\n\n    let id = element.id;\n    if (!id) {\n      return this._unmappedLabelControls\n        .filter(lc => lc.control == element)\n        .map(lc => lc.label);\n    }\n    return this._mappedLabels.get(id) || [];\n  },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LabelUtils);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.mjs":
/*!*********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Logic\": () => (/* binding */ Logic)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * Code that we can share across Firefox Desktop, Firefox Android and Firefox iOS.\n */\n\nclass Logic {\n  static inputTypeIsCompatibleWithUsername(input) {\n    const fieldType = input.getAttribute(\"type\")?.toLowerCase() || input.type;\n    return (\n      [\"text\", \"email\", \"url\", \"tel\", \"number\", \"search\"].includes(fieldType) ||\n      fieldType?.includes(\"user\")\n    );\n  }\n\n  /**\n   * Test whether the element has the keyword in its attributes.\n   * The tested attributes include id, name, className, and placeholder.\n   */\n  static elementAttrsMatchRegex(element, regex) {\n    if (\n      regex.test(element.id) ||\n      regex.test(element.name) ||\n      regex.test(element.className)\n    ) {\n      return true;\n    }\n\n    const placeholder = element.getAttribute(\"placeholder\");\n    return placeholder && regex.test(placeholder);\n  }\n\n  /**\n   * Test whether associated labels of the element have the keyword.\n   * This is a simplified rule of hasLabelMatchingRegex in NewPasswordModel.sys.mjs\n   */\n  static hasLabelMatchingRegex(element, regex) {\n    return regex.test(element.labels?.[0]?.textContent);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js":
/*!**************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\n\n// This array defines overrides that webpack will use when bundling the JS on iOS\n// in order to load the right modules\nconst ModuleOverrides = {\n  \"AppConstants.sys.mjs\": \"Helpers.ios.mjs\",\n  \"XPCOMUtils.sys.mjs\": \"Helpers.ios.mjs\",\n  \"Region.sys.mjs\": \"Helpers.ios.mjs\",\n  \"OSKeyStore.sys.mjs\": \"Helpers.ios.mjs\",\n  \"FormAutofill.sys.mjs\": \"FormAutofill.ios.sys.mjs\",\n  \"EntryFile.sys.mjs\": \"FormAutofillChild.ios.sys.mjs\",\n};\n\n// We need this because not all webpack libraries used in iOS are ES Modules\n// Hence we defer to CommonJS.\n// eslint-disable-next-line no-undef\nmodule.exports = { ModuleOverrides };\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/Overrides.ios.js?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs":
/*!*****************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhoneNumber\": () => (/* binding */ PhoneNumber)\n/* harmony export */ });\n/* harmony import */ var resource_gre_modules_shared_PhoneNumberMetaData_sys_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/PhoneNumberMetaData.sys.mjs */ \"./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs\");\n/* This Source Code Form is subject to the terms of the Apache License, Version\n * 2.0. If a copy of the Apache License was not distributed with this file, You\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\n\n// This library came from https://github.com/andreasgal/PhoneNumber.js but will\n// be further maintained by our own in Form Autofill codebase.\n\n\n\nconst lazy = {};\n\nChromeUtils.defineESModuleGetters(lazy, {\n  PhoneNumberNormalizer:\n    \"resource://gre/modules/shared/PhoneNumberNormalizer.sys.mjs\",\n});\n\nvar PhoneNumber = (function (dataBase) {\n  const MAX_PHONE_NUMBER_LENGTH = 50;\n  const NON_ALPHA_CHARS = /[^a-zA-Z]/g;\n  const NON_DIALABLE_CHARS = /[^,#+\\*\\d]/g;\n  const NON_DIALABLE_CHARS_ONCE = new RegExp(NON_DIALABLE_CHARS.source);\n  const SPLIT_FIRST_GROUP = /^(\\d+)(.*)$/;\n  const LEADING_PLUS_CHARS_PATTERN = /^[+\\uFF0B]+/g;\n\n  // Format of the string encoded meta data. If the name contains \"^\" or \"$\"\n  // we will generate a regular expression from the value, with those special\n  // characters as prefix/suffix.\n  const META_DATA_ENCODING = [\n    \"region\",\n    \"^(?:internationalPrefix)\",\n    \"nationalPrefix\",\n    \"^(?:nationalPrefixForParsing)\",\n    \"nationalPrefixTransformRule\",\n    \"nationalPrefixFormattingRule\",\n    \"^possiblePattern$\",\n    \"^nationalPattern$\",\n    \"formats\",\n  ];\n\n  const FORMAT_ENCODING = [\n    \"^pattern$\",\n    \"nationalFormat\",\n    \"^leadingDigits\",\n    \"nationalPrefixFormattingRule\",\n    \"internationalFormat\",\n  ];\n\n  let regionCache = Object.create(null);\n\n  // Parse an array of strings into a convenient object. We store meta\n  // data as arrays since thats much more compact than JSON.\n  function ParseArray(array, encoding, obj) {\n    for (let n = 0; n < encoding.length; ++n) {\n      let value = array[n];\n      if (!value) {\n        continue;\n      }\n      let field = encoding[n];\n      let fieldAlpha = field.replace(NON_ALPHA_CHARS, \"\");\n      if (field != fieldAlpha) {\n        value = new RegExp(field.replace(fieldAlpha, value));\n      }\n      obj[fieldAlpha] = value;\n    }\n    return obj;\n  }\n\n  // Parse string encoded meta data into a convenient object\n  // representation.\n  function ParseMetaData(countryCode, md) {\n    let array = JSON.parse(md);\n    md = ParseArray(array, META_DATA_ENCODING, { countryCode });\n    regionCache[md.region] = md;\n    return md;\n  }\n\n  // Parse string encoded format data into a convenient object\n  // representation.\n  function ParseFormat(md) {\n    let formats = md.formats;\n    if (!formats) {\n      return;\n    }\n    // Bail if we already parsed the format definitions.\n    if (!Array.isArray(formats[0])) {\n      return;\n    }\n    for (let n = 0; n < formats.length; ++n) {\n      formats[n] = ParseArray(formats[n], FORMAT_ENCODING, {});\n    }\n  }\n\n  // Search for the meta data associated with a region identifier (\"US\") in\n  // our database, which is indexed by country code (\"1\"). Since we have\n  // to walk the entire database for this, we cache the result of the lookup\n  // for future reference.\n  function FindMetaDataForRegion(region) {\n    // Check in the region cache first. This will find all entries we have\n    // already resolved (parsed from a string encoding).\n    let md = regionCache[region];\n    if (md) {\n      return md;\n    }\n    for (let countryCode in dataBase) {\n      let entry = dataBase[countryCode];\n      // Each entry is a string encoded object of the form '[\"US..', or\n      // an array of strings. We don't want to parse the string here\n      // to save memory, so we just substring the region identifier\n      // and compare it. For arrays, we compare against all region\n      // identifiers with that country code. We skip entries that are\n      // of type object, because they were already resolved (parsed into\n      // an object), and their country code should have been in the cache.\n      if (Array.isArray(entry)) {\n        for (let n = 0; n < entry.length; n++) {\n          if (typeof entry[n] == \"string\" && entry[n].substr(2, 2) == region) {\n            if (n > 0) {\n              // Only the first entry has the formats field set.\n              // Parse the main country if we haven't already and use\n              // the formats field from the main country.\n              if (typeof entry[0] == \"string\") {\n                entry[0] = ParseMetaData(countryCode, entry[0]);\n              }\n              let formats = entry[0].formats;\n              let current = ParseMetaData(countryCode, entry[n]);\n              current.formats = formats;\n              entry[n] = current;\n              return entry[n];\n            }\n\n            entry[n] = ParseMetaData(countryCode, entry[n]);\n            return entry[n];\n          }\n        }\n        continue;\n      }\n      if (typeof entry == \"string\" && entry.substr(2, 2) == region) {\n        dataBase[countryCode] = ParseMetaData(countryCode, entry);\n        return dataBase[countryCode];\n      }\n    }\n  }\n\n  // Format a national number for a given region. The boolean flag \"intl\"\n  // indicates whether we want the national or international format.\n  function FormatNumber(regionMetaData, number, intl) {\n    // We lazily parse the format description in the meta data for the region,\n    // so make sure to parse it now if we haven't already done so.\n    ParseFormat(regionMetaData);\n    let formats = regionMetaData.formats;\n    if (!formats) {\n      return null;\n    }\n    for (let n = 0; n < formats.length; ++n) {\n      let format = formats[n];\n      // The leading digits field is optional. If we don't have it, just\n      // use the matching pattern to qualify numbers.\n      if (format.leadingDigits && !format.leadingDigits.test(number)) {\n        continue;\n      }\n      if (!format.pattern.test(number)) {\n        continue;\n      }\n      if (intl) {\n        // If there is no international format, just fall back to the national\n        // format.\n        let internationalFormat = format.internationalFormat;\n        if (!internationalFormat) {\n          internationalFormat = format.nationalFormat;\n        }\n        // Some regions have numbers that can't be dialed from outside the\n        // country, indicated by \"NA\" for the international format of that\n        // number format pattern.\n        if (internationalFormat == \"NA\") {\n          return null;\n        }\n        // Prepend \"+\" and the country code.\n        number =\n          \"+\" +\n          regionMetaData.countryCode +\n          \" \" +\n          number.replace(format.pattern, internationalFormat);\n      } else {\n        number = number.replace(format.pattern, format.nationalFormat);\n        // The region has a national prefix formatting rule, and it can be overwritten\n        // by each actual number format rule.\n        let nationalPrefixFormattingRule =\n          regionMetaData.nationalPrefixFormattingRule;\n        if (format.nationalPrefixFormattingRule) {\n          nationalPrefixFormattingRule = format.nationalPrefixFormattingRule;\n        }\n        if (nationalPrefixFormattingRule) {\n          // The prefix formatting rule contains two magic markers, \"$NP\" and \"$FG\".\n          // \"$NP\" will be replaced by the national prefix, and \"$FG\" with the\n          // first group of numbers.\n          let match = number.match(SPLIT_FIRST_GROUP);\n          if (match) {\n            let firstGroup = match[1];\n            let rest = match[2];\n            let prefix = nationalPrefixFormattingRule;\n            prefix = prefix.replace(\"$NP\", regionMetaData.nationalPrefix);\n            prefix = prefix.replace(\"$FG\", firstGroup);\n            number = prefix + rest;\n          }\n        }\n      }\n      return number == \"NA\" ? null : number;\n    }\n    return null;\n  }\n\n  function NationalNumber(regionMetaData, number) {\n    this.region = regionMetaData.region;\n    this.regionMetaData = regionMetaData;\n    this.number = number;\n  }\n\n  // NationalNumber represents the result of parsing a phone number. We have\n  // three getters on the prototype that format the number in national and\n  // international format. Once called, the getters put a direct property\n  // onto the object, caching the result.\n  NationalNumber.prototype = {\n    // +1 949-726-2896\n    get internationalFormat() {\n      let value = FormatNumber(this.regionMetaData, this.number, true);\n      Object.defineProperty(this, \"internationalFormat\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // (949) 726-2896\n    get nationalFormat() {\n      let value = FormatNumber(this.regionMetaData, this.number, false);\n      Object.defineProperty(this, \"nationalFormat\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // +19497262896\n    get internationalNumber() {\n      let value = this.internationalFormat\n        ? this.internationalFormat.replace(NON_DIALABLE_CHARS, \"\")\n        : null;\n      Object.defineProperty(this, \"internationalNumber\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // 9497262896\n    get nationalNumber() {\n      let value = this.nationalFormat\n        ? this.nationalFormat.replace(NON_DIALABLE_CHARS, \"\")\n        : null;\n      Object.defineProperty(this, \"nationalNumber\", {\n        value,\n        enumerable: true,\n      });\n      return value;\n    },\n    // country name 'US'\n    get countryName() {\n      let value = this.region ? this.region : null;\n      Object.defineProperty(this, \"countryName\", { value, enumerable: true });\n      return value;\n    },\n    // country code '+1'\n    get countryCode() {\n      let value = this.regionMetaData.countryCode\n        ? \"+\" + this.regionMetaData.countryCode\n        : null;\n      Object.defineProperty(this, \"countryCode\", { value, enumerable: true });\n      return value;\n    },\n  };\n\n  // Check whether the number is valid for the given region.\n  function IsValidNumber(number, md) {\n    return md.possiblePattern.test(number);\n  }\n\n  // Check whether the number is a valid national number for the given region.\n  /* eslint-disable no-unused-vars */\n  function IsNationalNumber(number, md) {\n    return IsValidNumber(number, md) && md.nationalPattern.test(number);\n  }\n\n  // Determine the country code a number starts with, or return null if\n  // its not a valid country code.\n  function ParseCountryCode(number) {\n    for (let n = 1; n <= 3; ++n) {\n      let cc = number.substr(0, n);\n      if (dataBase[cc]) {\n        return cc;\n      }\n    }\n    return null;\n  }\n\n  // Parse a national number for a specific region. Return null if the\n  // number is not a valid national number (it might still be a possible\n  // number for parts of that region).\n  function ParseNationalNumber(number, md) {\n    if (!md.possiblePattern.test(number) || !md.nationalPattern.test(number)) {\n      return null;\n    }\n    // Success.\n    return new NationalNumber(md, number);\n  }\n\n  function ParseNationalNumberAndCheckNationalPrefix(number, md) {\n    let ret;\n\n    // This is not an international number. See if its a national one for\n    // the current region. National numbers can start with the national\n    // prefix, or without.\n    if (md.nationalPrefixForParsing) {\n      // Some regions have specific national prefix parse rules. Apply those.\n      let withoutPrefix = number.replace(\n        md.nationalPrefixForParsing,\n        md.nationalPrefixTransformRule || \"\"\n      );\n      ret = ParseNationalNumber(withoutPrefix, md);\n      if (ret) {\n        return ret;\n      }\n    } else {\n      // If there is no specific national prefix rule, just strip off the\n      // national prefix from the beginning of the number (if there is one).\n      let nationalPrefix = md.nationalPrefix;\n      if (\n        nationalPrefix &&\n        number.indexOf(nationalPrefix) == 0 &&\n        (ret = ParseNationalNumber(number.substr(nationalPrefix.length), md))\n      ) {\n        return ret;\n      }\n    }\n    ret = ParseNationalNumber(number, md);\n    if (ret) {\n      return ret;\n    }\n  }\n\n  function ParseNumberByCountryCode(number, countryCode) {\n    let ret;\n\n    // Lookup the meta data for the region (or regions) and if the rest of\n    // the number parses for that region, return the parsed number.\n    let entry = dataBase[countryCode];\n    if (Array.isArray(entry)) {\n      for (let n = 0; n < entry.length; ++n) {\n        if (typeof entry[n] == \"string\") {\n          entry[n] = ParseMetaData(countryCode, entry[n]);\n        }\n        if (n > 0) {\n          entry[n].formats = entry[0].formats;\n        }\n        ret = ParseNationalNumberAndCheckNationalPrefix(number, entry[n]);\n        if (ret) {\n          return ret;\n        }\n      }\n      return null;\n    }\n    if (typeof entry == \"string\") {\n      entry = dataBase[countryCode] = ParseMetaData(countryCode, entry);\n    }\n    return ParseNationalNumberAndCheckNationalPrefix(number, entry);\n  }\n\n  // Parse an international number that starts with the country code. Return\n  // null if the number is not a valid international number.\n  function ParseInternationalNumber(number) {\n    // Parse and strip the country code.\n    let countryCode = ParseCountryCode(number);\n    if (!countryCode) {\n      return null;\n    }\n    number = number.substr(countryCode.length);\n\n    return ParseNumberByCountryCode(number, countryCode);\n  }\n\n  // Parse a number and transform it into the national format, removing any\n  // international dial prefixes and country codes.\n  function ParseNumber(number, defaultRegion) {\n    let ret;\n\n    // Remove formating characters and whitespace.\n    number = lazy.PhoneNumberNormalizer.Normalize(number);\n\n    // If there is no defaultRegion or the defaultRegion is the global region,\n    // we can't parse international access codes.\n    if ((!defaultRegion || defaultRegion === \"001\") && number[0] !== \"+\") {\n      return null;\n    }\n\n    // Detect and strip leading '+'.\n    if (number[0] === \"+\") {\n      return ParseInternationalNumber(\n        number.replace(LEADING_PLUS_CHARS_PATTERN, \"\")\n      );\n    }\n\n    // If \"defaultRegion\" is a country code, use it to parse the number directly.\n    let matches = String(defaultRegion).match(/^\\+?(\\d+)/);\n    if (matches) {\n      let countryCode = ParseCountryCode(matches[1]);\n      if (!countryCode) {\n        return null;\n      }\n      return ParseNumberByCountryCode(number, countryCode);\n    }\n\n    // Lookup the meta data for the given region.\n    let md = FindMetaDataForRegion(defaultRegion.toUpperCase());\n    if (!md) {\n      dump(\"Couldn't find Meta Data for region: \" + defaultRegion + \"\\n\");\n      return null;\n    }\n\n    // See if the number starts with an international prefix, and if the\n    // number resulting from stripping the code is valid, then remove the\n    // prefix and flag the number as international.\n    if (md.internationalPrefix.test(number)) {\n      let possibleNumber = number.replace(md.internationalPrefix, \"\");\n      ret = ParseInternationalNumber(possibleNumber);\n      if (ret) {\n        return ret;\n      }\n    }\n\n    ret = ParseNationalNumberAndCheckNationalPrefix(number, md);\n    if (ret) {\n      return ret;\n    }\n\n    // Now lets see if maybe its an international number after all, but\n    // without '+' or the international prefix.\n    ret = ParseInternationalNumber(number);\n    if (ret) {\n      return ret;\n    }\n\n    // If the number matches the possible numbers of the current region,\n    // return it as a possible number.\n    if (md.possiblePattern.test(number)) {\n      return new NationalNumber(md, number);\n    }\n\n    // We couldn't parse the number at all.\n    return null;\n  }\n\n  function IsPlainPhoneNumber(number) {\n    if (typeof number !== \"string\") {\n      return false;\n    }\n\n    let length = number.length;\n    let isTooLong = length > MAX_PHONE_NUMBER_LENGTH;\n    let isEmpty = length === 0;\n    return !(isTooLong || isEmpty || NON_DIALABLE_CHARS_ONCE.test(number));\n  }\n\n  return {\n    IsPlain: IsPlainPhoneNumber,\n    IsValid: IsValidNumber,\n    Parse: ParseNumber,\n    FindMetaDataForRegion,\n  };\n})(resource_gre_modules_shared_PhoneNumberMetaData_sys_mjs__WEBPACK_IMPORTED_MODULE_0__.PHONE_NUMBER_META_DATA);\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs":
/*!*************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PHONE_NUMBER_META_DATA\": () => (/* binding */ PHONE_NUMBER_META_DATA)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Apache License, Version\n * 2.0. If a copy of the Apache License was not distributed with this file, You\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\n\n/*\n * This data was generated base on libphonenumber v8.4.1 via the script in\n * https://github.com/andreasgal/PhoneNumber.js\n *\n * The XML format of libphonenumber has changed since v8.4.2 so we can only stay\n * in this version for now.\n */\n\nvar PHONE_NUMBER_META_DATA = {\n  46: '[\"SE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,12}\",\"[1-35-9]\\\\\\\\d{5,11}|4\\\\\\\\d{6,8}\",[[\"(8)(\\\\\\\\d{2,3})(\\\\\\\\d{2,3})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"8\",null,\"$1 $2 $3 $4\"],[\"([1-69]\\\\\\\\d)(\\\\\\\\d{2,3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"1[013689]|2[0136]|3[1356]|4[0246]|54|6[03]|90\",null,\"$1 $2 $3 $4\"],[\"([1-469]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1-$2 $3\",\"1[136]|2[136]|3[356]|4[0246]|6[03]|90\",null,\"$1 $2 $3\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[0-5]|4[0-3])\",null,\"$1 $2 $3 $4\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2,3})(\\\\\\\\d{2})\",\"$1-$2 $3\",\"1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[0-5]|4[0-3])\",null,\"$1 $2 $3\"],[\"(7\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4\",\"7\",null,\"$1 $2 $3 $4\"],[\"(77)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2$3\",\"7\",null,\"$1 $2 $3\"],[\"(20)(\\\\\\\\d{2,3})(\\\\\\\\d{2})\",\"$1-$2 $3\",\"20\",null,\"$1 $2 $3\"],[\"(9[034]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1-$2 $3 $4\",\"9[034]\",null,\"$1 $2 $3 $4\"],[\"(9[034]\\\\\\\\d)(\\\\\\\\d{4})\",\"$1-$2\",\"9[034]\",null,\"$1 $2\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2 $3 $4 $5\",\"25[245]|67[3-6]\",null,\"$1 $2 $3 $4 $5\"]]]',\n  299: '[\"GL\",\"00\",null,null,null,null,\"\\\\\\\\d{6}\",\"[1-689]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  385: '[\"HR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[1-7]\\\\\\\\d{5,8}|[89]\\\\\\\\d{6,8}\",[[\"(1)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1\",null],[\"([2-5]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[2-5]\",null],[\"(9\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"9\",null],[\"(6[01])(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"6[01]\",null],[\"([67]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[67]\",null],[\"(80[01])(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"8\",null],[\"(80[01])(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8\",null]]]',\n  670: '[\"TL\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-489]\\\\\\\\d{6}|7\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-489]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"7\",null]]]',\n  258: '[\"MZ\",\"00\",null,null,null,null,\"\\\\\\\\d{8,9}\",\"[28]\\\\\\\\d{7,8}\",[[\"([28]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2|8[2-7]\",null],[\"(80\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"80\",null]]]',\n  359: '[\"BG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[23567]\\\\\\\\d{5,7}|[489]\\\\\\\\d{6,8}\",[[\"(2)(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"2\",null],[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"43[124-7]|70[1-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"43[124-7]|70[1-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[78]00\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"999\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"48|8[7-9]|9[08]\",null]]]',\n  682: '[\"CK\",\"00\",null,null,null,null,\"\\\\\\\\d{5}\",\"[2-8]\\\\\\\\d{4}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",null,null]]]',\n  852: '[\"HK\",\"00(?:[126-9]|30|5[09])?\",null,null,null,null,\"\\\\\\\\d{5,11}\",\"[235-7]\\\\\\\\d{7}|8\\\\\\\\d{7,8}|9\\\\\\\\d{4,10}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[235-7]|[89](?:0[1-9]|[1-9])\",null],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"800\",null],[\"(900)(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"900\",null],[\"(900)(\\\\\\\\d{2,5})\",\"$1 $2\",\"900\",null]]]',\n  998: '[\"UZ\",\"810\",\"8\",null,null,\"$NP $FG\",\"\\\\\\\\d{7,9}\",\"[679]\\\\\\\\d{8}\",[[\"([679]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  291: '[\"ER\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,7}\",\"[178]\\\\\\\\d{6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  95: '[\"MM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"[1478]\\\\\\\\d{5,7}|[256]\\\\\\\\d{5,8}|9(?:[279]\\\\\\\\d{0,2}|[58]|[34]\\\\\\\\d{1,2}|6\\\\\\\\d?)\\\\\\\\d{6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"1|2[245]\",null],[\"(2)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"251\",null],[\"(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"16|2\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"67|81\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[4-8]\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{4,6})\",\"$1 $2 $3\",\"9(?:2[0-4]|[35-9]|4[137-9])\",null],[\"(9)([34]\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9(?:3[0-36]|4[0-57-9])\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"92[56]\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"93\",null]]]',\n  266: '[\"LS\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2568]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  245: '[\"GW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,9}\",\"(?:4(?:0\\\\\\\\d{5}|4\\\\\\\\d{7})|9\\\\\\\\d{8})\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"44|9[567]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"40\",null]]]',\n  374: '[\"AM\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{5,8}\",\"[1-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",\"1|47\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",\"4[1349]|[5-7]|9[1-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"[23]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8|90\",\"$NP $FG\"]]]',\n  61: [\n    '[\"AU\",\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"1\\\\\\\\d{4,9}|[2-578]\\\\\\\\d{8}\",[[\"([2378])(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2378]\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[45]|14\",\"$NP$FG\"],[\"(16)(\\\\\\\\d{3,4})\",\"$1 $2\",\"16\",\"$NP$FG\"],[\"(16)(\\\\\\\\d{3})(\\\\\\\\d{2,4})\",\"$1 $2 $3\",\"16\",\"$NP$FG\"],[\"(1[389]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1(?:[38]0|90)\",\"$FG\"],[\"(180)(2\\\\\\\\d{3})\",\"$1 $2\",\"180\",\"$FG\"],[\"(19\\\\\\\\d)(\\\\\\\\d{3})\",\"$1 $2\",\"19[13]\",\"$FG\"],[\"(19\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"19[679]\",\"$FG\"],[\"(13)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"13[1-9]\",\"$FG\"]]]',\n    '[\"CC\",\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[1458]\\\\\\\\d{5,9}\"]',\n    '[\"CX\",\"(?:14(?:1[14]|34|4[17]|[56]6|7[47]|88))?001[14-689]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[1458]\\\\\\\\d{5,9}\"]',\n  ],\n  500: '[\"FK\",\"00\",null,null,null,null,\"\\\\\\\\d{5}\",\"[2-7]\\\\\\\\d{4}\"]',\n  261: '[\"MG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[23]\\\\\\\\d{8}\",[[\"([23]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  92: '[\"PK\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{6,12}\",\"1\\\\\\\\d{8}|[2-8]\\\\\\\\d{5,11}|9(?:[013-9]\\\\\\\\d{4,9}|2\\\\\\\\d(?:111\\\\\\\\d{6}|\\\\\\\\d{3,7}))\",[[\"(\\\\\\\\d{2})(111)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)1\",null],[\"(\\\\\\\\d{3})(111)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"2[349]|45|54|60|72|8[2-5]|9[2-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{7,8})\",\"$1 $2\",\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{6,7})\",\"$1 $2\",\"2[349]|45|54|60|72|8[2-5]|9[2-9]\",null],[\"(3\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2\",\"3\",\"$NP$FG\"],[\"([15]\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"58[12]|1\",null],[\"(586\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"586\",null],[\"([89]00)(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"[89]00\",\"$NP$FG\"]]]',\n  234: '[\"NG\",\"009\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,14}\",\"[1-6]\\\\\\\\d{5,8}|9\\\\\\\\d{5,9}|[78]\\\\\\\\d{5,13}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[12]|9(?:0[3-9]|[1-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"[3-6]|7(?:[1-79]|0[1-9])|8[2-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"70|8[01]|90[235-9]\",null],[\"([78]00)(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1 $2 $3\",\"[78]00\",null],[\"([78]00)(\\\\\\\\d{5})(\\\\\\\\d{5,6})\",\"$1 $2 $3\",\"[78]00\",null],[\"(78)(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"78\",null]]]',\n  350: '[\"GI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2568]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"2\",null]]]',\n  45: '[\"DK\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  963: '[\"SY\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[1-59]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[1-5]\",null],[\"(9\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"9\",null]]]',\n  226: '[\"BF\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[25-7]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  974: '[\"QA\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-8]\\\\\\\\d{6,7}\",[[\"([28]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[28]\",null],[\"([3-7]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[3-7]\",null]]]',\n  218: '[\"LY\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[25679]\\\\\\\\d{8}\",[[\"([25679]\\\\\\\\d)(\\\\\\\\d{7})\",\"$1-$2\",null,null]]]',\n  51: '[\"PE\",\"19(?:1[124]|77|90)00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{6,9}\",\"[14-9]\\\\\\\\d{7,8}\",[[\"(1)(\\\\\\\\d{7})\",\"$1 $2\",\"1\",null],[\"([4-8]\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"[4-7]|8[2-4]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"80\",null],[\"(9\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"9\",\"$FG\"]]]',\n  62: '[\"ID\",\"0(?:0[1789]|10(?:00|1[67]))\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"(?:[1-79]\\\\\\\\d{6,10}|8\\\\\\\\d{7,11})\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5,8})\",\"$1 $2\",\"2[124]|[36]1\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{5,8})\",\"$1 $2\",\"[4579]|2[035-9]|[36][02-9]\",\"($NP$FG)\"],[\"(8\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{3})\",\"$1-$2-$3\",\"8[1-35-9]\",null],[\"(8\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1-$2-$3\",\"8[1-35-9]\",null],[\"(1)(500)(\\\\\\\\d{3})\",\"$1 $2 $3\",\"15\",\"$FG\"],[\"(177)(\\\\\\\\d{6,8})\",\"$1 $2\",\"17\",null],[\"(800)(\\\\\\\\d{5,7})\",\"$1 $2\",\"800\",null],[\"(804)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"804\",null],[\"(80\\\\\\\\d)(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"80[79]\",null]]]',\n  298: '[\"FO\",\"00\",null,\"(10(?:01|[12]0|88))\",null,null,\"\\\\\\\\d{6}\",\"[2-9]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{6})\",\"$1\",null,null]]]',\n  381: '[\"RS\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"[126-9]\\\\\\\\d{4,11}|3(?:[0-79]\\\\\\\\d{3,10}|8[2-9]\\\\\\\\d{2,9})\",[[\"([23]\\\\\\\\d{2})(\\\\\\\\d{4,9})\",\"$1 $2\",\"(?:2[389]|39)0\",null],[\"([1-3]\\\\\\\\d)(\\\\\\\\d{5,10})\",\"$1 $2\",\"1|2(?:[0-24-7]|[389][1-9])|3(?:[0-8]|9[1-9])\",null],[\"(6\\\\\\\\d)(\\\\\\\\d{6,8})\",\"$1 $2\",\"6\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3,9})\",\"$1 $2\",\"[89]\",null],[\"(7[26])(\\\\\\\\d{4,9})\",\"$1 $2\",\"7[26]\",null],[\"(7[08]\\\\\\\\d)(\\\\\\\\d{4,9})\",\"$1 $2\",\"7[08]\",null]]]',\n  975: '[\"BT\",\"00\",null,null,null,null,\"\\\\\\\\d{6,8}\",\"[1-8]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"1|77\",null],[\"([2-8])(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-68]|7[246]\",null]]]',\n  34: '[\"ES\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[5-9]\\\\\\\\d{8}\",[[\"([89]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[89]00\",null],[\"([5-9]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[568]|[79][0-8]\",null]]]',\n  881: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}\",\"[67]\\\\\\\\d{8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2 $3\",\"[67]\",null]]]',\n  855: '[\"KH\",\"00[14-9]\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[1-9]\\\\\\\\d{7,9}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"1\\\\\\\\d[1-9]|[2-9]\",\"$NP$FG\"],[\"(1[89]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1[89]0\",null]]]',\n  420: '[\"CZ\",\"00\",null,null,null,null,\"\\\\\\\\d{9,12}\",\"[2-8]\\\\\\\\d{8}|9\\\\\\\\d{8,11}\",[[\"([2-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-8]|9[015-7]\",null],[\"(96\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"96\",null],[\"(9\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"9[36]\",null]]]',\n  216: '[\"TN\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-57-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  673: '[\"BN\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-578]\\\\\\\\d{6}\",[[\"([2-578]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  290: [\n    '[\"SH\",\"00\",null,null,null,null,\"\\\\\\\\d{4,5}\",\"[256]\\\\\\\\d{4}\"]',\n    '[\"TA\",\"00\",null,null,null,null,\"\\\\\\\\d{4}\",\"8\\\\\\\\d{3}\"]',\n  ],\n  882: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{7,12}\",\"[13]\\\\\\\\d{6,11}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3[23]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"16|342\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"34[57]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"348\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"16\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,5})(\\\\\\\\d{5})\",\"$1 $2 $3\",\"16|39\",null]]]',\n  267: '[\"BW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-79]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-6]\",null],[\"(7\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"7\",null],[\"(90)(\\\\\\\\d{5})\",\"$1 $2\",\"9\",null]]]',\n  94: '[\"LK\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[1-9]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{1})(\\\\\\\\d{6})\",\"$1 $2 $3\",\"[1-689]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7\",null]]]',\n  356: '[\"MT\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2357-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  375: '[\"BY\",\"810\",\"8\",\"8?0?\",null,null,\"\\\\\\\\d{5,11}\",\"[1-4]\\\\\\\\d{8}|800\\\\\\\\d{3,7}|[89]\\\\\\\\d{9,10}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"17[0-3589]|2[4-9]|[34]\",\"$NP 0$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"1(?:5[24]|6[235]|7[467])|2(?:1[246]|2[25]|3[26])\",\"$NP 0$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2-$3\",\"1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])\",\"$NP 0$FG\"],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8[01]|9\",\"$NP $FG\"],[\"(82\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"82\",\"$NP $FG\"],[\"(800)(\\\\\\\\d{3})\",\"$1 $2\",\"800\",\"$NP $FG\"],[\"(800)(\\\\\\\\d{2})(\\\\\\\\d{2,4})\",\"$1 $2 $3\",\"800\",\"$NP $FG\"]]]',\n  690: '[\"TK\",\"00\",null,null,null,null,\"\\\\\\\\d{4,7}\",\"[2-47]\\\\\\\\d{3,6}\"]',\n  507: '[\"PA\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[1-9]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[1-57-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"6\",null]]]',\n  692: '[\"MH\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}\",\"[2-6]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",null,null]]]',\n  250: '[\"RW\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{8,9}\",\"[027-9]\\\\\\\\d{7,8}\",[[\"(2\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2\",\"$FG\"],[\"([7-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[7-9]\",\"$NP$FG\"],[\"(0\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"0\",null]]]',\n  81: '[\"JP\",\"010\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,17}\",\"[1-9]\\\\\\\\d{8,9}|00(?:[36]\\\\\\\\d{7,14}|7\\\\\\\\d{5,7}|8\\\\\\\\d{7})\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2-$3\",\"(?:12|57|99)0\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"800\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"0077\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1-$2-$3\",\"0077\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"0088\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{5})(\\\\\\\\d{5,6})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{6})(\\\\\\\\d{6,7})\",\"$1-$2-$3\",\"00(?:37|66)\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[2579]0|80[1-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|5(?:76|97)|499|746|8(?:3[89]|63|47|51)|9(?:49|80|9[16])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:2[3-6]|3[3-9]|4[2-6]|5[2-8]|[68][2-7]|7[2-689]|9[1-578])|2(?:2[03-689]|3[3-58]|4[0-468]|5[04-8]|6[013-8]|7[06-9]|8[02-57-9]|9[13])|4(?:2[28]|3[689]|6[035-7]|7[05689]|80|9[3-5])|5(?:3[1-36-9]|4[4578]|5[013-8]|6[1-9]|7[2-8]|8[14-7]|9[4-9])|7(?:2[15]|3[5-9]|4[02-9]|6[135-8]|7[0-4689]|9[014-9])|8(?:2[49]|3[3-8]|4[5-8]|5[2-9]|6[35-9]|7[579]|8[03-579]|9[2-8])|9(?:[23]0|4[02-46-9]|5[024-79]|6[4-9]|7[2-47-9]|8[02-7]|9[3-7])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1|2(?:2[37]|5[5-9]|64|78|8[39]|91)|4(?:2[2689]|64|7[347])|5(?:[2-589]|39)|60|8(?:[46-9]|3[279]|2[124589])|9(?:[235-8]|93)\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"2(?:9[14-79]|74|[34]7|[56]9)|82|993\",null],[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"3|4(?:2[09]|7[01])|6[1-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[2479][1-9]\",null]]]',\n  237: '[\"CM\",\"00\",null,null,null,null,\"\\\\\\\\d{8,9}\",\"[2368]\\\\\\\\d{7,8}\",[[\"([26])(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"[26]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[23]|88\",null],[\"(800)(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"80\",null]]]',\n  351: '[\"PT\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[2-46-9]\\\\\\\\d{8}\",[[\"(2\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[12]\",null],[\"([2-46-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[3-9]|[346-9]\",null]]]',\n  246: '[\"IO\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"3\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  227: '[\"NE\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[0289]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[289]|09\",null],[\"(08)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"08\",null]]]',\n  27: '[\"ZA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[1-79]\\\\\\\\d{8}|8\\\\\\\\d{4,8}\",[[\"(860)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"860\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1 $2\",\"8[1-4]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"8[1-4]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[1-79]|8(?:[0-57]|6[1-9])\",null]]]',\n  962: '[\"JO\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[235-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2356]|87\",\"($NP$FG)\"],[\"(7)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7[457-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"70|8[0158]|9\",null]]]',\n  387: '[\"BA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[3-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2-$3\",\"[3-5]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"6[1-356]|[7-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"6[047]\",null]]]',\n  33: '[\"FR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[1-9]\\\\\\\\d{8}\",[[\"([1-79])(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"[1-79]\",null],[\"(1\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",\"11\",\"$FG\",\"NA\"],[\"(8\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"8\",\"$NP $FG\"]]]',\n  972: '[\"IL\",\"0(?:0|1[2-9])\",\"0\",null,null,\"$FG\",\"\\\\\\\\d{4,12}\",\"1\\\\\\\\d{6,11}|[2-589]\\\\\\\\d{3}(?:\\\\\\\\d{3,6})?|6\\\\\\\\d{3}|7\\\\\\\\d{6,9}\",[[\"([2-489])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[2-489]\",\"$NP$FG\"],[\"([57]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[57]\",\"$NP$FG\"],[\"(153)(\\\\\\\\d{1,2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3 $4\",\"153\",null],[\"(1)([7-9]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2-$3-$4\",\"1[7-9]\",null],[\"(1255)(\\\\\\\\d{3})\",\"$1-$2\",\"125\",null],[\"(1200)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2-$3\",\"120\",null],[\"(1212)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2-$3\",\"121\",null],[\"(1599)(\\\\\\\\d{6})\",\"$1-$2\",\"15\",null],[\"(\\\\\\\\d{4})\",\"*$1\",\"[2-689]\",null]]]',\n  248: '[\"SC\",\"0(?:[02]|10?)\",null,null,null,null,\"\\\\\\\\d{6,7}\",\"[24689]\\\\\\\\d{5,6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[246]\",null]]]',\n  297: '[\"AW\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[25-9]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  421: '[\"SK\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"(?:[2-68]\\\\\\\\d{5,8}|9\\\\\\\\d{6,8})\",[[\"(2)(1[67])(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"21[67]\",null],[\"([3-5]\\\\\\\\d)(1[67])(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"[3-5]\",null],[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1/$2 $3 $4\",\"2\",null],[\"([3-5]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1/$2 $3 $4\",\"[3-5]\",null],[\"([689]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[689]\",null],[\"(9090)(\\\\\\\\d{3})\",\"$1 $2\",\"9090\",null]]]',\n  672: '[\"NF\",\"00\",null,null,null,null,\"\\\\\\\\d{5,6}\",\"[13]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"1\",null],[\"(\\\\\\\\d)(\\\\\\\\d{5})\",\"$1 $2\",\"3\",null]]]',\n  870: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}\",\"[35-7]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  883: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}(?:\\\\\\\\d{3})?\",\"51\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"510\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"510\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"51[13]\",null]]]',\n  264: '[\"NA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[68]\\\\\\\\d{7,8}\",[[\"(8\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8[1235]\",null],[\"(6\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"6\",null],[\"(88)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"88\",null],[\"(870)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"870\",null]]]',\n  878: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{12}\",\"1\\\\\\\\d{11}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5})(\\\\\\\\d{5})\",\"$1 $2 $3\",null,null]]]',\n  239: '[\"ST\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[29]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  357: '[\"CY\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[257-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",null,null]]]',\n  240: '[\"GQ\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[23589]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[235]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"[89]\",null]]]',\n  506: '[\"CR\",\"00\",null,\"(19(?:0[012468]|1[09]|20|66|77|99))\",null,null,\"\\\\\\\\d{8,10}\",\"[24-9]\\\\\\\\d{7,9}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[24-7]|8[3-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[89]0\",null]]]',\n  86: '[\"CN\",\"(1(?:[129]\\\\\\\\d{3}|79\\\\\\\\d{2}))?00\",\"0\",\"(1(?:[129]\\\\\\\\d{3}|79\\\\\\\\d{2}))|0\",null,null,\"\\\\\\\\d{4,12}\",\"[1-7]\\\\\\\\d{6,11}|8[0-357-9]\\\\\\\\d{6,9}|9\\\\\\\\d{7,10}\",[[\"(80\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"80[2678]\",\"$NP$FG\"],[\"([48]00)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[48]00\",null],[\"(\\\\\\\\d{5,6})\",\"$1\",\"100|95\",null,\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{5,6})\",\"$1 $2\",\"(?:10|2\\\\\\\\d)[19]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"[3-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-9]\",null,\"NA\"],[\"(21)(\\\\\\\\d{4})(\\\\\\\\d{4,6})\",\"$1 $2 $3\",\"21\",\"$NP$FG\"],[\"([12]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"10[1-9]|2[02-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3(?:1[02-9]|35|49|5|7[02-68]|9[1-68])|4(?:1[02-9]|2[179]|[35][2-9]|6[4789]|7\\\\\\\\d|8[23])|5(?:3[03-9]|4[36]|5[02-9]|6[1-46]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[04-9]|4[3-6]|6[2368])|8(?:1[236-8]|2[5-7]|3|5[1-9]|7[02-9]|8[3678]|9[1-7])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3(?:11|7[179])|4(?:[15]1|3[1-35])|5(?:1|2[37]|3[12]|51|7[13-79]|9[15])|7(?:31|5[457]|6[09]|91)|8(?:[57]1|98)\",\"$NP$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"807\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[3-578]\",null],[\"(10800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"108\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{7,8})\",\"$1 $2\",\"950\",null]]]',\n  257: '[\"BI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[267]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  683: '[\"NU\",\"00\",null,null,null,null,\"\\\\\\\\d{4}\",\"[1-5]\\\\\\\\d{3}\"]',\n  43: '[\"AT\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{3,13}\",\"[1-9]\\\\\\\\d{3,12}\",[[\"(116\\\\\\\\d{3})\",\"$1\",\"116\",\"$FG\"],[\"(1)(\\\\\\\\d{3,12})\",\"$1 $2\",\"1\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3,5})\",\"$1 $2\",\"5[079]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"5[079]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4,7})\",\"$1 $2 $3\",\"5[079]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,10})\",\"$1 $2\",\"316|46|51|732|6(?:5[0-3579]|[6-9])|7(?:[28]0)|[89]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3,9})\",\"$1 $2\",\"2|3(?:1[1-578]|[3-8])|4[2378]|5[2-6]|6(?:[12]|4[1-9]|5[468])|7(?:2[1-8]|35|4[1-8]|[5-79])\",null]]]',\n  247: '[\"AC\",\"00\",null,null,null,null,\"\\\\\\\\d{5,6}\",\"[46]\\\\\\\\d{4}|[01589]\\\\\\\\d{5}\"]',\n  675: '[\"PG\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[1-9]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[13-689]|27\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"20|7\",null]]]',\n  376: '[\"AD\",\"00\",null,null,null,null,\"\\\\\\\\d{6,9}\",\"[16]\\\\\\\\d{5,8}|[37-9]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2\",\"[137-9]|6[0-8]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"180\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"690\",null]]]',\n  63: '[\"PH\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{5,13}\",\"2\\\\\\\\d{5,7}|[3-9]\\\\\\\\d{7,9}|1800\\\\\\\\d{7,9}\",[[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",\"($NP$FG)\"],[\"(2)(\\\\\\\\d{5})\",\"$1 $2\",\"2\",\"($NP$FG)\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4,6})\",\"$1 $2\",\"3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|5(?:22|44)|642|8(?:62|8[245])\",\"($NP$FG)\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1 $2\",\"346|4(?:27|9[35])|883\",\"($NP$FG)\"],[\"([3-8]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[3-8]\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"81|9\",\"$NP$FG\"],[\"(1800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(1800)(\\\\\\\\d{1,2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3 $4\",\"1\",null]]]',\n  236: '[\"CF\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[278]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  590: [\n    '[\"GP\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\",[[\"([56]90)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2-$3\",null,null]]]',\n    '[\"BL\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\"]',\n    '[\"MF\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\"]',\n  ],\n  53: '[\"CU\",\"119\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{4,8}\",\"[2-57]\\\\\\\\d{5,7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{6,7})\",\"$1 $2\",\"7\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,6})\",\"$1 $2\",\"[2-4]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"5\",\"$NP$FG\"]]]',\n  64: '[\"NZ\",\"0(?:0|161)\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,11}\",\"6[235-9]\\\\\\\\d{6}|[2-57-9]\\\\\\\\d{7,10}\",[[\"([34679])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"[346]|7[2-57-9]|9[1-9]\",null],[\"(24099)(\\\\\\\\d{3})\",\"$1 $2\",\"240\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"21\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,5})\",\"$1 $2 $3\",\"2(?:1[1-9]|[69]|7[0-35-9])|70|86\",null],[\"(2\\\\\\\\d)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[028]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2(?:10|74)|5|[89]0\",null]]]',\n  965: '[\"KW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[12569]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{3,4})\",\"$1 $2\",\"[16]|2(?:[0-35-9]|4[0-35-9])|9[024-9]|52[25]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"244|5(?:[015]|66)\",null]]]',\n  224: '[\"GN\",\"00\",null,null,null,null,\"\\\\\\\\d{8,9}\",\"[367]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"3\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[67]\",null]]]',\n  973: '[\"BH\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[136-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  32: '[\"BE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[1-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"4[6-9]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[23]|4[23]|9[2-4]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[156]|7[018]|8(?:0[1-9]|[1-79])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"(?:80|9)0\",null]]]',\n  249: '[\"SD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[19]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  678: '[\"VU\",\"00\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[2-57-9]\\\\\\\\d{4,6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[579]\",null]]]',\n  52: '[\"MX\",\"0[09]\",\"01\",\"0[12]|04[45](\\\\\\\\d{10})\",\"1$1\",\"$NP $FG\",\"\\\\\\\\d{7,11}\",\"[1-9]\\\\\\\\d{9,10}\",[[\"([358]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"33|55|81\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2467]|3[0-2457-9]|5[089]|8[02-9]|9[0-35-9]\",null],[\"(1)([358]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"044 $2 $3 $4\",\"1(?:33|55|81)\",\"$FG\",\"$1 $2 $3 $4\"],[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"044 $2 $3 $4\",\"1(?:[2467]|3[0-2457-9]|5[089]|8[2-9]|9[1-35-9])\",\"$FG\",\"$1 $2 $3 $4\"]]]',\n  968: '[\"OM\",\"00\",null,null,null,null,\"\\\\\\\\d{7,9}\",\"(?:5|[279]\\\\\\\\d)\\\\\\\\d{6}|800\\\\\\\\d{5,6}\",[[\"(2\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"2\",null],[\"([79]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[79]\",null],[\"([58]00)(\\\\\\\\d{4,6})\",\"$1 $2\",\"[58]\",null]]]',\n  599: [\n    '[\"CW\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[169]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[13-7]\",null],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9\",null]]]',\n    '[\"BQ\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[347]\\\\\\\\d{6}\"]',\n  ],\n  800: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{8}\",\"\\\\\\\\d{8}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  386: '[\"SI\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,8}\",\"[1-7]\\\\\\\\d{6,7}|[89]\\\\\\\\d{4,7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[12]|3[24-8]|4[24-8]|5[2-8]|7[3-8]\",\"($NP$FG)\"],[\"([3-7]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[37][01]|4[0139]|51|6\",null],[\"([89][09])(\\\\\\\\d{3,6})\",\"$1 $2\",\"[89][09]\",null],[\"([58]\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"59|8[1-3]\",null]]]',\n  679: '[\"FJ\",\"0(?:0|52)\",null,null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{4})?\",\"[35-9]\\\\\\\\d{6}|0\\\\\\\\d{10}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[35-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0\",null]]]',\n  238: '[\"CV\",\"0\",null,null,null,null,\"\\\\\\\\d{7}\",\"[259]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  691: '[\"FM\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[39]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  262: [\n    '[\"RE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[268]\\\\\\\\d{8}\",[[\"([268]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n    '[\"YT\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[268]\\\\\\\\d{8}\"]',\n  ],\n  241: '[\"GA\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"0?\\\\\\\\d{7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[2-7]\",\"0$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"0\",null]]]',\n  370: '[\"LT\",\"00\",\"8\",\"[08]\",null,\"($NP-$FG)\",\"\\\\\\\\d{8}\",\"[3-9]\\\\\\\\d{7}\",[[\"([34]\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"37|4(?:1|5[45]|6[2-4])\",null],[\"([3-6]\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"3[148]|4(?:[24]|6[09])|528|6\",null],[\"([7-9]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[7-9]\",\"$NP $FG\"],[\"(5)(2\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"52[0-79]\",null]]]',\n  256: '[\"UG\",\"00[057]\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"[7-9]|20(?:[013-8]|2[5-9])|4(?:6[45]|[7-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2\",\"3|4(?:[1-5]|6[0-36-9])\",null],[\"(2024)(\\\\\\\\d{5})\",\"$1 $2\",\"2024\",null]]]',\n  677: '[\"SB\",\"0[01]\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[1-9]\\\\\\\\d{4,6}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"[7-9]\",null]]]',\n  377: '[\"MC\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"[34689]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[39]\",\"$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"4\",null],[\"(6)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"6\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"8\",\"$FG\"]]]',\n  382: '[\"ME\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[2-9]\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-57-9]|6[036-9]\",null]]]',\n  231: '[\"LR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"2\\\\\\\\d{7,8}|[378]\\\\\\\\d{8}|4\\\\\\\\d{6}|5\\\\\\\\d{6,8}\",[[\"(2\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2\",null],[\"([4-5])(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[45]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[23578]\",null]]]',\n  591: '[\"BO\",\"00(1\\\\\\\\d)?\",\"0\",\"0(1\\\\\\\\d)?\",null,null,\"\\\\\\\\d{7,8}\",\"[23467]\\\\\\\\d{7}\",[[\"([234])(\\\\\\\\d{7})\",\"$1 $2\",\"[234]\",null],[\"([67]\\\\\\\\d{7})\",\"$1\",\"[67]\",null]]]',\n  808: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{8}\",\"\\\\\\\\d{8}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  964: '[\"IQ\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[1-7]\\\\\\\\d{7,9}\",[[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"([2-6]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[2-6]\",null],[\"(7\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7\",null]]]',\n  225: '[\"CI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[02-8]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  992: '[\"TJ\",\"810\",\"8\",null,null,\"$FG\",\"\\\\\\\\d{3,9}\",\"[3-57-9]\\\\\\\\d{8}\",[[\"([349]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[34]7|91[78]\",null],[\"([457-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"4[148]|[578]|9(?:1[59]|[0235-9])\",null],[\"(331700)(\\\\\\\\d)(\\\\\\\\d{2})\",\"$1 $2 $3\",\"331\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3[1-5]\",null]]]',\n  55: '[\"BR\",\"00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)\",\"0\",\"(?:0|90)(?:(1[245]|2[135]|[34]1)(\\\\\\\\d{10,11}))?\",\"$2\",null,\"\\\\\\\\d{8,11}\",\"[1-46-9]\\\\\\\\d{7,10}|5(?:[0-4]\\\\\\\\d{7,9}|5(?:[2-8]\\\\\\\\d{7}|9\\\\\\\\d{7,8}))\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9](?:[1-9]|0[1-9])\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1-$2\",\"9(?:[1-9]|0[1-9])\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{3,5})\",\"$1\",\"1[125689]\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"[1-9][1-9]\",\"($FG)\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"(?:[14689][1-9]|2[12478]|3[1-578]|5[1-5]|7[13-579])9\",\"($FG)\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"(?:300|40(?:0|20))\",null],[\"([3589]00)(\\\\\\\\d{2,3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[3589]00\",\"$NP$FG\"]]]',\n  674: '[\"NR\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[458]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  967: '[\"YE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[1-7]\\\\\\\\d{6,8}\",[[\"([1-7])(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[1-6]|7[24-68]\",null],[\"(7\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"7[0137]\",null]]]',\n  49: '[\"DE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{2,15}\",\"[1-35-9]\\\\\\\\d{3,14}|4(?:[0-8]\\\\\\\\d{3,12}|9(?:[0-37]\\\\\\\\d|4(?:[1-35-8]|4\\\\\\\\d?)|5\\\\\\\\d{1,2}|6[1-8]\\\\\\\\d?)\\\\\\\\d{2,8})\",[[\"(1\\\\\\\\d{2})(\\\\\\\\d{7,8})\",\"$1 $2\",\"1[67]\",null],[\"(15\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"15[0568]\",null],[\"(1\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1 $2\",\"15\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,11})\",\"$1 $2\",\"3[02]|40|[68]9\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,11})\",\"$1 $2\",\"2(?:\\\\\\\\d1|0[2389]|1[24]|28|34)|3(?:[3-9][15]|40)|[4-8][1-9]1|9(?:06|[1-9]1)\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{2,11})\",\"$1 $2\",\"[24-6]|[7-9](?:\\\\\\\\d[1-9]|[1-9]\\\\\\\\d)|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])\",null],[\"(3\\\\\\\\d{4})(\\\\\\\\d{1,10})\",\"$1 $2\",\"3\",null],[\"(800)(\\\\\\\\d{7,12})\",\"$1 $2\",\"800\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{4,10})\",\"$1 $2 $3\",\"(?:18|90)0|137\",null],[\"(1\\\\\\\\d{2})(\\\\\\\\d{5,11})\",\"$1 $2\",\"181\",null],[\"(18\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"185\",null],[\"(18\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2\",\"18[68]\",null],[\"(18\\\\\\\\d)(\\\\\\\\d{8})\",\"$1 $2\",\"18[2-579]\",null],[\"(700)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"700\",null],[\"(138)(\\\\\\\\d{4})\",\"$1 $2\",\"138\",null],[\"(15[013-68])(\\\\\\\\d{2})(\\\\\\\\d{8})\",\"$1 $2 $3\",\"15[013-68]\",null],[\"(15[279]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1 $2 $3\",\"15[279]\",null],[\"(1[67]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{7,8})\",\"$1 $2 $3\",\"1(?:6[023]|7)\",null]]]',\n  31: '[\"NL\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"1\\\\\\\\d{4,8}|[2-7]\\\\\\\\d{8}|[89]\\\\\\\\d{6,9}\",[[\"([1-578]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[035]|2[0346]|3[03568]|4[0356]|5[0358]|7|8[4578]\",null],[\"([1-5]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1[16-8]|2[259]|3[124]|4[17-9]|5[124679]\",null],[\"(6)(\\\\\\\\d{8})\",\"$1 $2\",\"6[0-57-9]\",null],[\"(66)(\\\\\\\\d{7})\",\"$1 $2\",\"66\",null],[\"(14)(\\\\\\\\d{3,4})\",\"$1 $2\",\"14\",\"$FG\"],[\"([89]0\\\\\\\\d)(\\\\\\\\d{4,7})\",\"$1 $2\",\"80|9\",null]]]',\n  970: '[\"PS\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4,10}\",\"[24589]\\\\\\\\d{7,8}|1(?:[78]\\\\\\\\d{8}|[49]\\\\\\\\d{2,3})\",[[\"([2489])(2\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2489]\",null],[\"(5[69]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"5\",null],[\"(1[78]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1[78]\",\"$FG\"]]]',\n  58: '[\"VE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"[24589]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1-$2\",null,null]]]',\n  856: '[\"LA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[2-8]\\\\\\\\d{7,9}\",[[\"(20)(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"20\",null],[\"([2-8]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[13]|3[14]|[4-8]\",null],[\"(30)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"30\",null]]]',\n  354: '[\"IS\",\"1(?:0(?:01|10|20)|100)|00\",null,null,null,null,\"\\\\\\\\d{7,9}\",\"[4-9]\\\\\\\\d{6}|38\\\\\\\\d{7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[4-9]\",null],[\"(3\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3\",null]]]',\n  242: '[\"CG\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[028]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[02]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8\",null]]]',\n  423: '[\"LI\",\"00\",\"0\",\"0|10(?:01|20|66)\",null,null,\"\\\\\\\\d{7,9}\",\"6\\\\\\\\d{8}|[23789]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"[23789]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"6[56]\",null],[\"(69)(7\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"697\",null]]]',\n  213: '[\"DZ\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8,9}\",\"(?:[1-4]|[5-9]\\\\\\\\d)\\\\\\\\d{7}\",[[\"([1-4]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[1-4]\",null],[\"([5-8]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[5-8]\",null],[\"(9\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"9\",null]]]',\n  371: '[\"LV\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2689]\\\\\\\\d{7}\",[[\"([2689]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  503: '[\"SV\",\"00\",null,null,null,null,\"\\\\\\\\d{7,8}|\\\\\\\\d{11}\",\"[267]\\\\\\\\d{7}|[89]\\\\\\\\d{6}(?:\\\\\\\\d{4})?\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[267]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[89]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[89]\",null]]]',\n  685: '[\"WS\",\"0\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[2-8]\\\\\\\\d{4,6}\",[[\"(8\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1 $2\",\"8\",null],[\"(7\\\\\\\\d)(\\\\\\\\d{5})\",\"$1 $2\",\"7\",null],[\"(\\\\\\\\d{5})\",\"$1\",\"[2-6]\",null]]]',\n  880: '[\"BD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[2-79]\\\\\\\\d{5,9}|1\\\\\\\\d{9}|8[0-7]\\\\\\\\d{4,8}\",[[\"(2)(\\\\\\\\d{7,8})\",\"$1-$2\",\"2\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,6})\",\"$1-$2\",\"[3-79]1\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3,6})\",\"$1-$2\",\"1|3(?:0|[2-58]2)|4(?:0|[25]2|3[23]|[4689][25])|5(?:[02-578]2|6[25])|6(?:[0347-9]2|[26][25])|7[02-9]2|8(?:[023][23]|[4-7]2)|9(?:[02][23]|[458]2|6[016])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,7})\",\"$1-$2\",\"[3-79][2-9]|8\",null]]]',\n  265: '[\"MW\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"(?:1(?:\\\\\\\\d{2})?|[2789]\\\\\\\\d{2})\\\\\\\\d{6}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1\",null],[\"(2\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[1789]\",null]]]',\n  65: '[\"SG\",\"0[0-3]\\\\\\\\d\",null,null,null,null,\"\\\\\\\\d{8,11}\",\"[36]\\\\\\\\d{7}|[17-9]\\\\\\\\d{7,10}\",[[\"([3689]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[369]|8[1-9]\",null],[\"(1[89]00)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[89]\",null],[\"(7000)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"70\",null],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",null]]]',\n  504: '[\"HN\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[237-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",null,null]]]',\n  688: '[\"TV\",\"00\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[279]\\\\\\\\d{4,6}\"]',\n  84: '[\"VN\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"[167]\\\\\\\\d{6,9}|[2-59]\\\\\\\\d{7,9}|8\\\\\\\\d{6,8}\",[[\"([17]99)(\\\\\\\\d{4})\",\"$1 $2\",\"[17]99\",null],[\"([48])(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"4|8(?:[1-57]|6[0-79]|9[0-7])\",null],[\"([235-7]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[025-79]|3[0136-9]|5[2-9]|6[0-46-8]|7[02-79]\",null],[\"(80)(\\\\\\\\d{5})\",\"$1 $2\",\"80\",null],[\"(69\\\\\\\\d)(\\\\\\\\d{4,5})\",\"$1 $2\",\"69\",null],[\"([235-7]\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[0-489]|3[25]|5[01]|65|7[18]\",null],[\"([89]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"8(?:68|8|9[89])|9\",null],[\"(1[2689]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1(?:[26]|8[68]|99)\",null],[\"(1[89]00)(\\\\\\\\d{4,6})\",\"$1 $2\",\"1[89]0\",\"$FG\"]]]',\n  255: '[\"TZ\",\"00[056]\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"\\\\\\\\d{9}\",[[\"([24]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[24]\",null],[\"([67]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[67]\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[89]\",null]]]',\n  222: '[\"MR\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-48]\\\\\\\\d{7}\",[[\"([2-48]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  230: '[\"MU\",\"0(?:0|[2-7]0|33)\",null,null,null,null,\"\\\\\\\\d{7,8}\",\"[2-9]\\\\\\\\d{6,7}\",[[\"([2-46-9]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-46-9]\",null],[\"(5\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"5\",null]]]',\n  592: '[\"GY\",\"001\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-46-9]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  41: '[\"CH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}(?:\\\\\\\\d{3})?\",\"[2-9]\\\\\\\\d{8}|860\\\\\\\\d{9}\",[[\"([2-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[2-7]|[89]1\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8[047]|90\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4 $5\",\"860\",null]]]',\n  39: [\n    '[\"IT\",\"00\",null,null,null,null,\"\\\\\\\\d{6,11}\",\"[01589]\\\\\\\\d{5,10}|3(?:[12457-9]\\\\\\\\d{8}|[36]\\\\\\\\d{7,9})\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0[26]|55\",null],[\"(0[26])(\\\\\\\\d{4})(\\\\\\\\d{5})\",\"$1 $2 $3\",\"0[26]\",null],[\"(0[26])(\\\\\\\\d{4,6})\",\"$1 $2\",\"0[26]\",null],[\"(0\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0[13-57-9][0159]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,6})\",\"$1 $2\",\"0[13-57-9][0159]|8(?:03|4[17]|9[245])\",null],[\"(0\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"0[13-57-9][2-46-8]\",null],[\"(0\\\\\\\\d{3})(\\\\\\\\d{2,6})\",\"$1 $2\",\"0[13-57-9][2-46-8]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[13]|8(?:00|4[08]|9[59])\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"894\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"3\",null]]]',\n    '[\"VA\",\"00\",null,null,null,null,\"\\\\\\\\d{6,11}\",\"(?:0(?:878\\\\\\\\d{5}|6698\\\\\\\\d{5})|[1589]\\\\\\\\d{5,10}|3(?:[12457-9]\\\\\\\\d{8}|[36]\\\\\\\\d{7,9}))\"]',\n  ],\n  993: '[\"TM\",\"810\",\"8\",null,null,\"($NP $FG)\",\"\\\\\\\\d{8}\",\"[1-6]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"12\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",\"6\",\"$NP $FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"13|[2-5]\",null]]]',\n  888: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{11}\",\"\\\\\\\\d{11}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2 $3\",null,null]]]',\n  353: '[\"IE\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{5,10}\",\"[124-9]\\\\\\\\d{6,9}\",[[\"(1)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"2[24-9]|47|58|6[237-9]|9[35-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"40[24]|50[45]\",null],[\"(48)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"48\",null],[\"(818)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"81\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[24-69]|7[14]\",null],[\"([78]\\\\\\\\d)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"76|8[35-9]\",\"$NP$FG\"],[\"(700)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"70\",\"$NP$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1(?:8[059]|5)\",\"$FG\"]]]',\n  966: '[\"SA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"1\\\\\\\\d{7,8}|(?:[2-467]|92)\\\\\\\\d{7}|5\\\\\\\\d{8}|8\\\\\\\\d{9}\",[[\"([1-467])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[1-467]\",null],[\"(1\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[1-467]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"5\",null],[\"(92\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"92\",\"$FG\"],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",\"$FG\"],[\"(811)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"81\",null]]]',\n  380: '[\"UA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[3-9]\\\\\\\\d{8}\",[[\"([3-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[38]9|4(?:[45][0-5]|87)|5(?:0|6[37]|7[37])|6[36-8]|7|9[1-9]\",null],[\"([3-689]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3[1-8]2|4[13678]2|5(?:[12457]2|6[24])|6(?:[49]2|[12][29]|5[24])|8[0-8]|90\",null],[\"([3-6]\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"3(?:5[013-9]|[1-46-8])|4(?:[137][013-9]|6|[45][6-9]|8[4-6])|5(?:[1245][013-9]|6[0135-9]|3|7[4-6])|6(?:[49][013-9]|5[0135-9]|[12][13-8])\",null]]]',\n  98: '[\"IR\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4,10}\",\"[1-8]\\\\\\\\d{9}|9(?:[0-4]\\\\\\\\d{8}|9\\\\\\\\d{2,8})\",[[\"(21)(\\\\\\\\d{3,5})\",\"$1 $2\",\"21\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[1-8]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2\",\"9\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"9\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"9\",null]]]',\n  971: '[\"AE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"[2-79]\\\\\\\\d{7,8}|800\\\\\\\\d{2,9}\",[[\"([2-4679])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2-4679][2-8]\",null],[\"(5\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"5\",null],[\"([479]00)(\\\\\\\\d)(\\\\\\\\d{5})\",\"$1 $2 $3\",\"[479]0\",\"$FG\"],[\"([68]00)(\\\\\\\\d{2,9})\",\"$1 $2\",\"60|8\",\"$FG\"]]]',\n  30: '[\"GR\",\"00\",null,null,null,null,\"\\\\\\\\d{10}\",\"[26-9]\\\\\\\\d{9}\",[[\"([27]\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"21|7\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[2-9]1|[689]\",null],[\"(2\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"2[2-9][02-9]\",null]]]',\n  228: '[\"TG\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[29]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[29]\",null]]]',\n  48: '[\"PL\",\"00\",null,null,null,null,\"\\\\\\\\d{6,9}\",\"[12]\\\\\\\\d{6,8}|[3-57-9]\\\\\\\\d{8}|6\\\\\\\\d{5,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[14]|2[0-57-9]|3[2-4]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{1})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[12]2\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"26|39|5[0137]|6[0469]|7[02389]|8[08]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2,3})\",\"$1 $2 $3\",\"64\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2\",\"64\",null]]]',\n  886: '[\"TW\",\"0(?:0[25679]|19)\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"2\\\\\\\\d{6,8}|[3-689]\\\\\\\\d{7,8}|7\\\\\\\\d{7,9}\",[[\"(20)(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1 $2 $3\",\"202\",null],[\"(20)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"20[013-9]\",null],[\"([2-8])(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[23-8]|[3-6]|[78][1-9]\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"80|9\",null],[\"(70)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"70\",null]]]',\n  212: [\n    '[\"MA\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[5-9]\\\\\\\\d{8}\",[[\"([5-7]\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1-$2\",\"5(?:2[015-7]|3[0-4])|[67]\",null],[\"([58]\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1-$2\",\"5(?:2[2-489]|3[5-9]|92)|892\",null],[\"(5\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"5(?:29|38)\",null],[\"([5]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"5(?:4[067]|5[03])\",null],[\"(8[09])(\\\\\\\\d{7})\",\"$1-$2\",\"8(?:0|9[013-9])\",null]]]',\n    '[\"EH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[5-9]\\\\\\\\d{8}\"]',\n  ],\n  372: '[\"EE\",\"00\",null,null,null,null,\"\\\\\\\\d{4,10}\",\"1\\\\\\\\d{3,4}|[3-9]\\\\\\\\d{6,7}|800\\\\\\\\d{6,7}\",[[\"([3-79]\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]\",null],[\"(70)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"70\",null],[\"(8000)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"800\",null],[\"([458]\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2\",\"40|5|8(?:00|[1-5])\",null]]]',\n  598: '[\"UY\",\"0(?:1[3-9]\\\\\\\\d|0)\",\"0\",null,null,null,\"\\\\\\\\d{7,8}\",\"[2489]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[24]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"9[1-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"[89]0\",\"$NP$FG\"]]]',\n  502: '[\"GT\",\"00\",null,null,null,null,\"\\\\\\\\d{8}(?:\\\\\\\\d{3})?\",\"[2-7]\\\\\\\\d{7}|1[89]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[2-7]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null]]]',\n  82: '[\"KR\",\"00(?:[124-68]|3\\\\\\\\d{2}|7(?:[0-8]\\\\\\\\d|9[0-79]))\",\"0\",\"0(8[1-46-8]|85\\\\\\\\d{2})?\",null,\"$NP$FG\",\"\\\\\\\\d{3,14}\",\"007\\\\\\\\d{9,11}|[1-7]\\\\\\\\d{3,9}|8\\\\\\\\d{8}\",[[\"(\\\\\\\\d{5})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"00798\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3 $4\",\"00798\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:0|1[19]|[69]9|5[458])|[57]0\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"1(?:[01]|5[1-4]|6[2-8]|[7-9])|[68]0|[3-6][1-9][1-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{4})\",\"$1-$2-$3\",\"131\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"131\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"13[2-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3-$4\",\"30\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"2[1-9]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3,4})\",\"$1-$2\",\"21[0-46-9]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3,4})\",\"$1-$2\",\"[3-6][1-9]1\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"1(?:5[246-9]|6[04678]|8[03579])\",\"$FG\"]]]',\n  253: '[\"DJ\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[27]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  91: '[\"IN\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,13}\",\"008\\\\\\\\d{9}|1\\\\\\\\d{7,12}|[2-9]\\\\\\\\d{9,10}\",[[\"(\\\\\\\\d{5})(\\\\\\\\d{5})\",\"$1 $2\",\"600|7(?:[02-8]|19|9[037-9])|8(?:0[015-9]|[1-9]|20)|9\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"11|2[02]|33|4[04]|79[1-9]|80[2-46]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1(?:2[0-249]|3[0-25]|4[145]|[59][14]|7[1257]|[68][1-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|[36][25]|22|4[28]|5[12]|[78]1|9[15])|6(?:12|[2-4]1|5[17]|6[13]|7[14]|80)|7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1(?:[23579]|[468][1-9])|[2-8]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"008\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"140\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"160\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1 $2\",\"180\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{2,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"180\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3,4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"186\",\"$FG\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"18[06]\",\"$FG\"]]]',\n  389: '[\"MK\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,8}\",\"[2-578]\\\\\\\\d{7}\",[[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",null],[\"([347]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[347]\",null],[\"([58]\\\\\\\\d{2})(\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[58]\",null]]]',\n  1: [\n    '[\"US\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2-9]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",null,null,\"NA\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"($1) $2-$3\",null,null,\"$1-$2-$3\"]]]',\n    '[\"AI\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"AS\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"BB\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"BM\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[4589]\\\\\\\\d{9}\"]',\n    '[\"BS\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"CA\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2-9]\\\\\\\\d{9}|3\\\\\\\\d{6}\"]',\n    '[\"DM\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[57-9]\\\\\\\\d{9}\"]',\n    '[\"DO\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"GD\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[4589]\\\\\\\\d{9}\"]',\n    '[\"GU\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"JM\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"KN\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"KY\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[3589]\\\\\\\\d{9}\"]',\n    '[\"LC\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"MP\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"MS\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"PR\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"SX\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"TC\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5689]\\\\\\\\d{9}\"]',\n    '[\"TT\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[589]\\\\\\\\d{9}\"]',\n    '[\"AG\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"VC\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[5789]\\\\\\\\d{9}\"]',\n    '[\"VG\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[2589]\\\\\\\\d{9}\"]',\n    '[\"VI\",\"011\",\"1\",null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{3})?\",\"[3589]\\\\\\\\d{9}\"]',\n  ],\n  60: '[\"MY\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{6,10}\",\"[13-9]\\\\\\\\d{7,9}\",[[\"([4-79])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"[4-79]\",\"$NP$FG\"],[\"(3)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"3\",\"$NP$FG\"],[\"([18]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1-$2 $3\",\"1[02-46-9][1-9]|8\",\"$NP$FG\"],[\"(1)([36-8]00)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2-$3-$4\",\"1[36-8]0\",null],[\"(11)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"11\",\"$NP$FG\"],[\"(15[49])(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2 $3\",\"15\",\"$NP$FG\"]]]',\n  355: '[\"AL\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,9}\",\"[2-57]\\\\\\\\d{7}|6\\\\\\\\d{8}|8\\\\\\\\d{5,7}|9\\\\\\\\d{5}\",[[\"(4)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"4[0-6]\",null],[\"(6\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"6\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2358][2-5]|4[7-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,5})\",\"$1 $2\",\"[235][16-9]|8[016-9]|[79]\",null]]]',\n  254: '[\"KE\",\"000\",\"0\",\"005|0\",null,\"$NP$FG\",\"\\\\\\\\d{7,10}\",\"20\\\\\\\\d{6,7}|[4-9]\\\\\\\\d{6,9}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5,7})\",\"$1 $2\",\"[24-6]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"7\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[89]\",null]]]',\n  223: '[\"ML\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[246-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[246-9]\",null],[\"(\\\\\\\\d{4})\",\"$1\",\"67|74\",null,\"NA\"]]]',\n  686: '[\"KI\",\"00\",null,\"0\",null,null,\"\\\\\\\\d{5,8}\",\"[2458]\\\\\\\\d{4}|3\\\\\\\\d{4,7}|7\\\\\\\\d{7}\"]',\n  994: '[\"AZ\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{7,9}\",\"[1-9]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"(?:1[28]|2(?:[45]2|[0-36])|365)\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[4-8]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"9\",\"$NP$FG\"]]]',\n  979: '[\"001\",null,null,null,null,null,\"\\\\\\\\d{9}\",\"\\\\\\\\d{9}\",[[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  66: '[\"TH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4}|\\\\\\\\d{8,10}\",\"[2-9]\\\\\\\\d{7,8}|1\\\\\\\\d{3}(?:\\\\\\\\d{5,6})?\",[[\"(2)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",null],[\"([13-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"14|[3-9]\",null],[\"(1[89]00)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"1\",\"$FG\"]]]',\n  233: '[\"GH\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[235]\\\\\\\\d{8}|8\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[235]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"8\",null]]]',\n  593: '[\"EC\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{7,11}\",\"1\\\\\\\\d{9,10}|[2-8]\\\\\\\\d{7}|9\\\\\\\\d{8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"[247]|[356][2-8]\",null,\"$1-$2-$3\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9\",\"$NP$FG\"],[\"(1800)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"1\",\"$FG\"]]]',\n  509: '[\"HT\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2-489]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  54: '[\"AR\",\"00\",\"0\",\"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\\\\\\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))?15)?\",\"9$1\",\"$NP$FG\",\"\\\\\\\\d{6,11}\",\"11\\\\\\\\d{8}|[2368]\\\\\\\\d{9}|9\\\\\\\\d{10}\",[[\"([68]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2-$3\",\"[68]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9]\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9]\",\"$FG\",\"NA\"],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-9]\",\"$FG\",\"NA\"],[\"(9)(11)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$2 15-$3-$4\",\"911\",null,\"$1 $2 $3-$4\"],[\"(9)(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$2 15-$3-$4\",\"9(?:2[234689]|3[3-8])\",null,\"$1 $2 $3-$4\"],[\"(9)(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$2 15-$3-$4\",\"9[23]\",null,\"$1 $2 $3-$4\"],[\"(11)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"1\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"2(?:2[013]|3[067]|49|6[01346]|80|9[147-9])|3(?:36|4[1-358]|5[138]|6[24]|7[069]|8[013578])\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2-$3\",\"[23]\",null],[\"(\\\\\\\\d{3})\",\"$1\",\"1[012]|911\",\"$FG\",\"NA\"]]]',\n  57: '[\"CO\",\"00(?:4(?:[14]4|56)|[579])\",\"0\",\"0([3579]|4(?:44|56))?\",null,null,\"\\\\\\\\d{7,11}\",\"(?:[13]\\\\\\\\d{0,3}|[24-8])\\\\\\\\d{7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"1(?:8[2-9]|9[0-3]|[2-7])|[24-8]\",\"($FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1 $2\",\"3\",null],[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{7})\",\"$1-$2-$3\",\"1(?:80|9[04])\",\"$NP$FG\",\"$1 $2 $3\"]]]',\n  597: '[\"SR\",\"00\",null,null,null,null,\"\\\\\\\\d{6,7}\",\"[2-8]\\\\\\\\d{5,6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1-$2\",\"[2-4]|5[2-58]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2-$3\",\"56\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[6-8]\",null]]]',\n  676: '[\"TO\",\"00\",null,null,null,null,\"\\\\\\\\d{5,7}\",\"[02-8]\\\\\\\\d{4,6}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1-$2\",\"[1-6]|7[0-4]|8[05]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",\"7[5-9]|8[47-9]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1 $2\",\"0\",null]]]',\n  505: '[\"NI\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[12578]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  850: '[\"KP\",\"00|99\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,8}|\\\\\\\\d{10}\",\"1\\\\\\\\d{9}|[28]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8\",null]]]',\n  7: [\n    '[\"RU\",\"810\",\"8\",null,null,\"$NP ($FG)\",\"\\\\\\\\d{10}\",\"[3489]\\\\\\\\d{9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1-$2-$3\",\"[1-79]\",\"$FG\",\"NA\"],[\"([3489]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2-$3-$4\",\"[34689]\",null],[\"(7\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"7\",null]]]',\n    '[\"KZ\",\"810\",\"8\",null,null,null,\"\\\\\\\\d{10}\",\"(?:33\\\\\\\\d|7\\\\\\\\d{2}|80[09])\\\\\\\\d{7}\"]',\n  ],\n  268: '[\"SZ\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[027]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[027]\",null]]]',\n  501: '[\"BZ\",\"00\",null,null,null,null,\"\\\\\\\\d{7}(?:\\\\\\\\d{4})?\",\"[2-8]\\\\\\\\d{6}|0\\\\\\\\d{10}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[2-8]\",null],[\"(0)(800)(\\\\\\\\d{4})(\\\\\\\\d{3})\",\"$1-$2-$3-$4\",\"0\",null]]]',\n  252: '[\"SO\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{6,9}\",\"[1-9]\\\\\\\\d{5,8}\",[[\"(\\\\\\\\d{6})\",\"$1\",\"[134]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{6})\",\"$1 $2\",\"2[0-79]|[13-5]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"24|[67]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"8[125]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5,7})\",\"$1 $2\",\"15|28|6[1-35-9]|799|9[2-9]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"3[59]|4[89]|6[24-6]|79|8[08]|90\",null]]]',\n  229: '[\"BJ\",\"00\",null,null,null,null,\"\\\\\\\\d{4,8}\",\"[2689]\\\\\\\\d{7}|7\\\\\\\\d{3}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  680: '[\"PW\",\"01[12]\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-8]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  263: '[\"ZW\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{3,10}\",\"2(?:[012457-9]\\\\\\\\d{3,8}|6(?:[14]\\\\\\\\d{7}|\\\\\\\\d{4}))|[13-79]\\\\\\\\d{4,9}|8[06]\\\\\\\\d{8}\",[[\"([49])(\\\\\\\\d{3})(\\\\\\\\d{2,4})\",\"$1 $2 $3\",\"4|9[2-9]\",null],[\"(7\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"7\",null],[\"(86\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"86[24]\",null],[\"([2356]\\\\\\\\d{2})(\\\\\\\\d{3,5})\",\"$1 $2\",\"2(?:0[45]|2[278]|[49]8|[78])|3(?:08|17|3[78]|7[1569]|8[37]|98)|5[15][78]|6(?:[29]8|[38]7|6[78]|75|[89]8)\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"2(?:1[39]|2[0157]|6[14]|7[35]|84)|329\",null],[\"([1-356]\\\\\\\\d)(\\\\\\\\d{3,5})\",\"$1 $2\",\"1[3-9]|2[0569]|3[0-69]|5[05689]|6[0-46-9]\",null],[\"([235]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[23]9|54\",null],[\"([25]\\\\\\\\d{3})(\\\\\\\\d{3,5})\",\"$1 $2\",\"(?:25|54)8\",null],[\"(8\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"86\",null],[\"(80\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",null]]]',\n  90: '[\"TR\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{7,10}\",\"[2-589]\\\\\\\\d{9}|444\\\\\\\\d{4}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[23]|4(?:[0-35-9]|4[0-35-9])\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"5[02-69]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"51|[89]\",\"$NP$FG\"],[\"(444)(\\\\\\\\d{1})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"444\",null]]]',\n  352: '[\"LU\",\"00\",null,\"(15(?:0[06]|1[12]|35|4[04]|55|6[26]|77|88|99)\\\\\\\\d)\",null,null,\"\\\\\\\\d{4,11}\",\"[24-9]\\\\\\\\d{3,10}|3(?:[0-46-9]\\\\\\\\d{2,9}|5[013-9]\\\\\\\\d{1,8})\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",\"[2-5]|7[1-9]|[89](?:[1-9]|0[2-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"[2-5]|7[1-9]|[89](?:[1-9]|0[2-9])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"20\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{1,2})\",\"$1 $2 $3 $4\",\"2(?:[0367]|4[3-8])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"20\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{1,2})\",\"$1 $2 $3 $4 $5\",\"2(?:[0367]|4[3-8])\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{1,4})\",\"$1 $2 $3 $4\",\"2(?:[12589]|4[12])|[3-5]|7[1-9]|8(?:[1-9]|0[2-9])|9(?:[1-9]|0[2-46-9])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"70|80[01]|90[015]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"6\",null]]]',\n  47: [\n    '[\"NO\",\"00\",null,null,null,null,\"\\\\\\\\d{5}(?:\\\\\\\\d{3})?\",\"0\\\\\\\\d{4}|[2-9]\\\\\\\\d{7}\",[[\"([489]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[489]\",null],[\"([235-7]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[235-7]\",null]]]',\n    '[\"SJ\",\"00\",null,null,null,null,\"\\\\\\\\d{5}(?:\\\\\\\\d{3})?\",\"0\\\\\\\\d{4}|[45789]\\\\\\\\d{7}\"]',\n  ],\n  243: '[\"CD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[2-6]\\\\\\\\d{6}|[18]\\\\\\\\d{6,8}|9\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"12\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8[0-2459]|9\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"88\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"[1-6]\",null]]]',\n  220: '[\"GM\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[2-9]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  687: '[\"NC\",\"00\",null,null,null,null,\"\\\\\\\\d{6}\",\"[2-57-9]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1.$2.$3\",\"[2-46-9]|5[0-4]\",null]]]',\n  995: '[\"GE\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{6,9}\",\"[34578]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[348]\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"7\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"5\",\"$FG\"]]]',\n  961: '[\"LB\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{7,8}\",\"[13-9]\\\\\\\\d{6,7}\",[[\"(\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[13-6]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]|9\",\"$NP$FG\"],[\"([7-9]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[89][01]|7(?:[01]|6[013-9]|8[89]|9[1-3])\",null]]]',\n  40: '[\"RO\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,9}\",\"[23]\\\\\\\\d{5,8}|[7-9]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[23]1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2\",\"[23]1\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[23][3-7]|[7-9]\",null],[\"(2\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2\",\"2[3-6]\",null]]]',\n  232: '[\"SL\",\"00\",\"0\",null,null,\"($NP$FG)\",\"\\\\\\\\d{6,8}\",\"[2-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1 $2\",null,null]]]',\n  594: '[\"GF\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  976: '[\"MN\",\"001\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[12]\\\\\\\\d{7,9}|[57-9]\\\\\\\\d{7}\",[[\"([12]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[12]1\",null],[\"([12]2\\\\\\\\d)(\\\\\\\\d{5,6})\",\"$1 $2\",\"[12]2[1-3]\",null],[\"([12]\\\\\\\\d{3})(\\\\\\\\d{5})\",\"$1 $2\",\"[12](?:27|[3-5])\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2\",\"[57-9]\",\"$FG\"],[\"([12]\\\\\\\\d{4})(\\\\\\\\d{4,5})\",\"$1 $2\",\"[12](?:27|[3-5])\",null]]]',\n  20: '[\"EG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"1\\\\\\\\d{4,9}|[2456]\\\\\\\\d{8}|3\\\\\\\\d{7}|[89]\\\\\\\\d{8,9}\",[[\"(\\\\\\\\d)(\\\\\\\\d{7,8})\",\"$1 $2\",\"[23]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1[012]|[89]00\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6,7})\",\"$1 $2\",\"1[35]|[4-6]|[89][2-9]\",null]]]',\n  689: '[\"PF\",\"00\",null,null,null,null,\"\\\\\\\\d{6}(?:\\\\\\\\d{2})?\",\"4\\\\\\\\d{5,7}|8\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"4[09]|8[79]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",\"44\",null]]]',\n  56: '[\"CL\",\"(?:0|1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))0\",\"0\",\"0|(1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))\",null,\"$NP$FG\",\"\\\\\\\\d{7,11}\",\"(?:[2-9]|600|123)\\\\\\\\d{7,8}\",[[\"(\\\\\\\\d)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2[23]\",\"($FG)\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[357]|4[1-35]|6[13-57]\",\"($FG)\"],[\"(9)(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"9\",null],[\"(44)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"44\",null],[\"([68]00)(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"60|8\",\"$FG\"],[\"(600)(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"60\",\"$FG\"],[\"(1230)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",\"$FG\"],[\"(\\\\\\\\d{5})(\\\\\\\\d{4})\",\"$1 $2\",\"219\",\"($FG)\"],[\"(\\\\\\\\d{4,5})\",\"$1\",\"[1-9]\",\"$FG\",\"NA\"]]]',\n  596: '[\"MQ\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[56]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  508: '[\"PM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6}\",\"[45]\\\\\\\\d{5}\",[[\"([45]\\\\\\\\d)(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  269: '[\"KM\",\"00\",null,null,null,null,\"\\\\\\\\d{7}\",\"[3478]\\\\\\\\d{6}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  358: [\n    '[\"FI\",\"00|99(?:[02469]|5(?:11|33|5[59]|88|9[09]))\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"1\\\\\\\\d{4,11}|[2-9]\\\\\\\\d{4,10}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3,7})\",\"$1 $2\",\"(?:[1-3]00|[6-8]0)\",null],[\"(116\\\\\\\\d{3})\",\"$1\",\"116\",\"$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{4,10})\",\"$1 $2\",\"[14]|2[09]|50|7[135]\",null],[\"(\\\\\\\\d)(\\\\\\\\d{4,11})\",\"$1 $2\",\"[25689][1-8]|3\",null]]]',\n    '[\"AX\",\"00|99(?:[02469]|5(?:11|33|5[59]|88|9[09]))\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,12}\",\"1\\\\\\\\d{5,11}|[35]\\\\\\\\d{5,9}|[27]\\\\\\\\d{4,9}|4\\\\\\\\d{5,10}|6\\\\\\\\d{7,9}|8\\\\\\\\d{6,9}\"]',\n  ],\n  251: '[\"ET\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[1-59]\\\\\\\\d{8}\",[[\"([1-59]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",null,null]]]',\n  681: '[\"WF\",\"00\",null,null,null,null,\"\\\\\\\\d{6}\",\"[4-8]\\\\\\\\d{5}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3\",null,null]]]',\n  853: '[\"MO\",\"00\",null,null,null,null,\"\\\\\\\\d{8}\",\"[268]\\\\\\\\d{7}\",[[\"([268]\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2\",null,null]]]',\n  44: [\n    '[\"GB\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{4,10}\",\"\\\\\\\\d{7,10}\",[[\"(7\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"7(?:[1-5789]|62)\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{4})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"2|5[56]|7[06]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1(?:1|\\\\\\\\d1)|3|9[018]\",null],[\"(\\\\\\\\d{5})(\\\\\\\\d{4,5})\",\"$1 $2\",\"1(?:38|5[23]|69|76|94)\",null],[\"(1\\\\\\\\d{3})(\\\\\\\\d{5,6})\",\"$1 $2\",\"1\",null],[\"(800)(\\\\\\\\d{4})\",\"$1 $2\",\"800\",null],[\"(845)(46)(4\\\\\\\\d)\",\"$1 $2 $3\",\"845\",null],[\"(8\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8(?:4[2-5]|7[0-3])\",null],[\"(80\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"80\",null],[\"([58]00)(\\\\\\\\d{6})\",\"$1 $2\",\"[58]00\",null]]]',\n    '[\"GG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[135789]\\\\\\\\d{6,9}\"]',\n    '[\"IM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[135789]\\\\\\\\d{6,9}\"]',\n    '[\"JE\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[135789]\\\\\\\\d{6,9}\"]',\n  ],\n  244: '[\"AO\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[29]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,null]]]',\n  211: '[\"SS\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{9}\",\"[19]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",null,\"$NP$FG\"]]]',\n  373: '[\"MD\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{8}\",\"[235-9]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"22|3\",null],[\"([25-7]\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"2[13-9]|[5-7]\",null],[\"([89]\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"[89]\",null]]]',\n  996: '[\"KG\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{5,10}\",\"[235-8]\\\\\\\\d{8,9}\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[25-7]|31[25]\",null],[\"(\\\\\\\\d{4})(\\\\\\\\d{5})\",\"$1 $2\",\"3(?:1[36]|[2-9])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d)(\\\\\\\\d{3})\",\"$1 $2 $3 $4\",\"8\",null]]]',\n  93: '[\"AF\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{7,9}\",\"[2-7]\\\\\\\\d{8}\",[[\"([2-7]\\\\\\\\d)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[2-7]\",null]]]',\n  260: '[\"ZM\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{9}\",\"[289]\\\\\\\\d{8}\",[[\"([29]\\\\\\\\d)(\\\\\\\\d{7})\",\"$1 $2\",\"[29]\",null],[\"(800)(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"8\",null]]]',\n  378: '[\"SM\",\"00\",null,\"(?:0549)?([89]\\\\\\\\d{5})\",\"0549$1\",null,\"\\\\\\\\d{6,10}\",\"[05-7]\\\\\\\\d{7,9}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[5-7]\",null],[\"(0549)(\\\\\\\\d{6})\",\"$1 $2\",\"0\",null,\"($1) $2\"],[\"(\\\\\\\\d{6})\",\"0549 $1\",\"[89]\",null,\"(0549) $1\"]]]',\n  235: '[\"TD\",\"00|16\",null,null,null,null,\"\\\\\\\\d{8}\",\"[2679]\\\\\\\\d{7}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",null,null]]]',\n  960: '[\"MV\",\"0(?:0|19)\",null,null,null,null,\"\\\\\\\\d{7,10}\",\"[346-8]\\\\\\\\d{6,9}|9(?:00\\\\\\\\d{7}|\\\\\\\\d{6})\",[[\"(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1-$2\",\"[3467]|9(?:[1-9]|0[1-9])\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"[89]00\",null]]]',\n  221: '[\"SN\",\"00\",null,null,null,null,\"\\\\\\\\d{9}\",\"[3789]\\\\\\\\d{8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"[379]\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{2})(\\\\\\\\d{2})(\\\\\\\\d{2})\",\"$1 $2 $3 $4\",\"8\",null]]]',\n  595: '[\"PY\",\"00\",\"0\",null,null,null,\"\\\\\\\\d{5,9}\",\"5[0-5]\\\\\\\\d{4,7}|[2-46-9]\\\\\\\\d{5,8}\",[[\"(\\\\\\\\d{2})(\\\\\\\\d{5})\",\"$1 $2\",\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\",\"($NP$FG)\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"(?:[26]1|3[289]|4[124678]|7[123]|8[1236])\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3,6})\",\"$1 $2\",\"[2-9]0\",\"$NP$FG\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{6})\",\"$1 $2\",\"9[1-9]\",\"$NP$FG\"],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"8700\",null],[\"(\\\\\\\\d{3})(\\\\\\\\d{4,5})\",\"$1 $2\",\"[2-8][1-9]\",\"($NP$FG)\"],[\"(\\\\\\\\d{3})(\\\\\\\\d{3})(\\\\\\\\d{3})\",\"$1 $2 $3\",\"[2-8][1-9]\",\"$NP$FG\"]]]',\n  977: '[\"NP\",\"00\",\"0\",null,null,\"$NP$FG\",\"\\\\\\\\d{6,10}\",\"[1-8]\\\\\\\\d{7}|9(?:[1-69]\\\\\\\\d{6,8}|7[2-6]\\\\\\\\d{5,7}|8\\\\\\\\d{8})\",[[\"(1)(\\\\\\\\d{7})\",\"$1-$2\",\"1[2-6]\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{6})\",\"$1-$2\",\"1[01]|[2-8]|9(?:[1-69]|7[15-9])\",null],[\"(9\\\\\\\\d{2})(\\\\\\\\d{7})\",\"$1-$2\",\"9(?:6[013]|7[245]|8)\",\"$FG\"]]]',\n  36: '[\"HU\",\"00\",\"06\",null,null,\"($FG)\",\"\\\\\\\\d{6,9}\",\"[1-9]\\\\\\\\d{7,8}\",[[\"(1)(\\\\\\\\d{3})(\\\\\\\\d{4})\",\"$1 $2 $3\",\"1\",null],[\"(\\\\\\\\d{2})(\\\\\\\\d{3})(\\\\\\\\d{3,4})\",\"$1 $2 $3\",\"[2-9]\",null]]]',\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs":
/*!***************************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhoneNumberNormalizer\": () => (/* binding */ PhoneNumberNormalizer)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Apache License, Version\n * 2.0. If a copy of the Apache License was not distributed with this file, You\n * can obtain one at https://www.apache.org/licenses/LICENSE-2.0 */\n\n// This library came from https://github.com/andreasgal/PhoneNumber.js but will\n// be further maintained by our own in Form Autofill codebase.\n\nvar PhoneNumberNormalizer = (function () {\n  const UNICODE_DIGITS = /[\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9]/g;\n  const VALID_ALPHA_PATTERN = /[a-zA-Z]/g;\n  const LEADING_PLUS_CHARS_PATTERN = /^[+\\uFF0B]+/g;\n  const NON_DIALABLE_CHARS = /[^,#+\\*\\d]/g;\n\n  // Map letters to numbers according to the ITU E.161 standard\n  let E161 = {\n    a: 2,\n    b: 2,\n    c: 2,\n    d: 3,\n    e: 3,\n    f: 3,\n    g: 4,\n    h: 4,\n    i: 4,\n    j: 5,\n    k: 5,\n    l: 5,\n    m: 6,\n    n: 6,\n    o: 6,\n    p: 7,\n    q: 7,\n    r: 7,\n    s: 7,\n    t: 8,\n    u: 8,\n    v: 8,\n    w: 9,\n    x: 9,\n    y: 9,\n    z: 9,\n  };\n\n  // Normalize a number by converting unicode numbers and symbols to their\n  // ASCII equivalents and removing all non-dialable characters.\n  function NormalizeNumber(number, numbersOnly) {\n    if (typeof number !== \"string\") {\n      return \"\";\n    }\n\n    number = number.replace(UNICODE_DIGITS, function (ch) {\n      return String.fromCharCode(48 + (ch.charCodeAt(0) & 0xf));\n    });\n    if (!numbersOnly) {\n      number = number.replace(VALID_ALPHA_PATTERN, function (ch) {\n        return String(E161[ch.toLowerCase()] || 0);\n      });\n    }\n    number = number.replace(LEADING_PLUS_CHARS_PATTERN, \"+\");\n    number = number.replace(NON_DIALABLE_CHARS, \"\");\n    return number;\n  }\n\n  return {\n    Normalize: NormalizeNumber,\n  };\n})();\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/addressFormLayout.js":
/*!******************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/addressFormLayout.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"canSubmitForm\": () => (/* binding */ canSubmitForm),\n/* harmony export */   \"createFormLayoutFromRecord\": () => (/* binding */ createFormLayoutFromRecord)\n/* harmony export */ });\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconsole.log(\"ssssssss ------ 1\");\nconst lazy = {};\nChromeUtils.defineESModuleGetters(lazy, {\n  FormAutofill: \"resource://autofill/FormAutofill.sys.mjs\",\n  FormAutofillUtils: \"resource://gre/modules/shared/FormAutofillUtils.sys.mjs\",\n});\n\nconsole.log(\"ssssssss ------ 2\");\n\n/* exported canSubmitForm, getCurrentFormData */\n\n// Defines template descriptors for generating elements in convertLayoutToUI.\nconst fieldTemplates = {\n  commonAttributes(item) {\n    return {\n      id: item.fieldId,\n      name: item.fieldId,\n      required: item.required,\n      value: item.value ?? \"\",\n    };\n  },\n  input(item) {\n    return {\n      tag: \"input\",\n      type: item.type ?? \"text\",\n      ...this.commonAttributes(item),\n    };\n  },\n  textarea(item) {\n    return {\n      tag: \"textarea\",\n      ...this.commonAttributes(item),\n    };\n  },\n  select(item) {\n    return {\n      tag: \"select\",\n      children: item.options.map(({ value, text }) => ({\n        tag: \"option\",\n        selected: value === item.value,\n        value,\n        text,\n      })),\n      ...this.commonAttributes(item),\n    };\n  },\n};\n\n/**\n * Creates an HTML element with specified attributes and children.\n *\n * @param {string} tag - Tag name for the element to create.\n * @param {object} options - Options object containing attributes and children.\n * @param {object} options.attributes - Element's Attributes/Props (id, class, etc.)\n * @param {Array} options.children - Element's children (array of objects with tag and options).\n * @returns {HTMLElement} The newly created element.\n */\nconst createElement = (tag, { children = [], ...attributes }) => {\n  const element = document.createElement(tag);\n\n  for (let [attributeName, attributeValue] of Object.entries(attributes)) {\n    if (attributeName in element) {\n      element[attributeName] = attributeValue;\n    } else {\n      element.setAttribute(attributeName, attributeValue);\n    }\n  }\n\n  for (let { tag: childTag, ...childRest } of children) {\n    element.appendChild(createElement(childTag, childRest));\n  }\n\n  return element;\n};\n\n/**\n * Generator that creates UI elements from `fields` object, using localization from `l10nStrings`.\n *\n * @param {Array} fields - Array of objects as returned from `FormAutofillUtils.getFormLayout`.\n * @param {object} l10nStrings - Key-value pairs for field label localization.\n * @yields {HTMLElement} - A localized label element with constructed from a field.\n */\nfunction* convertLayoutToUI(fields, l10nStrings) {\n  for (const item of fields) {\n    // eslint-disable-next-line no-nested-ternary\n    const fieldTag = item.options\n      ? \"select\"\n      : item.multiline\n      ? \"textarea\"\n      : \"input\";\n\n    const fieldUI = {\n      label: {\n        id: `${item.fieldId}-container`,\n        class: `container ${item.newLine ? \"new-line\" : \"\"}`,\n      },\n      field: fieldTemplates[fieldTag](item),\n      span: {\n        class: \"label-text\",\n        textContent: l10nStrings[item.l10nId],\n      },\n    };\n\n    alert(JSON.stringify(l10nStrings));\n\n    const label = createElement(\"label\", fieldUI.label);\n    const { tag, ...rest } = fieldUI.field;\n    const field = createElement(tag, rest);\n    label.appendChild(field);\n    const span = createElement(\"span\", fieldUI.span);\n    label.appendChild(span);\n\n    yield label;\n  }\n}\n\n/**\n * Retrieves the current form data from the current form element on the page.\n *\n * @returns {object} An object containing key-value pairs of form data.\n */\nconst getCurrentFormData = () => {\n  const formElement = document.querySelector(\"form\");\n  const formData = new FormData(formElement);\n  return Object.fromEntries(formData.entries());\n};\n\n/**\n * Checks if the form can be submitted based on the number of non-empty values.\n * TODO(Bug 1891734): Add address validation. Right now we don't do any validation. (2 fields mimics the old behaviour ).\n *\n * @returns {boolean} True if the form can be submitted\n */\nconst canSubmitForm = () => {\n  const formData = getCurrentFormData();\n  const validValues = Object.values(formData).filter(Boolean);\n  return validValues.length >= 2;\n};\n\n/**\n * Generates a form layout based on record data and localization strings.\n *\n * @param {HTMLFormElement} formElement - Target form element.\n * @param {object} record - Address record, includes at least country code defaulted to FormAutofill.DEFAULT_REGION.\n * @param {object} l10nStrings - Localization strings map.\n */\nconst createFormLayoutFromRecord = (\n  formElement,\n  record = { country: lazy.FormAutofill.DEFAULT_REGION },\n  l10nStrings = {}\n) => {\n  // Always clear select values because they are not persisted between countries.\n  // For example from US with state NY, we don't want the address-level1 to be NY\n  // when changing to another country that doesn't have state options\n  const selects = formElement.querySelectorAll(\"select:not(#country)\");\n  for (const select of selects) {\n    select.value = \"\";\n  }\n\n  // Get old data to persist before clearing form\n  const formData = getCurrentFormData();\n  record = {\n    ...record,\n    ...formData,\n  };\n\n  formElement.innerHTML = \"\";\n  const fields = lazy.FormAutofillUtils.getFormLayout(record);\n\n  const layoutGenerator = convertLayoutToUI(fields, l10nStrings);\n\n  for (const fieldElement of layoutGenerator) {\n    formElement.appendChild(fieldElement);\n  }\n\n  document.querySelector(\"#country\").addEventListener(\n    \"change\",\n    (ev) =>\n      // Allow some time for the user to type\n      // before we set the new country and re-render\n      setTimeout(() => {\n        record.country = ev.target.value;\n        createFormLayoutFromRecord(formElement, record, l10nStrings);\n      }, 300),\n    { once: true }\n  );\n\n  // Used to notify tests that the form has been updated and is ready\n  window.dispatchEvent(new CustomEvent(\"FormReadyForTests\"));\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/addressFormLayout.js?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script/fathom.mjs":
/*!********************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/fathom.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"and\": () => (/* binding */ and),\n/* harmony export */   \"atMost\": () => (/* binding */ atMost),\n/* harmony export */   \"clusters\": () => (/* binding */ clusters$1),\n/* harmony export */   \"dom\": () => (/* binding */ dom),\n/* harmony export */   \"element\": () => (/* binding */ element),\n/* harmony export */   \"exceptions\": () => (/* binding */ exceptions),\n/* harmony export */   \"nearest\": () => (/* binding */ nearest),\n/* harmony export */   \"note\": () => (/* binding */ note),\n/* harmony export */   \"out\": () => (/* binding */ out),\n/* harmony export */   \"props\": () => (/* binding */ props),\n/* harmony export */   \"rule\": () => (/* binding */ rule),\n/* harmony export */   \"ruleset\": () => (/* binding */ ruleset),\n/* harmony export */   \"score\": () => (/* binding */ score),\n/* harmony export */   \"type\": () => (/* binding */ type),\n/* harmony export */   \"typeIn\": () => (/* binding */ typeIn),\n/* harmony export */   \"utils\": () => (/* binding */ utilsForFrontend),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\n/*\nDO NOT TOUCH fathom.mjs DIRECTLY. See the README for instructions.\n*/\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/**\n * A :func:`rule` depends on another rule which itself depends on the first\n * rule again, either directly or indirectly.\n */\nclass CycleError extends Error {\n}\n\n/**\n  * An examined element was not contained in a browser ``window`` object, but\n  * something needed it to be.\n  */\nclass NoWindowError extends Error {\n}\n\nvar exceptions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CycleError: CycleError,\n  NoWindowError: NoWindowError\n});\n\n/**\n * Return the passed-in arg. Useful as a default.\n */\nfunction identity(x) {\n    return x;\n}\n\n/*eslint-env browser*/\n\n/**\n * From an iterable return the best item, according to an arbitrary comparator\n * function. In case of a tie, the first item wins.\n *\n * @arg by {function} Given an item of the iterable, return a value to compare\n * @arg isBetter {function} Return whether its first arg is better than its\n *     second\n */\nfunction best(iterable, by, isBetter) {\n    let bestSoFar, bestKeySoFar;\n    let isFirst = true;\n    forEach(\n        function (item) {\n            const key = by(item);\n            if (isBetter(key, bestKeySoFar) || isFirst) {\n                bestSoFar = item;\n                bestKeySoFar = key;\n                isFirst = false;\n            }\n        },\n        iterable);\n    if (isFirst) {\n        throw new Error('Tried to call best() on empty iterable');\n    }\n    return bestSoFar;\n}\n\n/**\n * Return the maximum item from an iterable, as defined by >.\n *\n * Works with any type that works with >. If multiple items are equally great,\n * return the first.\n *\n * @arg by {function} Given an item of the iterable, returns a value to\n *     compare\n */\nfunction max(iterable, by = identity) {\n    return best(iterable, by, (a, b) => a > b);\n}\n\n/**\n * Return an Array of maximum items from an iterable, as defined by > and ===.\n *\n * If an empty iterable is passed in, return [].\n */\nfunction maxes(iterable, by = identity) {\n    let bests = [];\n    let bestKeySoFar;\n    let isFirst = true;\n    forEach(\n        function (item) {\n            const key = by(item);\n            if (key > bestKeySoFar || isFirst) {\n                bests = [item];\n                bestKeySoFar = key;\n                isFirst = false;\n            } else if (key === bestKeySoFar) {\n                bests.push(item);\n            }\n        },\n        iterable);\n    return bests;\n}\n\n/**\n * Return the minimum item from an iterable, as defined by <.\n *\n * If multiple items are equally great, return the first.\n */\nfunction min(iterable, by = identity) {\n    return best(iterable, by, (a, b) => a < b);\n}\n\n/**\n * Return the sum of an iterable, as defined by the + operator.\n */\nfunction sum(iterable) {\n    let total;\n    let isFirst = true;\n    forEach(\n        function assignOrAdd(addend) {\n            if (isFirst) {\n                total = addend;\n                isFirst = false;\n            } else {\n                total += addend;\n            }\n        },\n        iterable);\n    return total;\n}\n\n/**\n * Return the number of items in an iterable, consuming it as a side effect.\n */\nfunction length(iterable) {\n    let num = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (let item of iterable) {\n        num++;\n    }\n    return num;\n}\n\n/**\n * Iterate, depth first, over a DOM node. Return the original node first.\n *\n * @arg shouldTraverse {function} Given a node, say whether we should\n *     include it and its children. Default: always true.\n */\nfunction *walk(element, shouldTraverse = element => true) {\n    yield element;\n    for (let child of element.childNodes) {\n        if (shouldTraverse(child)) {\n            for (let w of walk(child, shouldTraverse)) {\n                yield w;\n            }\n        }\n    }\n}\n\nconst blockTags = new Set(\n    ['ADDRESS', 'BLOCKQUOTE', 'BODY', 'CENTER', 'DIR', 'DIV', 'DL',\n     'FIELDSET', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR',\n     'ISINDEX', 'MENU', 'NOFRAMES', 'NOSCRIPT', 'OL', 'P', 'PRE',\n     'TABLE', 'UL', 'DD', 'DT', 'FRAMESET', 'LI', 'TBODY', 'TD',\n     'TFOOT', 'TH', 'THEAD', 'TR', 'HTML']);\n/**\n * Return whether a DOM element is a block element by default (rather than by\n * styling).\n */\nfunction isBlock(element) {\n    return blockTags.has(element.tagName);\n}\n\n/**\n * Yield strings of text nodes within a normalized DOM node and its children,\n * without venturing into any contained block elements.\n *\n * @arg shouldTraverse {function} Specify additional elements to exclude by\n *     returning false\n */\nfunction *inlineTexts(element, shouldTraverse = element => true) {\n    // TODO: Could we just use querySelectorAll() with a really long\n    // selector rather than walk(), for speed?\n    for (let child of walk(element,\n                           element => !(isBlock(element) ||\n                                        element.tagName === 'SCRIPT' &&\n                                        element.tagName === 'STYLE')\n                                      && shouldTraverse(element))) {\n        if (child.nodeType === child.TEXT_NODE) {\n            // wholeText() is not implemented by jsdom, so we use\n            // textContent(). The result should be the same, since\n            // we're calling it on only text nodes, but it may be\n            // slower. On the positive side, it means we don't need to\n            // normalize the DOM tree first.\n            yield child.textContent;\n        }\n    }\n}\n\n/**\n * Return the total length of the inline text within an element, with\n * whitespace collapsed.\n *\n * @arg shouldTraverse {function} Specify additional elements to exclude by\n *     returning false\n */\nfunction inlineTextLength(element, shouldTraverse = element => true) {\n    return sum(map(text => collapseWhitespace(text).length,\n                   inlineTexts(element, shouldTraverse)));\n}\n\n/**\n * Return a string with each run of whitespace collapsed to a single space.\n */\nfunction collapseWhitespace(str) {\n    return str.replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Return the ratio of the inline text length of the links in an element to the\n * inline text length of the entire element.\n *\n * @arg inlineLength {number} Optionally, the precalculated inline\n *     length of the fnode. If omitted, we will calculate it ourselves.\n */\nfunction linkDensity(fnode, inlineLength) {\n    if (inlineLength === undefined) {\n        inlineLength = inlineTextLength(fnode.element);\n    }\n    const lengthWithoutLinks = inlineTextLength(fnode.element,\n                                                element => element.tagName !== 'A');\n    return (inlineLength - lengthWithoutLinks) / inlineLength;\n}\n\n/**\n * Return whether an element is a text node that consist wholly of whitespace.\n */\nfunction isWhitespace(element) {\n    return (element.nodeType === element.TEXT_NODE &&\n            element.textContent.trim().length === 0);\n}\n\n/**\n * Get a key of a map, first setting it to a default value if it's missing.\n */\nfunction setDefault(map, key, defaultMaker) {\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    const defaultValue = defaultMaker();\n    map.set(key, defaultValue);\n    return defaultValue;\n}\n\n/**\n * Get a key of a map or, if it's missing, a default value.\n */\nfunction getDefault(map, key, defaultMaker) {\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    return defaultMaker();\n}\n\n/**\n * Return an Array, the reverse topological sort of the given nodes.\n *\n * @arg nodes An iterable of arbitrary things\n * @arg nodesThatNeed {function} Take a node and returns an Array of nodes\n *     that depend on it\n */\nfunction toposort(nodes, nodesThatNeed) {\n    const ret = [];\n    const todo = new Set(nodes);\n    const inProgress = new Set();\n\n    function visit(node) {\n        if (inProgress.has(node)) {\n            throw new CycleError('The graph has a cycle.');\n        }\n        if (todo.has(node)) {\n            inProgress.add(node);\n            for (let needer of nodesThatNeed(node)) {\n                visit(needer);\n            }\n            inProgress.delete(node);\n            todo.delete(node);\n            ret.push(node);\n        }\n    }\n\n    while (todo.size > 0) {\n        visit(first(todo));\n    }\n    return ret;\n}\n\n/**\n * A Set with the additional methods it ought to have had\n */\nclass NiceSet extends Set {\n    /**\n     * Remove and return an arbitrary item. Throw an Error if I am empty.\n     */\n    pop() {\n        for (let v of this.values()) {\n            this.delete(v);\n            return v;\n        }\n        throw new Error('Tried to pop from an empty NiceSet.');\n    }\n\n    /**\n     * Union another set or other iterable into myself.\n     *\n     * @return myself, for chaining\n     */\n    extend(otherSet) {\n        for (let item of otherSet) {\n            this.add(item);\n        }\n        return this;\n    }\n\n    /**\n     * Subtract another set from a copy of me.\n     *\n     * @return a copy of myself excluding the elements in ``otherSet``.\n     */\n    minus(otherSet) {\n        const ret = new NiceSet(this);\n        for (const item of otherSet) {\n            ret.delete(item);\n        }\n        return ret;\n    }\n\n    /**\n     * Actually show the items in me.\n     */\n    toString() {\n        return '{' + Array.from(this).join(', ') + '}';\n    }\n}\n\n/**\n * Return the first item of an iterable.\n */\nfunction first(iterable) {\n    for (let i of iterable) {\n        return i;\n    }\n}\n\n/**\n * Given any node in a DOM tree, return the root element of the tree, generally\n * an HTML element.\n */\nfunction rootElement(element) {\n    return element.ownerDocument.documentElement;\n}\n\n/**\n * Return the number of times a regex occurs within the string `haystack`.\n *\n * Caller must make sure `regex` has the 'g' option set.\n */\nfunction numberOfMatches(regex, haystack) {\n    return (haystack.match(regex) || []).length;\n}\n\n/**\n * Wrap a scoring callback, and set its element to the page root iff a score is\n * returned.\n *\n * This is used to build rulesets which classify entire pages rather than\n * picking out specific elements.\n *\n * For example, these rules might classify a page as a \"login page\", influenced\n * by whether they have login buttons or username fields:\n *\n * ``rule(type('loginPage'), score(page(pageContainsLoginButton))),``\n * ``rule(type('loginPage'), score(page(pageContainsUsernameField)))``\n */\nfunction page(scoringFunction) {\n    function wrapper(fnode) {\n        const scoreAndTypeAndNote = scoringFunction(fnode);\n        if (scoreAndTypeAndNote.score !== undefined) {\n            scoreAndTypeAndNote.element = rootElement(fnode.element);\n        }\n        return scoreAndTypeAndNote;\n    }\n    return wrapper;\n}\n\n/**\n * Sort the elements by their position in the DOM.\n *\n * @arg fnodes {iterable} fnodes to sort\n * @return {Array} sorted fnodes\n */\nfunction domSort(fnodes) {\n    function compare(a, b) {\n        const element = a.element;\n        const position = element.compareDocumentPosition(b.element);\n        if (position & element.DOCUMENT_POSITION_FOLLOWING) {\n            return -1;\n        } else if (position & element.DOCUMENT_POSITION_PRECEDING) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n    return Array.from(fnodes).sort(compare);\n}\n\n/* istanbul ignore next */\n/**\n * Return the DOM element contained in a passed-in fnode. Return passed-in DOM\n * elements verbatim.\n *\n * @arg fnodeOrElement {Node|Fnode}\n */\nfunction toDomElement(fnodeOrElement) {\n    return isDomElement(fnodeOrElement) ? fnodeOrElement : fnodeOrElement.element;\n}\n\n/**\n * Checks whether any of the element's attribute values satisfy some condition.\n *\n * Example::\n *\n *     rule(type('foo'),\n *          score(attributesMatch(element,\n *                                attr => attr.includes('good'),\n *                                ['id', 'alt']) ? 2 : 1))\n *\n * @arg element {Node} Element whose attributes you want to search\n * @arg predicate {function} A condition to check. Take a string and\n *     return a boolean. If an attribute has multiple values (e.g. the class\n *     attribute), attributesMatch will check each one.\n * @arg attrs {string[]} An Array of attributes you want to search. If none are\n *     provided, search all.\n * @return Whether any of the attribute values satisfy the predicate function\n */\nfunction attributesMatch(element, predicate, attrs = []) {\n    const attributes = attrs.length === 0 ? Array.from(element.attributes).map(a => a.name) : attrs;\n    for (let i = 0; i < attributes.length; i++) {\n        const attr = element.getAttribute(attributes[i]);\n        // If the attribute is an array, apply the scoring function to each element\n        if (attr && ((Array.isArray(attr) && attr.some(predicate)) || predicate(attr))) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* istanbul ignore next */\n/**\n * Yield an element and each of its ancestors.\n */\nfunction *ancestors(element) {\n    yield element;\n    let parent;\n    while ((parent = element.parentNode) !== null && parent.nodeType === parent.ELEMENT_NODE) {\n        yield parent;\n        element = parent;\n    }\n}\n\n/**\n * Return the sigmoid of the argument: 1 / (1 + exp(-x)). This is useful for\n * crunching a feature value that may have a wide range into the range (0, 1)\n * without a hard ceiling: the sigmoid of even a very large number will be a\n * little larger than that of a slightly smaller one.\n *\n * @arg x {Number} a number to be compressed into the range (0, 1)\n */\nfunction sigmoid(x) {\n    return 1 / (1 + Math.exp(-x));\n}\n\n/* istanbul ignore next */\n/**\n * Return whether an element is practically visible, considering things like 0\n * size or opacity, ``visibility: hidden`` and ``overflow: hidden``.\n *\n * Merely being scrolled off the page in either horizontally or vertically\n * doesn't count as invisible; the result of this function is meant to be\n * independent of viewport size.\n *\n * @throws {NoWindowError} The element (or perhaps one of its ancestors) is not\n *     in a window, so we can't find the `getComputedStyle()` routine to call.\n *     That routine is the source of most of the information we use, so you\n *     should pick a different strategy for non-window contexts.\n */\nfunction isVisible(fnodeOrElement) {\n    // This could be 5x more efficient if https://github.com/w3c/csswg-drafts/issues/4122 happens.\n    const element = toDomElement(fnodeOrElement);\n    const elementWindow = windowForElement(element);\n    const elementRect = element.getBoundingClientRect();\n    const elementStyle = elementWindow.getComputedStyle(element);\n    // Alternative to reading ``display: none`` due to Bug 1381071.\n    if (elementRect.width === 0 && elementRect.height === 0 && elementStyle.overflow !== 'hidden') {\n        return false;\n    }\n    if (elementStyle.visibility === 'hidden') {\n        return false;\n    }\n    // Check if the element is irrevocably off-screen:\n    if (elementRect.x + elementRect.width < 0 ||\n        elementRect.y + elementRect.height < 0\n    ) {\n        return false;\n    }\n    for (const ancestor of ancestors(element)) {\n        const isElement = ancestor === element;\n        const style = isElement ? elementStyle : elementWindow.getComputedStyle(ancestor);\n        if (style.opacity === '0') {\n            return false;\n        }\n        if (style.display === 'contents') {\n            // ``display: contents`` elements have no box themselves, but children are\n            // still rendered.\n            continue;\n        }\n        const rect = isElement ? elementRect : ancestor.getBoundingClientRect();\n        if ((rect.width === 0 || rect.height === 0) && elementStyle.overflow === 'hidden') {\n            // Zero-sized ancestors don’t make descendants hidden unless the descendant\n            // has ``overflow: hidden``.\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Return the extracted [r, g, b, a] values from a string like \"rgba(0, 5, 255, 0.8)\",\n * and scale them to 0..1. If no alpha is specified, return undefined for it.\n */\nfunction rgbaFromString(str) {\n    const m = str.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i);\n    if (m) {\n        return [m[1] / 255, m[2] / 255, m[3] / 255, m[4] === undefined ? undefined : parseFloat(m[4])];\n    } else {\n        throw new Error('Color ' + str + ' did not match pattern rgb[a](r, g, b[, a]).');\n    }\n}\n\n/**\n * Return the saturation 0..1 of a color defined by RGB values 0..1.\n */\nfunction saturation(r, g, b) {\n    const cMax = Math.max(r, g, b);\n    const cMin = Math.min(r, g, b);\n    const delta = cMax - cMin;\n    const lightness = (cMax + cMin) / 2;\n    const denom = (1 - (Math.abs(2 * lightness - 1)));\n    // Return 0 if it's black (R, G, and B all 0).\n    return (denom === 0) ? 0 : delta / denom;\n}\n\n/**\n * Scale a number to the range [0, 1] using a linear slope.\n *\n * For a rising line, the result is 0 until the input reaches zeroAt, then\n * increases linearly until oneAt, at which it becomes 1. To make a falling\n * line, where the result is 1 to the left and 0 to the right, use a zeroAt\n * greater than oneAt.\n */\nfunction linearScale(number, zeroAt, oneAt) {\n    const isRising = zeroAt < oneAt;\n    if (isRising) {\n        if (number <= zeroAt) {\n            return 0;\n        } else if (number >= oneAt) {\n            return 1;\n        }\n    } else {\n        if (number >= zeroAt) {\n            return 0;\n        } else if (number <= oneAt) {\n            return 1;\n        }\n    }\n    const slope = 1 / (oneAt - zeroAt);\n    return slope * (number - zeroAt);\n}\n\n// -------- Routines below this point are private to the framework. --------\n\n/**\n * Flatten out an iterable of iterables into a single iterable of non-\n * iterables. Does not consider strings to be iterable.\n */\nfunction *flatten(iterable) {\n    for (const i of iterable) {\n        if (typeof i !== 'string' && isIterable(i)) {\n            yield *(flatten(i));\n        } else {\n            yield i;\n        }\n    }\n}\n\n/**\n * A lazy, top-level ``Array.map()`` workalike that works on anything iterable\n */\nfunction *map(fn, iterable) {\n    for (const i of iterable) {\n        yield fn(i);\n    }\n}\n\n/**\n * A lazy, top-level ``Array.forEach()`` workalike that works on anything\n * iterable\n */\nfunction forEach(fn, iterable) {\n    for (const i of iterable) {\n        fn(i);\n    }\n}\n\n/* istanbul ignore next */\n/**\n * @return whether a thing appears to be a DOM element.\n */\nfunction isDomElement(thing) {\n    return thing.nodeName !== undefined;\n}\n\nfunction isIterable(thing) {\n    return thing && typeof thing[Symbol.iterator] === 'function';\n}\n\n/**\n * Return an backward iterator over an Array without reversing it in place.\n */\nfunction *reversed(array) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        yield array[i];\n    }\n}\n\n/* istanbul ignore next */\n/*\n * Return the window an element is in.\n *\n * @throws {NoWindowError} There isn't such a window.\n */\nfunction windowForElement(element) {\n    let doc = element.ownerDocument;\n    if (doc === null) {\n        // The element itself was a document.\n        doc = element;\n    }\n    const win = doc.defaultView;\n    if (win === null) {\n        throw new NoWindowError();\n    }\n    return win;\n}\n\nvar utilsForFrontend = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  identity: identity,\n  best: best,\n  max: max,\n  maxes: maxes,\n  min: min,\n  sum: sum,\n  length: length,\n  walk: walk,\n  isBlock: isBlock,\n  inlineTexts: inlineTexts,\n  inlineTextLength: inlineTextLength,\n  collapseWhitespace: collapseWhitespace,\n  linkDensity: linkDensity,\n  isWhitespace: isWhitespace,\n  setDefault: setDefault,\n  getDefault: getDefault,\n  toposort: toposort,\n  NiceSet: NiceSet,\n  first: first,\n  rootElement: rootElement,\n  numberOfMatches: numberOfMatches,\n  page: page,\n  domSort: domSort,\n  toDomElement: toDomElement,\n  attributesMatch: attributesMatch,\n  ancestors: ancestors,\n  sigmoid: sigmoid,\n  isVisible: isVisible,\n  rgbaFromString: rgbaFromString,\n  saturation: saturation,\n  linearScale: linearScale,\n  flatten: flatten,\n  map: map,\n  forEach: forEach,\n  isDomElement: isDomElement,\n  reversed: reversed,\n  windowForElement: windowForElement\n});\n\n/**\n * Return the number of stride nodes between 2 DOM nodes *at the same\n * level of the tree*, without going up or down the tree.\n *\n * ``left`` xor ``right`` may also be undefined.\n */\nfunction numStrides(left, right) {\n    let num = 0;\n\n    // Walk right from left node until we hit the right node or run out:\n    let sibling = left;\n    let shouldContinue = sibling && sibling !== right;\n    while (shouldContinue) {\n        sibling = sibling.nextSibling;\n        if ((shouldContinue = sibling && sibling !== right) &&\n            !isWhitespace(sibling)) {\n            num += 1;\n        }\n    }\n    if (sibling !== right) {  // Don't double-punish if left and right are siblings.\n        // Walk left from right node:\n        sibling = right;\n        while (sibling) {\n            sibling = sibling.previousSibling;\n            if (sibling && !isWhitespace(sibling)) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}\n\n/**\n * Return a topological distance between 2 DOM nodes or :term:`fnodes<fnode>`\n * weighted according to the similarity of their ancestry in the DOM. For\n * instance, if one node is situated inside ``<div><span><b><theNode>`` and the\n * other node is at ``<differentDiv><span><b><otherNode>``, they are considered\n * close to each other for clustering purposes. This is useful for picking out\n * nodes which have similar purposes.\n *\n * Return ``Number.MAX_VALUE`` if one of the nodes contains the other.\n *\n * This is largely an implementation detail of :func:`clusters`, but you can\n * call it yourself if you wish to implement your own clustering. Takes O(n log\n * n) time.\n *\n * Note that the default costs may change; pass them in explicitly if they are\n * important to you.\n *\n * @arg fnodeA {Node|Fnode}\n * @arg fnodeB {Node|Fnode}\n * @arg differentDepthCost {number} Cost for each level deeper one node is than\n *    the other below their common ancestor\n * @arg differentTagCost {number} Cost for a level below the common ancestor\n *    where tagNames differ\n * @arg sameTagCost {number} Cost for a level below the common ancestor where\n *    tagNames are the same\n * @arg strideCost {number} Cost for each stride node between A and B. Stride\n *     nodes are siblings or siblings-of-ancestors that lie between the 2\n *     nodes. These interposed nodes make it less likely that the 2 nodes\n *     should be together in a cluster.\n * @arg additionalCost {function} Return an additional cost, given 2 fnodes or\n *    nodes.\n *\n */\nfunction distance(fnodeA,\n                         fnodeB,\n                         {differentDepthCost = 2,\n                          differentTagCost = 2,\n                          sameTagCost = 1,\n                          strideCost = 1,\n                          additionalCost = (fnodeA, fnodeB) => 0} = {}) {\n    // I was thinking of something that adds little cost for siblings. Up\n    // should probably be more expensive than down (see middle example in the\n    // Nokia paper).\n\n    // TODO: Test and tune default costs. They're off the cuff at the moment.\n\n    if (fnodeA === fnodeB) {\n        return 0;\n    }\n\n    const elementA = isDomElement(fnodeA) ? fnodeA : fnodeA.element;\n    const elementB = isDomElement(fnodeB) ? fnodeB : fnodeB.element;\n\n    // Stacks that go from the common ancestor all the way to A and B:\n    const aAncestors = [elementA];\n    const bAncestors = [elementB];\n\n    let aAncestor = elementA;\n    let bAncestor = elementB;\n\n    // Ascend to common parent, stacking them up for later reference:\n    while (!aAncestor.contains(elementB)) {  // Note: an element does contain() itself.\n        aAncestor = aAncestor.parentNode;\n        aAncestors.push(aAncestor); //aAncestors = [a, b]. aAncestor = b // if a is outer: no loop here; aAncestors = [a]. aAncestor = a.\n    }\n\n    // In compareDocumentPosition()'s opinion, inside implies after. Basically,\n    // before and after pertain to opening tags.\n    const comparison = elementA.compareDocumentPosition(elementB);\n\n    // If either contains the other, abort. We'd either return a misleading\n    // number or else walk upward right out of the document while trying to\n    // make the ancestor stack.\n    if (comparison & (elementA.DOCUMENT_POSITION_CONTAINS | elementA.DOCUMENT_POSITION_CONTAINED_BY)) {\n        return Number.MAX_VALUE;\n    }\n    // Make an ancestor stack for the right node too so we can walk\n    // efficiently down to it:\n    do {\n        bAncestor = bAncestor.parentNode;  // Assumes we've early-returned above if A === B. This walks upward from the outer node and up out of the tree. It STARTS OUT with aAncestor === bAncestor!\n        bAncestors.push(bAncestor);\n    } while (bAncestor !== aAncestor);\n\n    // Figure out which node is left and which is right, so we can follow\n    // sibling links in the appropriate directions when looking for stride\n    // nodes:\n    let left = aAncestors;\n    let right = bAncestors;\n    let cost = 0;\n    if (comparison & elementA.DOCUMENT_POSITION_FOLLOWING) {\n        // A is before, so it could contain the other node. What did I mean to do if one contained the other?\n        left = aAncestors;\n        right = bAncestors;\n    } else if (comparison & elementA.DOCUMENT_POSITION_PRECEDING) {\n        // A is after, so it might be contained by the other node.\n        left = bAncestors;\n        right = aAncestors;\n    }\n\n    // Descend to both nodes in parallel, discounting the traversal\n    // cost iff the nodes we hit look similar, implying the nodes dwell\n    // within similar structures.\n    while (left.length || right.length) {\n        const l = left.pop();\n        const r = right.pop();\n        if (l === undefined || r === undefined) {\n            // Punishment for being at different depths: same as ordinary\n            // dissimilarity punishment for now\n            cost += differentDepthCost;\n        } else {\n            // TODO: Consider similarity of classList.\n            cost += l.tagName === r.tagName ? sameTagCost : differentTagCost;\n        }\n        // Optimization: strides might be a good dimension to eliminate.\n        if (strideCost !== 0) {\n            cost += numStrides(l, r) * strideCost;\n        }\n    }\n\n    return cost + additionalCost(fnodeA, fnodeB);\n}\n\n/**\n * Return the spatial distance between 2 fnodes or elements, assuming a\n * rendered page.\n *\n * Specifically, return the distance in pixels between the centers of\n * ``fnodeA.element.getBoundingClientRect()`` and\n * ``fnodeB.element.getBoundingClientRect()``.\n */\nfunction euclidean(fnodeA, fnodeB) {\n    /**\n     * Return the horizontal distance from the left edge of the viewport to the\n     * center of an element, given a DOMRect object for it. It doesn't matter\n     * that the distance is affected by the page's scroll offset, since the 2\n     * elements have the same offset.\n     */\n    function xCenter(domRect) {\n        return domRect.left + domRect.width / 2;\n    }\n    function yCenter(domRect) {\n        return domRect.top + domRect.height / 2;\n    }\n\n    const elementA = toDomElement(fnodeA);\n    const elementB = toDomElement(fnodeB);\n    const aRect = elementA.getBoundingClientRect();\n    const bRect = elementB.getBoundingClientRect();\n    return Math.sqrt((xCenter(aRect) - xCenter(bRect)) ** 2 +\n                     (yCenter(aRect) - yCenter(bRect)) ** 2);\n}\n\n/** A lower-triangular matrix of inter-cluster distances */\nclass DistanceMatrix {\n    /**\n     * @arg distance {function} Some notion of distance between 2 given nodes\n     */\n    constructor(elements, distance) {\n        // A sparse adjacency matrix:\n        // {A => {},\n        //  B => {A => 4},\n        //  C => {A => 4, B => 4},\n        //  D => {A => 4, B => 4, C => 4}\n        //  E => {A => 4, B => 4, C => 4, D => 4}}\n        //\n        // A, B, etc. are arrays of [arrays of arrays of...] nodes, each\n        // array being a cluster. In this way, they not only accumulate a\n        // cluster but retain the steps along the way.\n        //\n        // This is an efficient data structure in terms of CPU and memory, in\n        // that we don't have to slide a lot of memory around when we delete a\n        // row or column from the middle of the matrix while merging. Of\n        // course, we lose some practical efficiency by using hash tables, and\n        // maps in particular are slow in their early implementations.\n        this._matrix = new Map();\n\n        // Convert elements to clusters:\n        const clusters = elements.map(el => [el]);\n\n        // Init matrix:\n        for (let outerCluster of clusters) {\n            const innerMap = new Map();\n            for (let innerCluster of this._matrix.keys()) {\n                innerMap.set(innerCluster, distance(outerCluster[0],\n                                                    innerCluster[0]));\n            }\n            this._matrix.set(outerCluster, innerMap);\n        }\n        this._numClusters = clusters.length;\n    }\n\n    // Return (distance, a: clusterA, b: clusterB) of closest-together clusters.\n    // Replace this to change linkage criterion.\n    closest() {\n        const self = this;\n\n        if (this._numClusters < 2) {\n            throw new Error('There must be at least 2 clusters in order to return the closest() ones.');\n        }\n\n        // Return the distances between every pair of clusters.\n        function clustersAndDistances() {\n            const ret = [];\n            for (let [outerKey, row] of self._matrix.entries()) {\n                for (let [innerKey, storedDistance] of row.entries()) {\n                    ret.push({a: outerKey, b: innerKey, distance: storedDistance});\n                }\n            }\n            return ret;\n        }\n        // Optimizing this by inlining the loop and writing it less\n        // functionally doesn't help:\n        return min(clustersAndDistances(), x => x.distance);\n    }\n\n    // Look up the distance between 2 clusters in me. Try the lookup in the\n    // other direction if the first one falls in the nonexistent half of the\n    // triangle.\n    _cachedDistance(clusterA, clusterB) {\n        let ret = this._matrix.get(clusterA).get(clusterB);\n        if (ret === undefined) {\n            ret = this._matrix.get(clusterB).get(clusterA);\n        }\n        return ret;\n    }\n\n    // Merge two clusters.\n    merge(clusterA, clusterB) {\n        // An example showing how rows merge:\n        //  A: {}\n        //  B: {A: 1}\n        //  C: {A: 4, B: 4},\n        //  D: {A: 4, B: 4, C: 4}\n        //  E: {A: 4, B: 4, C: 2, D: 4}}\n        //\n        // Step 2:\n        //  C: {}\n        //  D: {C: 4}\n        //  E: {C: 2, D: 4}}\n        //  AB: {C: 4, D: 4, E: 4}\n        //\n        // Step 3:\n        //  D:  {}\n        //  AB: {D: 4}\n        //  CE: {D: 4, AB: 4}\n\n        // Construct new row, finding min distances from either subcluster of\n        // the new cluster to old clusters.\n        //\n        // There will be no repetition in the matrix because, after all,\n        // nothing pointed to this new cluster before it existed.\n        const newRow = new Map();\n        for (let outerKey of this._matrix.keys()) {\n            if (outerKey !== clusterA && outerKey !== clusterB) {\n                newRow.set(outerKey, Math.min(this._cachedDistance(clusterA, outerKey),\n                                              this._cachedDistance(clusterB, outerKey)));\n            }\n        }\n\n        // Delete the rows of the clusters we're merging.\n        this._matrix.delete(clusterA);\n        this._matrix.delete(clusterB);\n\n        // Remove inner refs to the clusters we're merging.\n        for (let inner of this._matrix.values()) {\n            inner.delete(clusterA);\n            inner.delete(clusterB);\n        }\n\n        // Attach new row.\n        this._matrix.set([clusterA, clusterB], newRow);\n\n        // There is a net decrease of 1 cluster:\n        this._numClusters -= 1;\n    }\n\n    numClusters() {\n        return this._numClusters;\n    }\n\n    // Return an Array of nodes for each cluster in me.\n    clusters() {\n        // TODO: Can't get map to work here. Don't know why.\n        return Array.from(this._matrix.keys()).map(e => Array.from(flatten(e)));\n    }\n}\n\n/**\n * Partition the given nodes into one or more clusters by position in the DOM\n * tree.\n *\n * This implements an agglomerative clustering. It uses single linkage, since\n * we're talking about adjacency here more than Euclidean proximity: the\n * clusters we're talking about in the DOM will tend to be adjacent, not\n * overlapping. We haven't tried other linkage criteria yet.\n *\n * In a later release, we may consider score or notes.\n *\n * @arg {Fnode[]|Node[]} fnodes :term:`fnodes<fnode>` or DOM nodes to group\n *     into clusters\n * @arg {number} splittingDistance The closest-nodes :func:`distance` beyond\n *     which we will not attempt to unify 2 clusters. Make this larger to make\n *     larger clusters.\n * @arg getDistance {function} A function that returns some notion of numerical\n *    distance between 2 nodes. Default: :func:`distance`\n * @return {Array} An Array of Arrays, with each Array containing all the\n *     nodes in one cluster. Note that neither the clusters nor the nodes are\n *     in any particular order. You may find :func:`domSort` helpful to remedy\n *     the latter.\n */\nfunction clusters(fnodes, splittingDistance, getDistance = distance) {\n    const matrix = new DistanceMatrix(fnodes, getDistance);\n    let closest;\n\n    while (matrix.numClusters() > 1 && (closest = matrix.closest()).distance < splittingDistance) {\n        matrix.merge(closest.a, closest.b);\n    }\n\n    return matrix.clusters();\n}\n\nvar clusters$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  distance: distance,\n  euclidean: euclidean,\n  clusters: clusters\n});\n\n// The left-hand side of a rule\n\n\n/**\n * Take nodes that match a given DOM selector. Example:\n * ``dom('meta[property=\"og:title\"]')``\n *\n * Every ruleset has at least one ``dom`` or :func:`element` rule, as that is\n * where nodes begin to flow into the system. If run against a subtree of a\n * document, the root of the subtree is not considered as a possible match.\n */\nfunction dom(selector) {\n    return new DomLhs(selector);\n}\n\n/**\n * Take a single given node if it matches a given DOM selector, without looking\n * through its descendents or ancestors. Otherwise, take no nodes. Example:\n * ``element('input')``\n *\n * This is useful for applications in which you want Fathom to classify an\n * element the user has selected, rather than scanning the whole page for\n * candidates.\n */\nfunction element(selector) {\n    return new ElementLhs(selector);\n}\n\n/**\n * Rules and the LHSs and RHSs that comprise them have no mutable state. This\n * lets us make BoundRulesets from Rulesets without duplicating the rules. It\n * also lets us share a common cache among rules: multiple ones might care\n * about a cached type(), for instance; there isn't a one-to-one relationship\n * of storing with caring. There would also, because of the interdependencies\n * of rules in a ruleset, be little use in segmenting the caches: if you do\n * something that causes one to need to be cleared, you'll need to clear many\n * more as well.\n *\n * Lhses are responsible for maintaining ruleset.maxCache.\n *\n * Lhs and its subclasses are private to the Fathom framework.\n */\nclass Lhs {\n    constructor() {\n        this._predicate = () => true;\n    }\n\n    /** Return a new Lhs of the appropriate kind, given its first call. */\n    static fromFirstCall(firstCall) {\n        // firstCall is never 'dom', because dom() directly returns a DomLhs.\n        if (firstCall.method === 'type') {\n            return new TypeLhs(...firstCall.args);\n        } else if (firstCall.method === 'and') {\n            return new AndLhs(firstCall.args);\n        } else if (firstCall.method === 'nearest') {\n            return new NearestLhs(firstCall.args);\n        } else {\n            throw new Error('The left-hand side of a rule() must start with dom(), type(), and(), or nearest().');\n        }\n    }\n\n    /**\n     * Prune nodes from consideration early in run execution, before scoring is\n     * done.\n     *\n     * Reserve this for where you are sure it is always correct or when\n     * performance demands it. It is generally preferable to use :func:`score`\n     * and let the :doc:`trainer<training>` determine the relative significance\n     * of each rule. Human intuition as to what is important is often wrong:\n     * for example, one might assume that a music player website would include\n     * the word \"play\", but this does not hold once you include sites in other\n     * languages.\n     *\n     * Can be chained after :func:`type` or :func:`dom`.\n     *\n     * Example: ``dom('p').when(isVisible)``\n     *\n     * @arg {function} predicate Accepts a fnode and returns a boolean\n     */\n    when(predicate) {\n        let lhs = this.clone();\n        lhs._predicate = predicate;\n        return lhs;\n    }\n\n    /**\n     * Of all the dom nodes selected by type() or dom(), return only\n     * the fnodes that satisfy all the predicates imposed by calls to\n     * when()\n     */\n    fnodesSatisfyingWhen(fnodes) {\n        return Array.from(fnodes).filter(this._predicate);\n    }\n\n    /**\n     * Return an iterable of output fnodes selected by this left-hand-side\n     * expression.\n     *\n     * Pre: The rules I depend on have already been run, and their results are\n     * in ruleset.typeCache.\n     *\n     * @arg ruleset {BoundRuleset}\n     */\n    // fnodes (ruleset) {}\n\n    /**\n     * Check that a RHS-emitted fact is legal for this kind of LHS, and throw\n     * an error if it isn't.\n     */\n    checkFact(fact) {}\n\n    /**\n     * Return the single type the output of the LHS is guaranteed to have.\n     * Return undefined if there is no such single type we can ascertain.\n     */\n    guaranteedType() {}\n\n    /**\n     * Return the type I aggregate if I am an aggregate LHS; return undefined\n     * otherwise.\n     */\n    aggregatedType() {}\n\n    /**\n     * Return each combination of types my selected nodes could be locally (that\n     * is, by this rule only) constrained to have.\n     *\n     * For example, type(A) would return [A]. and(A, or(B, C)) would return\n     * [AB, AC, ABC]. More examples:\n     *\n     * or(A, B) → typeIn(A, B, C)  # Finalizes A, B.   combos A, B, AB: finalizes AB. Optimization: there's no point in returning the last combo in ors. Compilation into 2 rules with identical RHSs will inherently implement this optimization.\n     * or(A, B) → typeIn(A, B)  # Finalizes A, B\n     * or(A, B) → A  # Finalizes B\n     * and(A) -> A  # Finalizes nothing\n     * and(A, B) -> A  # Finalizes nothing.   AB: Ø\n     * and(A) -> typeIn(A, B)  # Finalizes A.   A\n     * and(A, B) -> typeIn(A, B)  # Finalizes nothing.   AB\n     * and(A, B) -> typeIn(A, B, C)  # Finalizes A, B.   AB\n     * and(A, or(B, C)) -> D  # Finalizes A, B, C.   AB, AC, ABC: ABC\n     * and(A, or(B, C)) -> B  # Finalizes A, C.   AB, AC, ABC: AC\n     * type(A).not(and(A, B)) ->\n     *\n     * @return {NiceSet[]}\n     */\n    // possibleTypeCombinations() {}\n\n    /**\n     * Types mentioned in this LHS.\n     *\n     * In other words, the types I need to know the assignment status of before\n     * I can make my selections\n     *\n     * @return NiceSet of strings\n     */\n    // typesMentioned() {}\n}\n\nclass DomLhs extends Lhs {\n    constructor(selector) {\n        super();\n        if (selector === undefined) {\n            throw new Error('A querySelector()-style selector is required as the argument to ' + this._callName() + '().');\n        }\n        this.selector = selector;\n    }\n\n    /**\n     * Return the name of this kind of LHS, for use in error messages.\n     */\n    _callName() {\n        return 'dom';\n    }\n\n    clone() {\n        return new this.constructor(this.selector);\n    }\n\n    fnodes(ruleset) {\n        return this._domNodesToFilteredFnodes(\n            ruleset,\n            ruleset.doc.querySelectorAll(this.selector));\n    }\n\n    /**\n     * Turn a NodeList of DOM nodes into an array of fnodes, and filter out\n     * those that don't match the :func:`when()` clause.\n     */\n    _domNodesToFilteredFnodes(ruleset, domNodes) {\n        let ret = [];\n        for (let i = 0; i < domNodes.length; i++) {\n            ret.push(ruleset.fnodeForElement(domNodes[i]));\n        }\n        return this.fnodesSatisfyingWhen(ret);\n    }\n\n    checkFact(fact) {\n        if (fact.type === undefined) {\n            throw new Error(`The right-hand side of a ${this._callName()}() rule failed to specify a type. This means there is no way for its output to be used by later rules. All it specified was ${fact}.`);\n        }\n    }\n\n    asLhs() {\n        return this;\n    }\n\n    possibleTypeCombinations() {\n        return [];\n    }\n\n    typesMentioned() {\n        return new NiceSet();\n    }\n}\n\nclass ElementLhs extends DomLhs {\n    _callName() {\n        return 'element';\n    }\n\n    fnodes(ruleset) {\n        return this._domNodesToFilteredFnodes(\n            ruleset,\n            ruleset.doc.matches(this.selector) ? [ruleset.doc] : []);\n    }\n}\n\n/** Internal representation of a LHS constrained by type but not by max() */\nclass TypeLhs extends Lhs {\n    constructor(type) {\n        super();\n        if (type === undefined) {\n            throw new Error('A type name is required when calling type().');\n        }\n        this._type = type;  // the input type\n    }\n\n    clone() {\n        return new this.constructor(this._type);\n    }\n\n    fnodes(ruleset) {\n        const cached = getDefault(ruleset.typeCache, this._type, () => []);\n        return this.fnodesSatisfyingWhen(cached);\n    }\n\n    /** Override the type previously specified by this constraint. */\n    type(inputType) {\n        // Preserve the class in case this is a TypeMaxLhs.\n        return new this.constructor(inputType);\n    }\n\n    /**\n     * Of the nodes selected by a ``type`` call to the left, constrain the LHS\n     * to return only the max-scoring one. If there is a tie, more than 1 node\n     * will be returned. Example: ``type('titley').max()``\n     */\n    max() {\n        return new TypeMaxLhs(this._type);\n    }\n\n    /**\n     * Take the nodes selected by a ``type`` call to the left, group them into\n     * clusters, and return the nodes in the cluster that has the highest total\n     * score (on the relevant type).\n     *\n     * Nodes come out in arbitrary order, so, if you plan to emit them,\n     * consider using ``.out('whatever').allThrough(domSort)``. See\n     * :func:`domSort`.\n     *\n     * If multiple clusters have equally high scores, return an arbitrary one,\n     * because Fathom has no way to represent arrays of arrays in rulesets.\n     *\n     * @arg options {Object} The same depth costs taken by :func:`distance`,\n     *     plus ``splittingDistance``, which is the distance beyond which 2\n     *     clusters will be considered separate. ``splittingDistance``, if\n     *     omitted, defaults to 3.\n     */\n    bestCluster(options) {\n        return new BestClusterLhs(this._type, options);\n    }\n\n    // Other clustering calls could be called biggestCluster() (having the most\n    // nodes) and bestAverageCluster() (having the highest average score).\n\n    guaranteedType() {\n        return this._type;\n    }\n\n    possibleTypeCombinations() {\n        return [this.typesMentioned()];\n    }\n\n    typesMentioned() {\n        return new NiceSet([this._type]);\n    }\n}\n\n/**\n * Abstract LHS that is an aggregate function taken across all fnodes of a type\n *\n * The main point here is that any aggregate function over a (typed) set of\n * nodes depends on first computing all the rules that could emit those nodes\n * (nodes of that type).\n */\nclass AggregateTypeLhs extends TypeLhs {\n    aggregatedType() {\n        return this._type;\n    }\n}\n\n/**\n * Internal representation of a LHS that has both type and max([NUMBER])\n * constraints. max(NUMBER != 1) support is not yet implemented.\n */\nclass TypeMaxLhs extends AggregateTypeLhs {\n    /**\n     * Return the max-scoring node (or nodes if there is a tie) of the given\n     * type.\n     */\n    fnodes(ruleset) {\n        // TODO: Optimize better. Walk the dependency tree, and run only the\n        // rules that could possibly lead to a max result. As part of this,\n        // make RHSs expose their max potential scores.\n        const self = this;\n        // Work around V8 bug:\n        // https://stackoverflow.com/questions/32943776/using-super-within-an-\n        // arrow-function-within-an-arrow-function-within-a-method\n        const getSuperFnodes = () => super.fnodes(ruleset);\n        return setDefault(\n            ruleset.maxCache,\n            this._type,\n            function maxFnodesOfType() {\n                return maxes(getSuperFnodes(), fnode => ruleset.weightedScore(fnode.scoresSoFarFor(self._type)));\n            });\n    }\n}\n\nclass BestClusterLhs extends AggregateTypeLhs {\n    constructor(type, options) {\n        super(type);\n        this._options = options || {splittingDistance: 3};\n    }\n\n    /**\n     * Group the nodes of my type into clusters, and return the cluster with\n     * the highest total score for that type.\n     */\n    fnodes(ruleset) {\n        // Get the nodes of the type:\n        const fnodesOfType = Array.from(super.fnodes(ruleset));\n        if (fnodesOfType.length === 0) {\n            return [];\n        }\n        // Cluster them:\n        const clusts = clusters(\n            fnodesOfType,\n            this._options.splittingDistance,\n            (a, b) => distance(a, b, this._options));\n        // Tag each cluster with the total of its nodes' scores:\n        const clustsAndSums = clusts.map(\n            clust => [clust,\n                      sum(clust.map(fnode => fnode.scoreFor(this._type)))]);\n        // Return the highest-scoring cluster:\n        return max(clustsAndSums, clustAndSum => clustAndSum[1])[0];\n    }\n}\n\nclass AndLhs extends Lhs {\n    constructor(lhss) {\n        super();\n\n        // For the moment, we accept only type()s as args. TODO: Generalize to\n        // type().max() and such later.\n        this._args = lhss.map(sideToTypeLhs);\n    }\n\n    *fnodes(ruleset) {\n        // Take an arbitrary one for starters. Optimization: we could always\n        // choose the pickiest one to start with.\n        const fnodes = this._args[0].fnodes(ruleset);\n        // Then keep only the fnodes that have the type of every other arg:\n        fnodeLoop: for (let fnode of fnodes) {\n            for (let otherLhs of this._args.slice(1)) {\n                // Optimization: could use a .hasTypeSoFar() below\n                if (!fnode.hasType(otherLhs.guaranteedType())) {\n                    // TODO: This is n^2. Why is there no set intersection in JS?!\n                    continue fnodeLoop;\n                }\n            }\n            yield fnode;\n        }\n    }\n\n    possibleTypeCombinations() {\n        return [this.typesMentioned()];\n    }\n\n    typesMentioned() {\n        return new NiceSet(this._args.map(arg => arg.guaranteedType()));\n    }\n}\n\nfunction sideToTypeLhs(side) {\n    const lhs = side.asLhs();\n    if (!(lhs.constructor === TypeLhs)) {\n        throw new Error('and() and nearest() support only simple type() calls as arguments for now.');\n        // TODO: Though we could solve this with a compilation step: and(type(A), type(B).max()) is equivalent to type(B).max() -> type(Bmax); and(type(A), type(Bmax)).\n        // In fact, we should be able to compile most (any?) arbitrary and()s, including nested ands and and(type(...).max(), ...) constructions into several and(type(A), type(B), ...) rules.\n    }\n    return lhs;\n}\n\nclass NearestLhs extends Lhs {\n    constructor([a, b, distance]) {\n        super();\n        this._a = sideToTypeLhs(a);\n        this._b = sideToTypeLhs(b);\n        this._distance = distance;\n    }\n\n    /**\n     * Return an iterable of {fnodes, transformer} pairs.\n     */\n    *fnodes(ruleset) {\n        // Go through all the left arg's nodes. For each one, find the closest\n        // right-arg's node. O(a * b). Once a right-arg's node is used, we\n        // don't eliminate it from consideration, because then order of left-\n        // args' nodes would matter.\n\n        // TODO: Still not sure how to get the distance to factor into the\n        // score unless we hard-code nearest() to do that. It's a\n        // matter of not being able to bind on the RHS to the output of the\n        // distance function on the LHS. Perhaps we could at least make\n        // distance part of the note and read it in a props() callback.\n\n        // We're assuming here that simple type() calls return just plain\n        // fnodes, not {fnode, rhsTransformer} pairs:\n        const as_ = this._a.fnodes(ruleset);\n        const bs = Array.from(this._b.fnodes(ruleset));\n        if (bs.length > 0) {\n            // If bs is empty, there can be no nearest nodes, so don't emit any.\n            for (const a of as_) {\n                const nearest = min(bs, b => this._distance(a, b));\n                yield {fnode: a,\n                       rhsTransformer: function setNoteIfEmpty(fact) {\n                           // If note is explicitly set by the RHS, let it take\n                           // precedence, even though that makes this entire LHS\n                           // pointless.\n                           if (fact.note === undefined) {\n                               fact.note = nearest;  // TODO: Wrap this in an object to make room to return distance later.\n                           }\n                           return fact;\n                       }};\n            }\n        }\n    }\n\n    checkFact(fact) {\n        // Barf if the fact doesn't set a type at least. It should be a *new* type or at least one that doesn't result in cycles, but we can't deduce that.\n    }\n\n    possibleTypeCombinations() {\n        return [new NiceSet([this._a.guaranteedType()])];\n    }\n\n    typesMentioned() {\n        return new NiceSet([this._a.guaranteedType(),\n                            this._b.guaranteedType()]);\n    }\n\n    guaranteedType() {\n        return this._a.guaranteedType();\n    }\n}\n\n// The right-hand side of a rule\n\n\nconst TYPE = 1;\nconst NOTE = 2;\nconst SCORE = 4;\nconst ELEMENT = 8;\nconst SUBFACTS = {\n    type: TYPE,\n    note: NOTE,\n    score: SCORE,\n    element: ELEMENT\n};\n\n/**\n * Expose the output of this rule's LHS as a \"final result\" to the surrounding\n * program. It will be available by calling :func:`~BoundRuleset.get` on the\n * ruleset and passing the key. You can run each node through a callback\n * function first by adding :func:`through()`, or you can run the entire set of\n * nodes through a callback function by adding :func:`allThrough()`.\n */\nfunction out(key) {\n    return new OutwardRhs(key);\n}\n\nclass InwardRhs {\n    constructor(calls = [], max = Infinity, types) {\n        this._calls = calls.slice();\n        this._max = max;  // max score\n        this._types = new NiceSet(types);  // empty set if unconstrained\n    }\n\n    /**\n     * Declare that the maximum returned subscore is such and such,\n     * which helps the optimizer plan efficiently. This doesn't force it to be\n     * true; it merely throws an error at runtime if it isn't. To lift an\n     * ``atMost`` constraint, call ``atMost()`` (with no args). The reason\n     * ``atMost`` and ``typeIn`` apply until explicitly cleared is so that, if\n     * someone used them for safety reasons on a lexically distant rule you are\n     * extending, you won't stomp on their constraint and break their\n     * invariants accidentally.\n     */\n    atMost(score) {\n        return new this.constructor(this._calls, score, this._types);\n    }\n\n    _checkAtMost(fact) {\n        if (fact.score !== undefined && fact.score > this._max) {\n            throw new Error(`Score of ${fact.score} exceeds the declared atMost(${this._max}).`);\n        }\n    }\n\n    /**\n      * Determine any of type, note, score, and element using a callback. This\n      * overrides any previous call to `props` and, depending on what\n      * properties of the callback's return value are filled out, may override\n      * the effects of other previous calls as well.\n      *\n      * The callback should return...\n      *\n      * * An optional :term:`subscore`\n      * * A type (required on ``dom(...)`` rules, defaulting to the input one on\n      *   ``type(...)`` rules)\n      * * Optional notes\n      * * An element, defaulting to the input one. Overriding the default\n      *   enables a callback to walk around the tree and say things about nodes\n      *   other than the input one.\n      */\n    props(callback) {\n        function getSubfacts(fnode) {\n            const subfacts = callback(fnode);\n            // Filter the raw result down to okayed properties so callbacks\n            // can't insert arbitrary keys (like conserveScore, which might\n            // mess up the optimizer).\n            for (let subfact in subfacts) {\n                if (!SUBFACTS.hasOwnProperty(subfact) || !(SUBFACTS[subfact] & getSubfacts.possibleSubfacts)) {\n                    // The ES5.1 spec says in 12.6.4 that it's fine to delete\n                    // as we iterate.\n                    delete subfacts[subfact];\n                }\n            }\n            return subfacts;\n        }\n        // Thse are the subfacts this call could affect:\n        getSubfacts.possibleSubfacts = TYPE | NOTE | SCORE | ELEMENT;\n        getSubfacts.kind = 'props';\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    /**\n     * Set the type applied to fnodes processed by this RHS.\n     */\n    type(theType) {\n        // In the future, we might also support providing a callback that receives\n        // the fnode and returns a type. We couldn't reason based on these, but the\n        // use would be rather a consise way to to override part of what a previous\n        // .props() call provides.\n\n        // Actually emit a given type.\n        function getSubfacts() {\n            return {type: theType};\n        }\n        getSubfacts.possibleSubfacts = TYPE;\n        getSubfacts.type = theType;\n        getSubfacts.kind = 'type';\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    /**\n     * Constrain this rule to emit 1 of a set of given types. Pass no args to lift\n     * a previous ``typeIn`` constraint, as you might do when basing a LHS on a\n     * common value to factor out repetition.\n     *\n     * ``typeIn`` is mostly a hint for the query planner when you're emitting types\n     * dynamically from ``props`` calls—in fact, an error will be raised if\n     * ``props`` is used without a ``typeIn`` or ``type`` to constrain it—but it\n     * also checks conformance at runtime to ensure validity.\n     */\n    typeIn(...types) {\n        // Rationale: If we used the spelling \"type('a', 'b', ...)\" instead of\n        // this, one might expect type('a', 'b').type(fn) to have the latter\n        // call override, while expecting type(fn).type('a', 'b') to keep both\n        // in effect. Then different calls to type() don't consistently\n        // override each other, and the rules get complicated. Plus you can't\n        // inherit a type constraint and then sub in another type-returning\n        // function that still gets the constraint applied.\n        return new this.constructor(this._calls,\n                                    this._max,\n                                    types);\n    }\n\n    /**\n     * Check a fact for conformance with any typeIn() call.\n     *\n     * @arg leftType the type of the LHS, which becomes my emitted type if the\n     *    fact doesn't specify one\n     */\n    _checkTypeIn(result, leftType) {\n        if (this._types.size > 0) {\n            if (result.type === undefined) {\n                if (!this._types.has(leftType)) {\n                    throw new Error(`A right-hand side claimed, via typeIn(...) to emit one of the types ${this._types} but actually inherited ${leftType} from the left-hand side.`);\n                }\n            } else if (!this._types.has(result.type)) {\n                throw new Error(`A right-hand side claimed, via typeIn(...) to emit one of the types ${this._types} but actually emitted ${result.type}.`);\n            }\n        }\n    }\n\n    /**\n     * Whatever the callback returns (even ``undefined``) becomes the note of\n     * the fact. This overrides any previous call to ``note``.\n     */\n    note(callback) {\n        function getSubfacts(fnode) {\n            return {note: callback(fnode)};\n        }\n        getSubfacts.possibleSubfacts = NOTE;\n        getSubfacts.kind = 'note';\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    /**\n     * Affect the confidence with which the input node should be considered a\n     * member of a type.\n     *\n     * The parameter is generally between 0 and 1 (inclusive), with 0 meaning\n     * the node does not have the \"smell\" this rule checks for and 1 meaning it\n     * does. The range between 0 and 1 is available to represent \"fuzzy\"\n     * confidences. If you have an unbounded range to compress down to [0, 1],\n     * consider using :func:`sigmoid` or a scaling thereof.\n     *\n     * Since every node can have multiple, independent scores (one for each\n     * type), this applies to the type explicitly set by the RHS or, if none,\n     * to the type named by the ``type`` call on the LHS. If the LHS has none\n     * because it's a ``dom(...)`` LHS, an error is raised.\n     *\n     * @arg {number|function} scoreOrCallback Can either be a static number,\n     *     generally 0 to 1 inclusive, or else a callback which takes the fnode\n     *     and returns such a number. If the callback returns a boolean, it is\n     *     cast to a number.\n     */\n    score(scoreOrCallback) {\n        let getSubfacts;\n\n        function getSubfactsFromNumber(fnode) {\n            return {score: scoreOrCallback};\n        }\n\n        function getSubfactsFromFunction(fnode) {\n            let result = scoreOrCallback(fnode);\n            if (typeof result === 'boolean') {\n                // Case bools to numbers for convenience. Boolean features are\n                // common. Don't cast other things, as it frustrates ruleset\n                // debugging.\n                result = Number(result);\n            }\n            return {score: result};\n        }\n\n        if (typeof scoreOrCallback === 'number') {\n            getSubfacts = getSubfactsFromNumber;\n        } else {\n            getSubfacts = getSubfactsFromFunction;\n        }\n        getSubfacts.possibleSubfacts = SCORE;\n        getSubfacts.kind = 'score';\n\n        return new this.constructor(this._calls.concat(getSubfacts),\n                                    this._max,\n                                    this._types);\n    }\n\n    // Future: why not have an .element() method for completeness?\n\n    // -------- Methods below this point are private to the framework. --------\n\n    /**\n     * Run all my props().type().note().score() stuff across a given fnode,\n     * enforce my max() stuff, and return a fact ({element, type, score,\n     * notes}) for incorporation into that fnode (or a different one, if\n     * element is specified). Any of the 4 fact properties can be missing;\n     * filling in defaults is a job for the caller.\n     *\n     * @arg leftType The type the LHS takes in\n     */\n    fact(fnode, leftType) {\n        const doneKinds = new Set();\n        const result = {};\n        let haveSubfacts = 0;\n        for (let call of reversed(this._calls)) {\n            // If we've already called a call of this kind, then forget it.\n            if (!doneKinds.has(call.kind)) {\n                doneKinds.add(call.kind);\n\n                if (~haveSubfacts & call.possibleSubfacts) {\n                    // This call might provide a subfact we are missing.\n                    const newSubfacts = call(fnode);\n\n                    // We start with an empty object, so we're okay here.\n                    // eslint-disable-next-line guard-for-in\n                    for (let subfact in newSubfacts) {\n                        // A props() callback could insert arbitrary keys into\n                        // the result, but it shouldn't matter, because nothing\n                        // pays any attention to them.\n                        if (!result.hasOwnProperty(subfact)) {\n                            result[subfact] = newSubfacts[subfact];\n                        }\n                        haveSubfacts |= SUBFACTS[subfact];\n                    }\n                }\n            }\n        }\n        this._checkAtMost(result);\n        this._checkTypeIn(result, leftType);\n        return result;\n    }\n\n    /**\n     * Return a record describing the types I might emit (which means either to\n     * add a type to a fnode or to output a fnode that already has that type).\n     * {couldChangeType: whether I might add a type to the fnode,\n     *  possibleTypes: If couldChangeType, the types I might emit; empty set if\n     *      we cannot infer it. If not couldChangeType, undefined.}\n     */\n    possibleEmissions() {\n        // If there is a typeIn() constraint or there is a type() call to the\n        // right of all props() calls, we have a constraint. We hunt for the\n        // tightest constraint we can find, favoring a type() call because it\n        // gives us a single type but then falling back to a typeIn().\n        let couldChangeType = false;\n        for (let call of reversed(this._calls)) {\n            if (call.kind === 'props') {\n                couldChangeType = true;\n                break;\n            } else if (call.kind === 'type') {\n                return {couldChangeType: true,\n                        possibleTypes: new Set([call.type])};\n            }\n        }\n        return {couldChangeType,\n                possibleTypes: this._types};\n    }\n}\n\nclass OutwardRhs {\n    constructor(key, through = x => x, allThrough = x => x) {\n        this.key = key;\n        this.callback = through;\n        this.allCallback = allThrough;\n    }\n\n    /**\n     * Append ``.through`` to :func:`out` to run each :term:`fnode` emitted\n     * from the LHS through an arbitrary function before returning it to the\n     * containing program. Example::\n     *\n     *     out('titleLengths').through(fnode => fnode.noteFor('title').length)\n     */\n    through(callback) {\n        return new this.constructor(this.key, callback, this.allCallback);\n    }\n\n    /**\n     * Append ``.allThrough`` to :func:`out` to run the entire iterable of\n     * emitted :term:`fnodes<fnode>` through an arbitrary function before\n     * returning them to the containing program. Example::\n     *\n     *     out('sortedTitles').allThrough(domSort)\n     */\n    allThrough(callback) {\n        return new this.constructor(this.key, this.callback, callback);\n    }\n\n    asRhs() {\n        return this;\n    }\n}\n\nfunction props(callback) {\n    return new Side({method: 'props', args: [callback]});\n}\n\n/** Constrain to an input type on the LHS, or apply a type on the RHS. */\nfunction type(theType) {\n    return new Side({method: 'type', args: [theType]});\n}\n\nfunction note(callback) {\n    return new Side({method: 'note', args: [callback]});\n}\n\nfunction score(scoreOrCallback) {\n    return new Side({method: 'score', args: [scoreOrCallback]});\n}\n\nfunction atMost(score) {\n    return new Side({method: 'atMost', args: [score]});\n}\n\nfunction typeIn(...types) {\n    return new Side({method: 'typeIn', args: types});\n}\n\n/**\n * Pull nodes that conform to multiple conditions at once.\n *\n * For example: ``and(type('title'), type('english'))``\n *\n * Caveats: ``and`` supports only simple ``type`` calls as arguments for now,\n * and it may fire off more rules as prerequisites than strictly necessary.\n * ``not`` and ``or`` don't exist yet, but you can express ``or`` the long way\n * around by having 2 rules with identical RHSs.\n */\nfunction and(...lhss) {\n    return new Side({method: 'and', args: lhss});\n}\n\n/**\n * Experimental. For each :term:`fnode` from ``typeCallA``, find the closest\n * node from ``typeCallB``, and attach it as a note. The note is attached to\n * the type specified by the RHS, defaulting to the type of ``typeCallA``. If\n * no nodes are emitted from ``typeCallB``, do nothing.\n *\n * For example... ::\n *\n *     nearest(type('image'), type('price'))\n *\n * The score of the ``typeCallA`` can be added to the new type's score by using\n * :func:`conserveScore` (though this routine has since been removed)::\n *\n *     rule(nearest(type('image'), type('price')),\n *          type('imageWithPrice').score(2).conserveScore())\n *\n * Caveats: ``nearest`` supports only simple ``type`` calls as arguments ``a``\n * and ``b`` for now.\n *\n * @arg distance {function} A function that takes 2 fnodes and returns a\n *     numerical distance between them. Included options are :func:`distance`,\n *     which is a weighted topological distance, and :func:`euclidean`, which\n *     is a spatial distance.\n */\nfunction nearest(typeCallA, typeCallB, distance = euclidean) {\n    return new Side({method: 'nearest', args: [typeCallA, typeCallB, distance]});\n}\n\n/**\n * A chain of calls that can be compiled into a Rhs or Lhs, depending on its\n * position in a Rule. This lets us use type() as a leading call for both RHSs\n * and LHSs. I would prefer to do this dynamically, but that wouldn't compile\n * down to old versions of ES.\n */\nclass Side {\n    constructor(...calls) {\n        // A \"call\" is like {method: 'dom', args: ['p.smoo']}.\n        this._calls = calls;\n    }\n\n    max() {\n        return this._and('max');\n    }\n\n    bestCluster(options) {\n        return this._and('bestCluster', options);\n    }\n\n    props(callback) {\n        return this._and('props', callback);\n    }\n\n    type(...types) {\n        return this._and('type', ...types);\n    }\n\n    note(callback) {\n        return this._and('note', callback);\n    }\n\n    score(scoreOrCallback) {\n        return this._and('score', scoreOrCallback);\n    }\n\n    atMost(score) {\n        return this._and('atMost', score);\n    }\n\n    typeIn(...types) {\n        return this._and('typeIn', ...types);\n    }\n\n    and(...lhss) {\n        return this._and('and', lhss);\n    }\n\n    _and(method, ...args) {\n        return new this.constructor(...this._calls.concat({method, args}));\n    }\n\n    asLhs() {\n        return this._asSide(Lhs.fromFirstCall(this._calls[0]), this._calls.slice(1));\n    }\n\n    asRhs() {\n        return this._asSide(new InwardRhs(), this._calls);\n    }\n\n    _asSide(side, calls) {\n        for (let call of calls) {\n            side = side[call.method](...call.args);\n        }\n        return side;\n    }\n\n    when(pred) {\n        return this._and('when', pred);\n    }\n}\n\n/**\n * A wrapper around a DOM node, storing :term:`types<type>`,\n * :term:`scores<score>`, and :term:`notes<note>` that apply to it\n */\nclass Fnode {\n    /**\n     * @arg element The DOM element described by the fnode.\n     * @arg ruleset The ruleset which created the fnode.\n     */\n    constructor(element, ruleset) {\n        if (element === undefined) {\n            throw new Error(\"Someone tried to make a fnode without specifying the element they're talking about.\");\n        }\n        /**\n         * The raw DOM element this fnode describes\n         */\n        this.element = element;\n        this._ruleset = ruleset;\n\n        // A map of type => {score: number, note: anything}. `score` is always\n        // present and defaults to 1. A note is set iff `note` is present and\n        // not undefined.\n        this._types = new Map();\n\n        // Note: conserveScore() is temporarily absent in 3.0.\n        //\n        // By default, a fnode has an independent score for each of its types.\n        // However, a RHS can opt to conserve the score of an upstream type,\n        // carrying it forward into another type. To avoid runaway scores in\n        // the case that multiple rules choose to do this, we limit the\n        // contribution of an upstream type's score to being multiplied in a\n        // single time. In this set, we keep track of which upstream types'\n        // scores have already been multiplied into each type. LHS fnode => Set\n        // of types whose score for that node have been multiplied into this\n        // node's score.\n        this._conservedScores = new Map();\n    }\n\n    /**\n     * Return whether the given type is one of the ones attached to the wrapped\n     * HTML node.\n     */\n    hasType(type) {\n        // Run type(theType) against the ruleset to make sure this doesn't\n        // return false just because we haven't lazily run certain rules yet.\n        this._computeType(type);\n        return this._types.has(type);\n    }\n\n    /**\n     * Return the confidence, in the range (0, 1), that the fnode belongs to the\n     * given type, 0 by default.\n     */\n    scoreFor(type) {\n        this._computeType(type);\n        return sigmoid(this._ruleset.weightedScore(this.scoresSoFarFor(type)) +\n                       getDefault(this._ruleset.biases, type, () => 0));\n    }\n\n    /**\n     * Return the fnode's note for the given type, ``undefined`` if none.\n     */\n    noteFor(type) {\n        this._computeType(type);\n        return this._noteSoFarFor(type);\n    }\n\n    /**\n     * Return whether this fnode has a note for the given type.\n     *\n     * ``undefined`` is not considered a note and may be overwritten with\n     * impunity.\n     */\n    hasNoteFor(type) {\n        this._computeType(type);\n        return this._hasNoteSoFarFor(type);\n    }\n\n    // -------- Methods below this point are private to the framework. --------\n\n    /**\n     * Return an iterable of the types tagged onto me by rules that have\n     * already executed.\n     */\n    typesSoFar() {\n        return this._types.keys();\n    }\n\n    _noteSoFarFor(type) {\n        return this._typeRecordForGetting(type).note;\n    }\n\n    _hasNoteSoFarFor(type) {\n        return this._noteSoFarFor(type) !== undefined;\n    }\n\n    /**\n     * Return the score thus far computed on me for a certain type. Doesn't\n     * implicitly run any rules. If no score has yet been determined for the\n     * given type, return undefined.\n     */\n    scoresSoFarFor(type) {\n        return this._typeRecordForGetting(type).score;\n    }\n\n    /**\n     * Add a given number to one of our per-type scores. Implicitly assign us\n     * the given type. Keep track of which rule it resulted from so we can\n     * later mess with the coeffs.\n     */\n    addScoreFor(type, score, ruleName) {\n        this._typeRecordForSetting(type).score.set(ruleName, score);\n    }\n\n    /**\n     * Set the note attached to one of our types. Implicitly assign us that\n     * type if we don't have it already.\n     */\n    setNoteFor(type, note) {\n        if (this._hasNoteSoFarFor(type)) {\n            if (note !== undefined) {\n                throw new Error(`Someone (likely the right-hand side of a rule) tried to add a note of type ${type} to an element, but one of that type already exists. Overwriting notes is not allowed, since it would make the order of rules matter.`);\n            }\n            // else the incoming note is undefined and we already have the\n            // type, so it's a no-op\n        } else {\n            // Apply either a type and note or just a type (which means a note\n            // that is undefined):\n            this._typeRecordForSetting(type).note = note;\n        }\n    }\n\n    /**\n     * Return a score/note record for a type, creating it if it doesn't exist.\n     */\n    _typeRecordForSetting(type) {\n        return setDefault(this._types, type, () => ({score: new Map()}));\n    }\n\n    /**\n     * Manifest a temporary type record for reading, working around the lack of\n     * a .? operator in JS.\n     */\n    _typeRecordForGetting(type) {\n        return getDefault(this._types, type, () => ({score: new Map()}));\n    }\n\n    /**\n     * Make sure any scores, notes, and type-tagging for the given type are\n     * computed for my element.\n     */\n    _computeType(theType) {\n        if (!this._types.has(theType)) {  // Prevent infinite recursion when an A->A rule looks at A's note in a callback.\n            this._ruleset.get(type(theType));\n        }\n    }\n}\n\n/**\n * Construct and return the proper type of rule class based on the\n * inwardness/outwardness of the RHS.\n *\n * @arg lhs {Lhs} The left-hand side of the rule\n * @arg rhs {Rhs} The right-hand side of the rule\n * @arg options {object} Other, optional information about the rule.\n *     Currently, the only recognized option is ``name``, which points to a\n *     string that uniquely identifies this rule in a ruleset. The name\n *     correlates this rule with one of the coefficients passed into\n *     :func:`ruleset`. If no name is given, an identifier is assigned based on\n *     the index of this rule in the ruleset, but that is, of course, brittle.\n */\nfunction rule(lhs, rhs, options) {\n    // Since out() is a valid call only on the RHS (unlike type()), we can take\n    // a shortcut here: any outward RHS will already be an OutwardRhs; we don't\n    // need to sidetrack it through being a Side. And OutwardRhs has an asRhs()\n    // that just returns itself.\n    if (typeof rhs === 'string') {\n        rhs = out(rhs);\n    }\n    return new ((rhs instanceof OutwardRhs) ? OutwardRule : InwardRule)(lhs, rhs, options);\n}\n\nlet nextRuleNumber = 0;\nfunction newInternalRuleName() {\n    return '_' + nextRuleNumber++;\n}\n\n/**\n * We place the in/out distinction in Rules because it determines whether the\n * RHS result is cached, and Rules are responsible for maintaining the rulewise\n * cache ruleset.ruleCache.\n */\nclass Rule {  // abstract\n    constructor(lhs, rhs, options) {\n        this.lhs = lhs.asLhs();\n        this.rhs = rhs.asRhs();\n        // TODO: Make auto-generated rule names be based on the out types of\n        // the rules, e.g. _priceish_4. That way, adding rules for one type\n        // won't make the coeffs misalign for another.\n        this.name = (options ? options.name : undefined) || newInternalRuleName();\n    }\n\n    /**\n     * Return a NiceSet of the rules that this one shallowly depends on in the\n     * given ruleset. In a BoundRuleset, this may include rules that have\n     * already been executed.\n     *\n     * Depend on emitters of any LHS type this rule finalizes. (See\n     * _typesFinalized for a definition.) Depend on adders of any other LHS\n     * types (because, after all, we need to know what nodes have that type in\n     * order to find the set of LHS nodes). This works for simple rules and\n     * complex ones like and().\n     *\n     * Specific examples (where A is a type):\n     * * A.max->* depends on anything emitting A.\n     * * Even A.max->A depends on A emitters, because we have to have all the\n     *   scores factored in first. For example, what if we did\n     *   max(A)->score(.5)?\n     * * A->A depends on anything adding A.\n     * * A->(something other than A) depends on anything emitting A. (For\n     *   example, we need the A score finalized before we could transfer it to\n     *   B using conserveScore().)\n     * * A->out() also depends on anything emitting A. Fnode methods aren't\n     *   smart enough to lazily run emitter rules as needed. We could make them\n     *   so if it was shown to be an advantage.\n     */\n    prerequisites(ruleset) {\n        // Optimization: we could cache the result of this when in a compiled (immutable) ruleset.\n\n        // Extend prereqs with rules derived from each of the given types. If\n        // no rules are found, raise an exception, as that indicates a\n        // malformed ruleset.\n        function extendOrThrow(prereqs, types, ruleGetter, verb) {\n            for (let type of types) {\n                const rules = ruleGetter(type);\n                if (rules.length > 0) {\n                    prereqs.extend(rules);\n                } else {\n                    throw new Error(`No rule ${verb} the \"${type}\" type, but another rule needs it as input.`);\n                }\n            }\n        }\n\n        const prereqs = new NiceSet();\n\n        // Add finalized types:\n        extendOrThrow(prereqs, this._typesFinalized(), type => ruleset.inwardRulesThatCouldEmit(type), 'emits');\n\n        // Add mentioned types:\n        // We could say this.lhs.typesMentioned().minus(typesFinalized) as an\n        // optimization. But since types mentioned are a superset of types\n        // finalized and rules adding are a subset of rules emitting, we get\n        // the same result without.\n        extendOrThrow(prereqs, this.lhs.typesMentioned(), type => ruleset.inwardRulesThatCouldAdd(type), 'adds');\n\n        return prereqs;\n    }\n\n    /**\n     * Return the types that this rule finalizes.\n     *\n     * To \"finalize\" a type means to make sure we're finished running all\n     * possible rules that might change a node's score or notes w.r.t. a given\n     * type. This is generally done because we're about to use those data for\n     * something, like computing a new type's score or or an aggregate\n     * function. Exhaustively, we're about to...\n     * * change the type of the nodes or\n     * * aggregate all nodes of a type\n     *\n     * This base-class implementation just returns what aggregate functions\n     * need, since that need spans inward and outward rules.\n     *\n     * @return Set of types\n     */\n    _typesFinalized() {\n        // Get the types that are fed to aggregate functions. Aggregate\n        // functions are more demanding than a simple type() LHS. A type() LHS\n        // itself does not finalize its nodes because the things it could do to\n        // them without changing their type (adding notes, adding to score)\n        // are immutable or commutative (respectively). Thus, we require a RHS\n        // type change in order to require finalization of a simple type()\n        // mention. A max(B), OTOH, is not commutative with other B->B rules\n        // (imagine type(B).max()->score(.5)), so it must depend on B emitters\n        // and thus finalize B. (This will have to be relaxed or rethought when\n        // we do the max()/atMost() optimization. Perhaps we can delegate to\n        // aggregate functions up in Rule.prerequisites() to ask what their\n        // prereqs are. If they implement such an optimization, they can reply.\n        // Otherwise, we can assume they are all the nodes of their type.)\n        //\n        // TODO: Could arbitrary predicates (once we implement those) matter\n        // too? Maybe it's not just aggregations.\n        const type = this.lhs.aggregatedType();\n        return (type === undefined) ? new NiceSet() : new NiceSet([type]);\n    }\n}\n\n/**\n * A normal rule, whose results head back into the Fathom knowledgebase, to be\n * operated on by further rules.\n */\nclass InwardRule extends Rule {\n    // TODO: On construct, complain about useless rules, like a dom() rule that\n    // doesn't assign a type.\n\n    /**\n     * Return an iterable of the fnodes emitted by the RHS of this rule.\n     * Side effect: update ruleset's store of fnodes, its accounting of which\n     * rules are done executing, and its cache of results per type.\n     */\n    results(ruleset) {\n        if (ruleset.doneRules.has(this)) {  // shouldn't happen\n            throw new Error('A bug in Fathom caused results() to be called on an inward rule twice. That could cause redundant score contributions, etc.');\n        }\n        const self = this;\n        // For now, we consider most of what a LHS computes to be cheap, aside\n        // from type() and type().max(), which are cached by their specialized\n        // LHS subclasses.\n        const leftResults = this.lhs.fnodes(ruleset);\n        // Avoid returning a single fnode more than once. LHSs uniquify\n        // themselves, but the RHS can change the element it's talking\n        // about and thus end up with dupes.\n        const returnedFnodes = new Set();\n\n        // Merge facts into fnodes:\n        forEach(\n            // leftResult can be either a fnode or a {fnode, rhsTransformer} pair.\n            function updateFnode(leftResult) {\n                const leftType = self.lhs.guaranteedType();\n                // Get a fnode and a RHS transformer, whether a plain fnode is\n                // returned or a {fnode, rhsTransformer} pair:\n                const {fnode: leftFnode = leftResult, rhsTransformer = identity} = leftResult;\n                // Grab the fact from the RHS, and run the LHS's optional\n                // transformer over it to pick up anything special it wants to\n                // do:\n                const fact = rhsTransformer(self.rhs.fact(leftFnode, leftType));\n                self.lhs.checkFact(fact);\n                const rightFnode = ruleset.fnodeForElement(fact.element || leftFnode.element);\n                // If the RHS doesn't specify a type, default to the\n                // type of the LHS, if any:\n                const rightType = fact.type || self.lhs.guaranteedType();\n                if (fact.score !== undefined) {\n                    if (rightType !== undefined) {\n                        rightFnode.addScoreFor(rightType, fact.score, self.name);\n                    } else {\n                        throw new Error(`The right-hand side of a rule specified a score (${fact.score}) with neither an explicit type nor one we could infer from the left-hand side.`);\n                    }\n                }\n                if (fact.type !== undefined || fact.note !== undefined) {\n                    // There's a reason to call setNoteFor.\n                    if (rightType === undefined) {\n                        throw new Error(`The right-hand side of a rule specified a note (${fact.note}) with neither an explicit type nor one we could infer from the left-hand side. Notes are per-type, per-node, so that's a problem.`);\n                    } else {\n                        rightFnode.setNoteFor(rightType, fact.note);\n                    }\n                }\n                returnedFnodes.add(rightFnode);\n            },\n            leftResults);\n\n        // Update ruleset lookup tables.\n        // First, mark this rule as done:\n        ruleset.doneRules.add(this);\n        // Then, stick each fnode in typeCache under all applicable types.\n        // Optimization: we really only need to loop over the types\n        // this rule can possibly add.\n        for (let fnode of returnedFnodes) {\n            for (let type of fnode.typesSoFar()) {\n                setDefault(ruleset.typeCache, type, () => new Set()).add(fnode);\n            }\n        }\n        return returnedFnodes.values();\n    }\n\n    /**\n     * Return a Set of the types that could be emitted back into the system.\n     * To emit a type means to either to add it to a fnode emitted from the RHS\n     * or to leave it on such a fnode where it already exists.\n     */\n    typesItCouldEmit() {\n        const rhs = this.rhs.possibleEmissions();\n        if (!rhs.couldChangeType && this.lhs.guaranteedType() !== undefined) {\n            // It's a b -> b rule.\n            return new Set([this.lhs.guaranteedType()]);\n        } else if (rhs.possibleTypes.size > 0) {\n            // We can prove the type emission from the RHS alone.\n            return rhs.possibleTypes;\n        } else {\n            throw new Error('Could not determine the emitted type of a rule because its right-hand side calls props() without calling typeIn().');\n        }\n    }\n\n    /**\n     * Return a Set of types I could add to fnodes I output (where the fnodes\n     * did not already have them).\n     */\n    typesItCouldAdd() {\n        const ret = new Set(this.typesItCouldEmit());\n        ret.delete(this.lhs.guaranteedType());\n        return ret;\n    }\n\n    /**\n     * Add the types we could change to the superclass's result.\n     */\n    _typesFinalized() {\n        const self = this;\n        function typesThatCouldChange() {\n            const ret = new NiceSet();\n\n            // Get types that could change:\n            const emissions = self.rhs.possibleEmissions();\n            if (emissions.couldChangeType) {\n                // Get the possible guaranteed combinations of types on the LHS\n                // (taking just this LHS into account). For each combo, if the RHS\n                // adds a type that's not in the combo, the types in the combo get\n                // unioned into ret.\n                for (let combo of self.lhs.possibleTypeCombinations()) {\n                    for (let rhsType of emissions.possibleTypes) {\n                        if (!combo.has(rhsType)) {\n                            ret.extend(combo);\n                            break;\n                        }\n                    }\n                }\n            }\n            // Optimization: the possible combos could be later expanded to be\n            // informed by earlier rules which add the types mentioned in the LHS.\n            // If the only way for something to get B is to have Q first, then we\n            // can add Q to each combo and end up with fewer types finalized. Would\n            // this imply the existence of a Q->B->Q cycle and thus be impossible?\n            // Think about it. If we do this, we can centralize that logic here,\n            // rather than repeating it in all the Lhs subclasses).\n            return ret;\n        }\n\n        return typesThatCouldChange().extend(super._typesFinalized());\n    }\n}\n\n/**\n * A rule whose RHS is an out(). This represents a final goal of a ruleset.\n * Its results go out into the world, not inward back into the Fathom\n * knowledgebase.\n */\nclass OutwardRule extends Rule {\n    /**\n     * Compute the whole thing, including any .through() and .allThrough().\n     * Do not mark me done in ruleset.doneRules; out rules are never marked as\n     * done so they can be requested many times without having to cache their\n     * (potentially big, since they aren't necessarily fnodes?) results. (We\n     * can add caching later if it proves beneficial.)\n     */\n    results(ruleset) {\n        /**\n         * From a LHS's ``{fnode, rhsTransform}`` object or plain fnode, pick off just\n         * the fnode and return it.\n         */\n        function justFnode(fnodeOrStruct) {\n            return (fnodeOrStruct instanceof Fnode) ? fnodeOrStruct : fnodeOrStruct.fnode;\n        }\n\n        return this.rhs.allCallback(map(this.rhs.callback, map(justFnode, this.lhs.fnodes(ruleset))));\n    }\n\n    /**\n     * @return the key under which the output of this rule will be available\n     */\n    key() {\n        return this.rhs.key;\n    }\n\n    /**\n     * OutwardRules finalize all types mentioned.\n     */\n    _typesFinalized() {\n        return this.lhs.typesMentioned().extend(super._typesFinalized());\n    }\n}\n\n/**\n * A shortcut for creating a new :class:`Ruleset`, for symmetry with\n * :func:`rule`\n */\nfunction ruleset(rules, coeffs = [], biases = []) {\n    return new Ruleset(rules, coeffs, biases);\n}\n\n/**\n * An unbound ruleset. When you bind it by calling :func:`~Ruleset.against()`,\n * the resulting :class:`BoundRuleset` will be immutable.\n */\nclass Ruleset {\n    /**\n     * @arg rules {Array} Rules returned from :func:`rule`\n     * @arg coeffs {Map} A map of rule names to numerical weights, typically\n     *     returned by the :doc:`trainer<training>`. Example:\n     *     ``[['someRuleName', 5.04], ...]``. If not given, coefficients\n     *     default to 1.\n     * @arg biases {object} A map of type names to neural-net biases. These\n     *      enable accurate confidence estimates. Example: ``[['someType',\n     *      -2.08], ...]``. If absent, biases default to 0.\n     */\n    constructor(rules, coeffs = [], biases = []) {\n        this._inRules = [];\n        this._outRules = new Map();  // key -> rule\n        this._rulesThatCouldEmit = new Map();  // type -> [rules]\n        this._rulesThatCouldAdd = new Map();  // type -> [rules]\n        // Private to the framework:\n        this._coeffs = new Map(coeffs);  // rule name => coefficient\n        this.biases = new Map(biases);  // type name => bias\n\n        // Separate rules into out ones and in ones, and sock them away. We do\n        // this here so mistakes raise errors early.\n        for (let rule of rules) {\n            if (rule instanceof InwardRule) {\n                this._inRules.push(rule);\n\n                // Keep track of what inward rules can emit or add:\n                // TODO: Combine these hashes for space efficiency:\n                const emittedTypes = rule.typesItCouldEmit();\n                for (let type of emittedTypes) {\n                    setDefault(this._rulesThatCouldEmit, type, () => []).push(rule);\n                }\n                for (let type of rule.typesItCouldAdd()) {\n                    setDefault(this._rulesThatCouldAdd, type, () => []).push(rule);\n                }\n            } else if (rule instanceof OutwardRule) {\n                this._outRules.set(rule.key(), rule);\n            } else {\n                throw new Error(`This element of ruleset()'s first param wasn't a rule: ${rule}`);\n            }\n        }\n    }\n\n    /**\n     * Commit this ruleset to running against a specific DOM tree or subtree.\n     *\n     * When run against a subtree, the root of the subtree is not considered as\n     * a possible match.\n     *\n     * This doesn't actually modify the Ruleset but rather returns a fresh\n     * :class:`BoundRuleset`, which contains caches and other stateful, per-DOM\n     * bric-a-brac.\n     */\n    against(doc) {\n        return new BoundRuleset(doc,\n                                this._inRules,\n                                this._outRules,\n                                this._rulesThatCouldEmit,\n                                this._rulesThatCouldAdd,\n                                this._coeffs,\n                                this.biases);\n    }\n\n    /**\n     * Return all the rules (both inward and outward) that make up this ruleset.\n     *\n     * From this, you can construct another ruleset like this one but with your\n     * own rules added.\n     */\n    rules() {\n        return Array.from([...this._inRules, ...this._outRules.values()]);\n    }\n}\n\n/**\n * A ruleset that is earmarked to analyze a certain DOM\n *\n * Carries a cache of rule results on that DOM. Typically comes from\n * :meth:`~Ruleset.against`.\n */\nclass BoundRuleset {\n    /**\n     * @arg inRules {Array} Non-out() rules\n     * @arg outRules {Map} Output key -> out() rule\n     */\n    constructor(doc, inRules, outRules, rulesThatCouldEmit, rulesThatCouldAdd, coeffs, biases) {\n        this.doc = doc;\n        this._inRules = inRules;\n        this._outRules = outRules;\n        this._rulesThatCouldEmit = rulesThatCouldEmit;\n        this._rulesThatCouldAdd = rulesThatCouldAdd;\n        this._coeffs = coeffs;\n\n        // Private, for the use of only helper classes:\n        this.biases = biases;\n        this._clearCaches();\n        this.elementCache = new WeakMap();  // DOM element => fnode about it\n        this.doneRules = new Set();  // InwardRules that have been executed. OutwardRules can be executed more than once because they don't change any fnodes and are thus idempotent.\n    }\n\n    /**\n     * Change my coefficients and biases after construction.\n     *\n     * @arg coeffs See the :class:`Ruleset` constructor.\n     * @arg biases See the :class:`Ruleset` constructor.\n     */\n    setCoeffsAndBiases(coeffs, biases = []) {\n        // Destructuring assignment doesn't make it through rollup properly\n        // (https://github.com/rollup/rollup-plugin-commonjs/issues/358):\n        this._coeffs = new Map(coeffs);\n        this.biases = new Map(biases);\n        this._clearCaches();\n    }\n\n    /**\n     * Clear the typeCache and maxCache, usually in the wake of changing\n     * ``this._coeffs``, because both of thise depend on weighted scores.\n     */\n    _clearCaches() {\n        this.maxCache = new Map();  // type => Array of max fnode (or fnodes, if tied) of this type\n        this.typeCache = new Map();  // type => Set of all fnodes of this type found so far. (The dependency resolution during execution ensures that individual types will be comprehensive just in time.)\n    }\n\n    /**\n     * Return an array of zero or more fnodes.\n     * @arg thing {string|Lhs|Node} Can be\n     *\n     *       (1) A string which matches up with an \"out\" rule in the ruleset.\n     *           If the out rule uses through(), the results of through's\n     *           callback (which might not be fnodes) will be returned.\n     *       (2) An arbitrary LHS which we calculate and return the results of.\n     *       (3) A DOM node, for which we will return the corresponding fnode.\n     *\n     *     Results are cached for cases (1) and (3).\n     */\n    get(thing) {\n        if (typeof thing === 'string') {\n            if (this._outRules.has(thing)) {\n                return Array.from(this._execute(this._outRules.get(thing)));\n            } else {\n                throw new Error(`There is no out() rule with key \"${thing}\".`);\n            }\n        } else if (isDomElement(thing)) {\n            // Return the fnode and let it run type(foo) on demand, as people\n            // ask it things like scoreFor(foo).\n            return this.fnodeForElement(thing);\n        } else if (thing.asLhs !== undefined) {\n            // Make a temporary out rule, and run it. This may add things to\n            // the ruleset's cache, but that's fine: it doesn't change any\n            // future results; it just might make them faster. For example, if\n            // you ask for .get(type('smoo')) twice, the second time will be a\n            // cache hit.\n            const outRule = rule(thing, out(Symbol('outKey')));\n            return Array.from(this._execute(outRule));\n        } else {\n            throw new Error('ruleset.get() expects a string, an expression like on the left-hand side of a rule, or a DOM node.');\n        }\n    }\n\n    /**\n     * Return the weighted sum of the per-rule, per-type scores from a fnode.\n     *\n     * @arg mapOfScores a Map of rule name to the [0, 1] score it computed for\n     *      the type in question\n     */\n    weightedScore(mapOfScores) {\n        let total = 0;\n        for (const [name, score] of mapOfScores) {\n            total += score * getDefault(this._coeffs, name, () => 1);\n        }\n        return total;\n    }\n\n    // Provide an opaque context object to be made available to all ranker\n    // functions.\n    // context (object) {\n    //     self.context = object;\n    // }\n\n    // -------- Methods below this point are private to the framework. --------\n\n    /**\n     * Return all the thus-far-unexecuted rules that will have to run to run\n     * the requested rule, in the form of Map(prereq: [rulesItIsNeededBy]).\n     */\n    _prerequisitesTo(rule, undonePrereqs = new Map()) {\n        for (let prereq of rule.prerequisites(this)) {\n            if (!this.doneRules.has(prereq)) {\n                // prereq is not already run. (If it were, we wouldn't care\n                // about adding it to the graph.)\n                const alreadyAdded = undonePrereqs.has(prereq);\n                setDefault(undonePrereqs, prereq, () => []).push(rule);\n\n                // alreadyAdded means we've already computed the prereqs of\n                // this prereq and added them to undonePrereqs. So, now\n                // that we've hooked up the rule to this prereq in the\n                // graph, we can stop. But, if we haven't, then...\n                if (!alreadyAdded) {\n                    this._prerequisitesTo(prereq, undonePrereqs);\n                }\n            }\n        }\n        return undonePrereqs;\n    }\n\n    /**\n     * Run the given rule (and its dependencies, in the proper order), and\n     * return its results.\n     *\n     * The caller is responsible for ensuring that _execute() is not called\n     * more than once for a given InwardRule, lest non-idempotent\n     * transformations, like score contributions, be applied to fnodes more\n     * than once.\n     *\n     * The basic idea is to sort rules in topological order (according to input\n     * and output types) and then run them. On top of that, we do some\n     * optimizations. We keep a cache of results by type (whether partial or\n     * comprehensive--either way, the topology ensures that any\n     * non-comprehensive typeCache entry is made comprehensive before another\n     * rule needs it). And we prune our search for prerequisite rules at the\n     * first encountered already-executed rule.\n     */\n    _execute(rule) {\n        const prereqs = this._prerequisitesTo(rule);\n        let sorted;\n        try {\n            sorted = [rule].concat(toposort(prereqs.keys(),\n                                            prereq => prereqs.get(prereq)));\n        } catch (exc) {\n            if (exc instanceof CycleError) {\n                throw new CycleError('There is a cyclic dependency in the ruleset.');\n            } else {\n                throw exc;\n            }\n        }\n        let fnodes;\n        for (let eachRule of reversed(sorted)) {\n            // Sock each set of results away in this.typeCache:\n            fnodes = eachRule.results(this);\n        }\n        return Array.from(fnodes);\n    }\n\n    /** @return {Rule[]} */\n    inwardRulesThatCouldEmit(type) {\n        return getDefault(this._rulesThatCouldEmit, type, () => []);\n    }\n\n    /** @return {Rule[]} */\n    inwardRulesThatCouldAdd(type) {\n        return getDefault(this._rulesThatCouldAdd, type, () => []);\n    }\n\n    /**\n     * @return the Fathom node that describes the given DOM element. This does\n     *     not trigger any execution, so the result may be incomplete.\n     */\n    fnodeForElement(element) {\n        return setDefault(this.elementCache,\n                          element,\n                          () => new Fnode(element, this));\n    }\n}\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nconst version = '3.7.3';\n\n\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/fathom.mjs?");

/***/ }),

/***/ "./firefox-ios/Client/Assets/CC_Script sync .mjs$":
/*!**********************************************************************!*\
  !*** ./firefox-ios/Client/Assets/CC_Script/ sync nonrecursive .mjs$ ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./AddressMetaData.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressMetaData.sys.mjs\",\n\t\"./AddressMetaDataExtension.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressMetaDataExtension.sys.mjs\",\n\t\"./AddressMetaDataLoader.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressMetaDataLoader.sys.mjs\",\n\t\"./AddressRecord.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AddressRecord.sys.mjs\",\n\t\"./AutofillTelemetry.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/AutofillTelemetry.sys.mjs\",\n\t\"./Constants.ios.mjs\": \"./firefox-ios/Client/Assets/CC_Script/Constants.ios.mjs\",\n\t\"./CreditCard.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/CreditCard.sys.mjs\",\n\t\"./CreditCardRecord.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/CreditCardRecord.sys.mjs\",\n\t\"./CreditCardRuleset.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/CreditCardRuleset.sys.mjs\",\n\t\"./FieldScanner.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FieldScanner.sys.mjs\",\n\t\"./FormAutofill.ios.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.ios.sys.mjs\",\n\t\"./FormAutofill.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofill.sys.mjs\",\n\t\"./FormAutofillChild.ios.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillChild.ios.sys.mjs\",\n\t\"./FormAutofillExtras.ios.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillExtras.ios.mjs\",\n\t\"./FormAutofillHandler.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillHandler.sys.mjs\",\n\t\"./FormAutofillHeuristics.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillHeuristics.sys.mjs\",\n\t\"./FormAutofillNameUtils.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillNameUtils.sys.mjs\",\n\t\"./FormAutofillSection.ios.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.ios.sys.mjs\",\n\t\"./FormAutofillSection.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillSection.sys.mjs\",\n\t\"./FormAutofillUtils.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormAutofillUtils.sys.mjs\",\n\t\"./FormLikeFactory.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormLikeFactory.sys.mjs\",\n\t\"./FormStateManager.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/FormStateManager.sys.mjs\",\n\t\"./Helpers.ios.mjs\": \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\",\n\t\"./HeuristicsRegExp.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/HeuristicsRegExp.sys.mjs\",\n\t\"./LabelUtils.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/LabelUtils.sys.mjs\",\n\t\"./LoginManager.shared.mjs\": \"./firefox-ios/Client/Assets/CC_Script/LoginManager.shared.mjs\",\n\t\"./PhoneNumber.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PhoneNumber.sys.mjs\",\n\t\"./PhoneNumberMetaData.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PhoneNumberMetaData.sys.mjs\",\n\t\"./PhoneNumberNormalizer.sys.mjs\": \"./firefox-ios/Client/Assets/CC_Script/PhoneNumberNormalizer.sys.mjs\",\n\t\"./fathom.mjs\": \"./firefox-ios/Client/Assets/CC_Script/fathom.mjs\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./firefox-ios/Client/Assets/CC_Script sync .mjs$\";\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Assets/CC_Script/_sync_nonrecursive_.mjs$?");

/***/ }),

/***/ "./firefox-ios/Client/Frontend/UserContent/UserScripts/AddressManageForm/AddressManageForm.mjs":
/*!*****************************************************************************************************!*\
  !*** ./firefox-ios/Client/Frontend/UserContent/UserScripts/AddressManageForm/AddressManageForm.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var resource_gre_modules_shared_Helpers_ios_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resource://gre/modules/shared/Helpers.ios.mjs */ \"./firefox-ios/Client/Assets/CC_Script/Helpers.ios.mjs\");\n/* harmony import */ var resource_gre_modules_shared_addressFormLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resource://gre/modules/shared/addressFormLayout.js */ \"./firefox-ios/Client/Assets/CC_Script/addressFormLayout.js\");\n\n\n\n// TMP: This should be sent by swift localized ofc\nconst l10nStrings = {\n  \"autofill-add-address-title\": \"Add address\",\n  \"autofill-manage-addresses-title\": \"Saved addresses\",\n  \"autofill-address-given-name\": \"First Name\",\n  \"autofill-address-additional-name\": \"Middle Name\",\n  \"autofill-address-family-name\": \"Last Name\",\n  \"autofill-address-name\": \"Name\",\n  \"autofill-address-organization\": \"Organization\",\n  \"autofill-address-street\": \"Street Address\",\n  \"autofill-address-state\": \"State\",\n  \"autofill-address-province\": \"Province\",\n  \"autofill-address-city\": \"City\",\n  \"autofill-address-country\": \"Country or Region\",\n  \"autofill-address-zip\": \"ZIP Code\",\n  \"autofill-address-postal-code\": \"Postal Code\",\n  \"autofill-address-email\": \"Email\",\n  \"autofill-address-tel\": \"Phone\",\n  \"autofill-edit-address-title\": \"Edit address\",\n  \"autofill-address-neighborhood\": \"Neighborhood\",\n  \"autofill-address-village-township\": \"Village or Township\",\n  \"autofill-address-island\": \"Island\",\n  \"autofill-address-townland\": \"Townland\",\n  \"autofill-address-district\": \"District\",\n  \"autofill-address-county\": \"County\",\n  \"autofill-address-post-town\": \"Post town\",\n  \"autofill-address-suburb\": \"Suburb\",\n  \"autofill-address-parish\": \"Parish\",\n  \"autofill-address-prefecture\": \"Prefecture\",\n  \"autofill-address-area\": \"Area\",\n  \"autofill-address-do-si\": \"Do/Si\",\n  \"autofill-address-department\": \"Department\",\n  \"autofill-address-emirate\": \"Emirate\",\n  \"autofill-address-oblast\": \"Oblast\",\n  \"autofill-address-pin\": \"Pin\",\n  \"autofill-address-eircode\": \"Eircode\",\n  \"autofill-address-country-only\": \"Country\",\n  \"autofill-cancel-button\": \"Cancel\",\n  \"autofill-save-button\": \"Save\",\n};\n\nwindow.init = (record) => {\n  (0,resource_gre_modules_shared_addressFormLayout_js__WEBPACK_IMPORTED_MODULE_1__.createFormLayoutFromRecord)(\n    document.querySelector(\"form\"),\n    record,\n    l10nStrings\n  );\n\n  document.querySelectorAll(\"input,select,textarea\").forEach((el) => {\n    el.readOnly = true;\n  });\n\n  // Hacky way to size textareas\n  // TODO: Fix this with a proper solution if possible\n  document.querySelectorAll(\"textarea\").forEach((el) => {\n    el.rows = 2;\n    el.addEventListener(\"input\", () => {\n      el.parentNode.dataset.value = el.value;\n    });\n  });\n};\n\nwindow.toggleEditMode = () => {\n  const elements = document.querySelectorAll(\"input,select,textarea\");\n  elements.forEach((element) => {\n    element.readOnly = false;\n  });\n\n  elements[0].focus();\n};\n\n\n//# sourceURL=webpack://firefox-ios/./firefox-ios/Client/Frontend/UserContent/UserScripts/AddressManageForm/AddressManageForm.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./firefox-ios/Client/Frontend/UserContent/UserScripts/AddressManageForm/AddressManageForm.mjs");
/******/ 	
/******/ })()
;